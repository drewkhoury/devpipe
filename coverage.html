
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>generate-docs: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/drew/devpipe/cmd/generate-docs/main.go (0.0%)</option>
				
				<option value="file1">github.com/drew/devpipe/cmd/sarif-viewer/main.go (0.0%)</option>
				
				<option value="file2">github.com/drew/devpipe/internal/config/config.go (97.5%)</option>
				
				<option value="file3">github.com/drew/devpipe/internal/config/defaults.go (100.0%)</option>
				
				<option value="file4">github.com/drew/devpipe/internal/config/validate.go (99.2%)</option>
				
				<option value="file5">github.com/drew/devpipe/internal/dashboard/dashboard.go (86.7%)</option>
				
				<option value="file6">github.com/drew/devpipe/internal/dashboard/html.go (83.3%)</option>
				
				<option value="file7">github.com/drew/devpipe/internal/dashboard/ide.go (95.5%)</option>
				
				<option value="file8">github.com/drew/devpipe/internal/dashboard/phases.go (92.3%)</option>
				
				<option value="file9">github.com/drew/devpipe/internal/git/git.go (82.2%)</option>
				
				<option value="file10">github.com/drew/devpipe/internal/metrics/junit.go (100.0%)</option>
				
				<option value="file11">github.com/drew/devpipe/internal/metrics/sarif.go (100.0%)</option>
				
				<option value="file12">github.com/drew/devpipe/internal/sarif/sarif.go (85.9%)</option>
				
				<option value="file13">github.com/drew/devpipe/internal/ui/animated.go (84.8%)</option>
				
				<option value="file14">github.com/drew/devpipe/internal/ui/colors.go (100.0%)</option>
				
				<option value="file15">github.com/drew/devpipe/internal/ui/progress.go (97.9%)</option>
				
				<option value="file16">github.com/drew/devpipe/internal/ui/renderer.go (89.2%)</option>
				
				<option value="file17">github.com/drew/devpipe/internal/ui/tty.go (83.3%)</option>
				
				<option value="file18">github.com/drew/devpipe/main.go (22.7%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Copyright 2025 Andrew Khoury
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// generate-docs generates documentation from config structs using reflection
package main

import (
        "encoding/json"
        "fmt"
        "os"
        "reflect"
        "strings"

        "github.com/drew/devpipe/internal/config"
)

// FieldDoc represents documentation for a single field
type FieldDoc struct {
        Name        string
        Type        string
        Required    bool
        Default     string
        Description string
        ValidValues []string
}

// SectionDoc represents documentation for a config section
type SectionDoc struct {
        Name        string
        Description string
        Fields      []FieldDoc
}

func main() <span class="cov0" title="0">{
        if len(os.Args) &gt; 1 &amp;&amp; os.Args[1] == "--help" </span><span class="cov0" title="0">{
                fmt.Println("Usage: generate-docs")
                fmt.Println("Generates documentation from config structs:")
                fmt.Println("  - config.example.toml")
                fmt.Println("  - config.schema.json")
                fmt.Println("  - docs/configuration.md")
                fmt.Println("  - docs/cli-reference.md")
                fmt.Println("  - docs/config-validation.md")
                return
        }</span>

        // Define documentation structure
        <span class="cov0" title="0">docs := buildDocumentation()

        // Generate outputs
        if err := generateExampleTOML(docs); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error generating config.example.toml: %v\n", err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">fmt.Println("âœ“ Generated config.example.toml")

        if err := generateJSONSchema(docs); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error generating config.schema.json: %v\n", err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">fmt.Println("âœ“ Generated config.schema.json")

        if err := generateMarkdownDocs(docs); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error generating docs/configuration.md: %v\n", err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">fmt.Println("âœ“ Generated docs/configuration.md")

        if err := generateCLIDocs(); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error generating docs/cli-reference.md: %v\n", err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">fmt.Println("âœ“ Generated docs/cli-reference.md")

        if err := generateValidationDocs(); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error generating docs/config-validation.md: %v\n", err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">fmt.Println("âœ“ Generated docs/config-validation.md")</span>
}

// readSnippet reads a markdown snippet from the snippets directory
func readSnippet(name string) (string, error) <span class="cov0" title="0">{
        content, err := os.ReadFile(fmt.Sprintf("cmd/generate-docs/snippets/%s", name))
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to read snippet %s: %w", name, err)
        }</span>
        <span class="cov0" title="0">return string(content), nil</span>
}

func buildDocumentation() []SectionDoc <span class="cov0" title="0">{
        defaults := config.GetDefaults()

        return []SectionDoc{
                extractSection("defaults", "Global configuration options", defaults.Defaults, defaults.Defaults),
                extractSection("defaults.git", "Git integration settings", defaults.Defaults.Git, defaults.Defaults.Git),
                extractSection("task_defaults", "Default values that apply to all tasks unless overridden at the task level", defaults.TaskDefaults, defaults.TaskDefaults),
                extractSection("tasks.&lt;task-id&gt;", "Individual task configuration. Task ID must be unique.", config.TaskConfig{}, config.TaskConfig{}),
        }
}</span>

// extractSection uses reflection to extract field documentation from struct tags
func extractSection(name, description string, value interface{}, defaultValue interface{}) SectionDoc <span class="cov0" title="0">{
        section := SectionDoc{
                Name:        name,
                Description: description,
                Fields:      []FieldDoc{},
        }

        t := reflect.TypeOf(value)
        v := reflect.ValueOf(defaultValue)

        for i := 0; i &lt; t.NumField(); i++ </span><span class="cov0" title="0">{
                field := t.Field(i)

                // Skip unexported fields
                if !field.IsExported() </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Skip internal fields (no doc tag)
                <span class="cov0" title="0">docTag := field.Tag.Get("doc")
                if docTag == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">tomlTag := field.Tag.Get("toml")
                if tomlTag == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">fieldDoc := FieldDoc{
                        Name:        tomlTag,
                        Type:        getFieldType(field.Type),
                        Required:    field.Tag.Get("required") == "true",
                        Description: docTag,
                }

                // Extract default value
                fieldValue := v.Field(i)
                fieldDoc.Default = getDefaultValue(fieldValue, field.Type)

                // Extract enum values
                enumTag := field.Tag.Get("enum")
                if enumTag != "" </span><span class="cov0" title="0">{
                        fieldDoc.ValidValues = strings.Split(enumTag, ",")
                }</span>

                <span class="cov0" title="0">section.Fields = append(section.Fields, fieldDoc)</span>
        }

        <span class="cov0" title="0">return section</span>
}

// getFieldType returns a string representation of the field type
func getFieldType(t reflect.Type) string <span class="cov0" title="0">{
        switch t.Kind() </span>{
        case reflect.String:<span class="cov0" title="0">
                return "string"</span>
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov0" title="0">
                return "int"</span>
        case reflect.Bool:<span class="cov0" title="0">
                return "bool"</span>
        case reflect.Ptr:<span class="cov0" title="0">
                return getFieldType(t.Elem())</span>
        default:<span class="cov0" title="0">
                return t.String()</span>
        }
}

// getDefaultValue returns a string representation of the default value
func getDefaultValue(v reflect.Value, t reflect.Type) string <span class="cov0" title="0">{
        if t.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                if v.IsNil() </span><span class="cov0" title="0">{
                        return ""
                }</span>
                <span class="cov0" title="0">v = v.Elem()
                t = t.Elem()</span>
        }

        <span class="cov0" title="0">switch t.Kind() </span>{
        case reflect.String:<span class="cov0" title="0">
                return v.String()</span>
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov0" title="0">
                return fmt.Sprintf("%d", v.Int())</span>
        case reflect.Bool:<span class="cov0" title="0">
                if v.Bool() </span><span class="cov0" title="0">{
                        return "true"
                }</span>
                <span class="cov0" title="0">return "false"</span>
        default:<span class="cov0" title="0">
                return ""</span>
        }
}

func generateExampleTOML(docs []SectionDoc) error <span class="cov0" title="0">{
        var sb strings.Builder

        sb.WriteString(`# =============================================================================
# devpipe Configuration Reference
# =============================================================================
# This is a comprehensive example showing ALL available configuration options.
# Copy sections you need to your own config.toml.
#
# Quick Start:
#   [tasks.my-task]
#   command = "npm test"
#
# Full documentation: https://github.com/drewkhoury/devpipe
# =============================================================================

`)

        for _, section := range docs </span><span class="cov0" title="0">{
                // Section header
                sb.WriteString("# -----------------------------------------------------------------------------\n")
                sb.WriteString(fmt.Sprintf("# [%s] - %s\n", section.Name, section.Description))
                sb.WriteString("# -----------------------------------------------------------------------------\n\n")

                // Write section
                if section.Name == "tasks.&lt;task-id&gt;" </span><span class="cov0" title="0">{
                        sb.WriteString("# Example task with all options:\n")
                        sb.WriteString("[tasks.example-task]\n")
                }</span> else<span class="cov0" title="0"> {
                        sb.WriteString(fmt.Sprintf("[%s]\n", section.Name))
                }</span>

                // Write fields
                <span class="cov0" title="0">for _, field := range section.Fields </span><span class="cov0" title="0">{
                        // Write description as comment
                        sb.WriteString(fmt.Sprintf("# %s\n", field.Description))
                        if field.Required </span><span class="cov0" title="0">{
                                sb.WriteString("# Required: yes\n")
                        }</span> else<span class="cov0" title="0"> {
                                sb.WriteString(fmt.Sprintf("# Default: %s\n", field.Default))
                        }</span>
                        <span class="cov0" title="0">if len(field.ValidValues) &gt; 0 </span><span class="cov0" title="0">{
                                sb.WriteString(fmt.Sprintf("# Valid values: %s\n", strings.Join(field.ValidValues, ", ")))
                        }</span>

                        // Write field with default value
                        <span class="cov0" title="0">value := field.Default
                        if field.Type == "string" &amp;&amp; value != "" &amp;&amp; value != "(inherited)" </span><span class="cov0" title="0">{
                                value = fmt.Sprintf(`"%s"`, value)
                        }</span>
                        <span class="cov0" title="0">if value == "" || value == "(inherited)" </span><span class="cov0" title="0">{
                                sb.WriteString(fmt.Sprintf("# %s = \n", field.Name))
                        }</span> else<span class="cov0" title="0"> {
                                sb.WriteString(fmt.Sprintf("%s = %s\n", field.Name, value))
                        }</span>
                        <span class="cov0" title="0">sb.WriteString("\n")</span>
                }

                <span class="cov0" title="0">sb.WriteString("\n")</span>
        }

        // Add phase example
        <span class="cov0" title="0">sb.WriteString(`# -----------------------------------------------------------------------------
# Phase-Based Execution
# -----------------------------------------------------------------------------
# Use [tasks.phase-&lt;name&gt;] to create phase headers.
# Tasks under a phase header run in parallel. Phases execute sequentially.

[tasks.phase-quality]
name = "Quality Checks"
desc = "Linting and formatting"

[tasks.lint]
command = "npm run lint"
type = "check"

[tasks.format]
command = "npm run format:check"
type = "check"

[tasks.phase-build]
name = "Build"

[tasks.build]
command = "npm run build"
type = "build"

[tasks.phase-test]
name = "Tests"

[tasks.unit-tests]
command = "npm test"
type = "test"
metricsFormat = "junit"
metricsPath = "test-results/junit.xml"

[tasks.e2e-tests]
command = "npm run test:e2e"
type = "test"
`)

        return os.WriteFile("config.example.toml", []byte(sb.String()), 0644)</span>
}

func generateJSONSchema(docs []SectionDoc) error <span class="cov0" title="0">{
        schema := map[string]interface{}{
                "$schema":     "http://json-schema.org/draft-07/schema#",
                "title":       "devpipe Configuration",
                "description": "Configuration schema for devpipe pipeline runner",
                "type":        "object",
                "properties":  make(map[string]interface{}),
        }

        properties := schema["properties"].(map[string]interface{})

        for _, section := range docs </span><span class="cov0" title="0">{
                sectionName := section.Name
                if strings.Contains(sectionName, ".") </span><span class="cov0" title="0">{
                        // Handle nested sections like "defaults.git"
                        continue</span> // We'll handle these separately
                }

                <span class="cov0" title="0">sectionProps := map[string]interface{}{
                        "type":        "object",
                        "description": section.Description,
                        "properties":  make(map[string]interface{}),
                }

                sectionFields := sectionProps["properties"].(map[string]interface{})

                for _, field := range section.Fields </span><span class="cov0" title="0">{
                        fieldSchema := map[string]interface{}{
                                "description": field.Description,
                        }

                        // Map type
                        switch field.Type </span>{
                        case "string":<span class="cov0" title="0">
                                fieldSchema["type"] = "string"</span>
                        case "int":<span class="cov0" title="0">
                                fieldSchema["type"] = "integer"</span>
                        case "bool":<span class="cov0" title="0">
                                fieldSchema["type"] = "boolean"</span>
                        }

                        // Add default
                        <span class="cov0" title="0">if field.Default != "" &amp;&amp; field.Default != "(inherited)" </span><span class="cov0" title="0">{
                                switch field.Type </span>{
                                case "string":<span class="cov0" title="0">
                                        fieldSchema["default"] = field.Default</span>
                                case "int":<span class="cov0" title="0">
                                        var intVal int
                                        fmt.Sscanf(field.Default, "%d", &amp;intVal)
                                        fieldSchema["default"] = intVal</span>
                                case "bool":<span class="cov0" title="0">
                                        fieldSchema["default"] = field.Default == "true"</span>
                                }
                        }

                        // Add enum for valid values
                        <span class="cov0" title="0">if len(field.ValidValues) &gt; 0 </span><span class="cov0" title="0">{
                                fieldSchema["enum"] = field.ValidValues
                        }</span>

                        <span class="cov0" title="0">sectionFields[field.Name] = fieldSchema</span>
                }

                // Handle nested git section
                <span class="cov0" title="0">if sectionName == "defaults" </span><span class="cov0" title="0">{
                        gitProps := map[string]interface{}{
                                "type":        "object",
                                "description": "Git integration settings",
                                "properties":  make(map[string]interface{}),
                        }

                        // Find git section in docs
                        for _, s := range docs </span><span class="cov0" title="0">{
                                if s.Name == "defaults.git" </span><span class="cov0" title="0">{
                                        gitFields := gitProps["properties"].(map[string]interface{})
                                        for _, field := range s.Fields </span><span class="cov0" title="0">{
                                                fieldSchema := map[string]interface{}{
                                                        "type":        "string",
                                                        "description": field.Description,
                                                }
                                                if field.Default != "" </span><span class="cov0" title="0">{
                                                        fieldSchema["default"] = field.Default
                                                }</span>
                                                <span class="cov0" title="0">if len(field.ValidValues) &gt; 0 </span><span class="cov0" title="0">{
                                                        fieldSchema["enum"] = field.ValidValues
                                                }</span>
                                                <span class="cov0" title="0">gitFields[field.Name] = fieldSchema</span>
                                        }
                                }
                        }

                        <span class="cov0" title="0">sectionFields["git"] = gitProps</span>
                }

                <span class="cov0" title="0">properties[sectionName] = sectionProps</span>
        }

        // Add tasks section
        <span class="cov0" title="0">tasksSection := docs[len(docs)-1] // tasks.&lt;task-id&gt; is last
        taskSchema := map[string]interface{}{
                "type":        "object",
                "description": tasksSection.Description,
                "properties":  make(map[string]interface{}),
        }

        taskProps := taskSchema["properties"].(map[string]interface{})
        for _, field := range tasksSection.Fields </span><span class="cov0" title="0">{
                fieldSchema := map[string]interface{}{
                        "description": field.Description,
                }
                switch field.Type </span>{
                case "string":<span class="cov0" title="0">
                        fieldSchema["type"] = "string"</span>
                case "bool":<span class="cov0" title="0">
                        fieldSchema["type"] = "boolean"</span>
                }
                <span class="cov0" title="0">if len(field.ValidValues) &gt; 0 </span><span class="cov0" title="0">{
                        fieldSchema["enum"] = field.ValidValues
                }</span>
                <span class="cov0" title="0">taskProps[field.Name] = fieldSchema</span>
        }

        <span class="cov0" title="0">properties["tasks"] = map[string]interface{}{
                "type": "object",
                "patternProperties": map[string]interface{}{
                        "^[a-zA-Z0-9_-]+$": taskSchema,
                },
        }

        // Write to file
        data, err := json.MarshalIndent(schema, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return os.WriteFile("config.schema.json", data, 0644)</span>
}

func generateMarkdownDocs(docs []SectionDoc) error <span class="cov0" title="0">{
        var sb strings.Builder

        // Add intro from snippet
        intro, err := readSnippet("config-intro.md")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">sb.WriteString(intro)
        sb.WriteString("\n\n")

        // Generate tables from struct tags
        for _, section := range docs </span><span class="cov0" title="0">{
                sb.WriteString("### `[" + section.Name + "]`\n\n")
                sb.WriteString(section.Description + "\n\n")

                sb.WriteString("| Field | Type | Required | Default | Description |\n")
                sb.WriteString("|-------|------|----------|---------|-------------|\n")

                for _, field := range section.Fields </span><span class="cov0" title="0">{
                        required := "No"
                        if field.Required </span><span class="cov0" title="0">{
                                required = "**Yes**"
                        }</span>
                        <span class="cov0" title="0">defaultVal := field.Default
                        if defaultVal == "" </span><span class="cov0" title="0">{
                                defaultVal = "-"
                        }</span>
                        <span class="cov0" title="0">desc := field.Description
                        if len(field.ValidValues) &gt; 0 </span><span class="cov0" title="0">{
                                desc += fmt.Sprintf(" (valid: `%s`)", strings.Join(field.ValidValues, "`, `"))
                        }</span>
                        <span class="cov0" title="0">sb.WriteString(fmt.Sprintf("| `%s` | %s | %s | `%s` | %s |\n",
                                field.Name, field.Type, required, defaultVal, desc))</span>
                }

                <span class="cov0" title="0">sb.WriteString("\n")</span>
        }

        // Add phase examples from snippet
        <span class="cov0" title="0">phaseExamples, err := readSnippet("phase-examples.md")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">sb.WriteString(phaseExamples)
        sb.WriteString("\n")

        // Create docs directory if it doesn't exist
        if err := os.MkdirAll("docs", 0755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return os.WriteFile("docs/configuration.md", []byte(sb.String()), 0644)</span>
}

func generateCLIDocs() error <span class="cov0" title="0">{
        var sb strings.Builder

        // Add intro from snippet
        intro, err := readSnippet("cli-intro.md")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">sb.WriteString(intro)
        sb.WriteString("\n\n")

        // TODO: Add auto-generated flag tables here when we parse CLI flags
        sb.WriteString("### Run Flags\n\n")
        sb.WriteString("| Flag | Description | Default |\n")
        sb.WriteString("|------|-------------|---------||\n")
        sb.WriteString("| `--config &lt;path&gt;` | Path to config file | `config.toml` |\n")
        sb.WriteString("| `--since &lt;ref&gt;` | Git ref to compare against (overrides config) | - |\n")
        sb.WriteString("| `--only &lt;task-id&gt;` | Run only a single task by id | - |\n")
        sb.WriteString("| `--skip &lt;task-id&gt;` | Skip a task by id (repeatable) | - |\n")
        sb.WriteString("| `--fix-type &lt;type&gt;` | Fix behavior: `auto`, `helper`, `none` (overrides config) | - |\n")
        sb.WriteString("| `--ui &lt;mode&gt;` | UI mode: `basic`, `full` | `basic` |\n")
        sb.WriteString("| `--dashboard` | Show dashboard with live progress | `false` |\n")
        sb.WriteString("| `--fail-fast` | Stop on first task failure | `false` |\n")
        sb.WriteString("| `--fast` | Skip long-running tasks (&gt; fastThreshold) | `false` |\n")
        sb.WriteString("| `--dry-run` | Do not execute commands, simulate only | `false` |\n")
        sb.WriteString("| `--verbose` | Show verbose output (always logged to pipeline.log) | `false` |\n")
        sb.WriteString("| `--no-color` | Disable colored output | `false` |\n")
        sb.WriteString("\n")

        sb.WriteString("### Validate Flags\n\n")
        sb.WriteString("| Flag | Description | Default |\n")
        sb.WriteString("|------|-------------|---------||\n")
        sb.WriteString("| `--config &lt;path&gt;` | Path to config file to validate (supports multiple files) | `config.toml` |\n")
        sb.WriteString("\n")
        sb.WriteString("See [config-validation.md](config-validation.md) for more details.\n\n")

        // Add examples from snippet
        examples, err := readSnippet("cli-examples.md")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">sb.WriteString(examples)
        sb.WriteString("\n")

        // Create docs directory if it doesn't exist
        if err := os.MkdirAll("docs", 0755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return os.WriteFile("docs/cli-reference.md", []byte(sb.String()), 0644)</span>
}

func generateValidationDocs() error <span class="cov0" title="0">{
        // Simply copy the snippet to docs
        content, err := readSnippet("config-validation.md")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Create docs directory if it doesn't exist
        <span class="cov0" title="0">if err := os.MkdirAll("docs", 0755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return os.WriteFile("docs/config-validation.md", []byte(content), 0644)</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "flag"
        "fmt"
        "os"
        "path/filepath"

        "github.com/drew/devpipe/internal/sarif"
)

func main() <span class="cov0" title="0">{
        // Command-line flags
        verbose := flag.Bool("v", false, "Verbose output (show rule names)")
        summary := flag.Bool("s", false, "Show summary grouped by rule")
        dir := flag.String("d", "", "Directory to search for SARIF files")
        flag.Parse()

        // Get SARIF file(s)
        var files []string
        if *dir != "" </span><span class="cov0" title="0">{
                // Search directory for SARIF files
                found, err := sarif.FindSARIFFiles(*dir)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "Error searching directory: %v\n", err)
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">files = found</span>
        } else<span class="cov0" title="0"> if flag.NArg() &gt; 0 </span><span class="cov0" title="0">{
                // Use files from arguments
                files = flag.Args()
        }</span> else<span class="cov0" title="0"> {
                // Default: look for SARIF files in tmp/codeql
                defaultPath := "tmp/codeql/results.sarif"
                if _, err := os.Stat(defaultPath); err == nil </span><span class="cov0" title="0">{
                        files = []string{defaultPath}
                }</span> else<span class="cov0" title="0"> {
                        fmt.Fprintf(os.Stderr, "Usage: %s [options] &lt;sarif-file&gt; [&lt;sarif-file&gt;...]\n", os.Args[0])
                        fmt.Fprintf(os.Stderr, "   or: %s -d &lt;directory&gt;\n\n", os.Args[0])
                        fmt.Fprintf(os.Stderr, "Options:\n")
                        flag.PrintDefaults()
                        fmt.Fprintf(os.Stderr, "\nIf no file is specified, looks for tmp/codeql/results.sarif\n")
                        os.Exit(1)
                }</span>
        }

        <span class="cov0" title="0">if len(files) == 0 </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "No SARIF files found\n")
                os.Exit(1)
        }</span>

        // Process all files
        <span class="cov0" title="0">var allFindings []sarif.Finding
        for _, file := range files </span><span class="cov0" title="0">{
                // Parse SARIF file
                doc, err := sarif.Parse(file)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "Error parsing %s: %v\n", file, err)
                        continue</span>
                }

                <span class="cov0" title="0">findings := doc.GetFindings()

                // If multiple files, show which file we're processing
                if len(files) &gt; 1 &amp;&amp; len(findings) &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Printf("\nðŸ“„ %s:\n", filepath.Base(file))
                }</span>

                <span class="cov0" title="0">allFindings = append(allFindings, findings...)</span>
        }

        // Display results
        <span class="cov0" title="0">if *summary </span><span class="cov0" title="0">{
                sarif.PrintSummary(allFindings)
        }</span> else<span class="cov0" title="0"> {
                sarif.PrintFindings(allFindings, *verbose)
        }</span>

        // Exit with error code if issues found
        <span class="cov0" title="0">if len(allFindings) &gt; 0 </span><span class="cov0" title="0">{
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Package config handles loading, validation, and merging of devpipe configuration files.
package config

import (
        "fmt"
        "os"
        "path/filepath"
        "strings"

        "github.com/BurntSushi/toml"
)

// Config represents the complete devpipe configuration
type Config struct {
        Defaults     DefaultsConfig        `toml:"defaults"`
        TaskDefaults TaskDefaultsConfig    `toml:"task_defaults"`
        Tasks        map[string]TaskConfig `toml:"tasks"`
}

// DefaultsConfig holds global defaults
type DefaultsConfig struct {
        // Directory for run outputs and logs
        OutputRoot string `toml:"outputRoot" doc:"Directory for run outputs and logs"`
        // Tasks longer than this (seconds) are skipped with --fast
        FastThreshold int `toml:"fastThreshold" doc:"Tasks longer than this (seconds) are skipped with --fast"`
        // UI mode: basic or full
        UIMode string `toml:"uiMode" doc:"UI mode: basic or full" enum:"basic,full"`
        // Dashboard refresh rate in milliseconds
        AnimationRefreshMs int `toml:"animationRefreshMs" doc:"Dashboard refresh rate in milliseconds"`
        // Group tasks by phase or type in dashboard
        AnimatedGroupBy string `toml:"animatedGroupBy" doc:"Group tasks by phase or type in dashboard" enum:"phase,type"`
        // Git integration settings
        Git GitConfig `toml:"git"`
}

// GitConfig holds git-related configuration
type GitConfig struct {
        // Git mode: staged, staged_unstaged, or ref
        Mode string `toml:"mode" doc:"Git mode: staged, staged_unstaged, or ref" enum:"staged,staged_unstaged,ref"`
        // Git ref to compare against when mode is ref
        Ref string `toml:"ref" doc:"Git ref to compare against when mode is ref"`
}

// TaskDefaultsConfig holds default values for all tasks
type TaskDefaultsConfig struct {
        // Whether tasks are enabled by default
        Enabled *bool `toml:"enabled" doc:"Whether tasks are enabled by default"`
        // Default working directory for tasks
        Workdir string `toml:"workdir" doc:"Default working directory for tasks"`
        // Default fix behavior: auto, helper, or none
        FixType string `toml:"fixType" doc:"Default fix behavior: auto, helper, or none" enum:"auto,helper,none"`
}

// TaskConfig represents a single task configuration
type TaskConfig struct {
        // Shell command to execute
        Command string `toml:"command" doc:"Shell command to execute" required:"true"`
        // Display name for the task
        Name string `toml:"name" doc:"Display name for the task"`
        // Description
        Desc string `toml:"desc" doc:"Description"`
        // Task type for grouping (e.g., check, build, test)
        Type string `toml:"type" doc:"Task type for grouping (e.g., check, build, test)"`
        // Working directory for this task
        Workdir string `toml:"workdir" doc:"Working directory for this task"`
        // Whether this task is enabled
        Enabled *bool `toml:"enabled" doc:"Whether this task is enabled"`
        // Internal use only: set automatically by phase headers
        Wait bool `toml:"wait"`
        // Metrics format: junit, sarif, artifact
        MetricsFormat string `toml:"metricsFormat" doc:"Metrics format: junit, sarif, artifact" enum:"junit,sarif,artifact"`
        // Path to metrics file (relative to workdir)
        MetricsPath string `toml:"metricsPath" doc:"Path to metrics file (relative to workdir)"`
        // Fix behavior: auto, helper, none (overrides task_defaults)
        FixType string `toml:"fixType" doc:"Fix behavior: auto, helper, none (overrides task_defaults)" enum:"auto,helper,none"`
        // Command to run to fix issues (required if fixType is set)
        FixCommand string `toml:"fixCommand" doc:"Command to run to fix issues (required if fixType is set)"`
}

// LoadConfig loads configuration from a TOML file
// Returns config, task order, phase info, task-to-phase mapping, and error
func LoadConfig(path string) (*Config, []string, map[string]PhaseInfo, map[string]string, error) <span class="cov5" title="10">{
        // If no path specified, look for config.toml in current directory
        explicitPath := path != ""
        if path == "" </span><span class="cov1" title="1">{
                path = "config.toml"
        }</span>

        // Check if file exists
        <span class="cov5" title="10">if _, err := os.Stat(path); os.IsNotExist(err) </span><span class="cov2" title="2">{
                // If user explicitly specified a config file, fail
                if explicitPath </span><span class="cov1" title="1">{
                        return nil, nil, nil, nil, fmt.Errorf("config file not found: %s", path)
                }</span>
                // Otherwise, return nil to allow auto-generation
                <span class="cov1" title="1">return nil, nil, nil, nil, nil</span>
        }

        <span class="cov4" title="8">var cfg Config
        metadata, err := toml.DecodeFile(path, &amp;cfg)
        if err != nil </span><span class="cov2" title="2">{
                return nil, nil, nil, nil, fmt.Errorf("failed to parse config file %s: %w", path, err)
        }</span>

        // Check for unknown fields
        <span class="cov4" title="6">undecoded := metadata.Undecoded()
        if len(undecoded) &gt; 0 </span><span class="cov1" title="1">{
                var unknownFields []string
                for _, key := range undecoded </span><span class="cov1" title="1">{
                        unknownFields = append(unknownFields, key.String())
                }</span>
                <span class="cov1" title="1">return nil, nil, nil, nil, fmt.Errorf("unknown fields in config: %s", strings.Join(unknownFields, ", "))</span>
        }

        // Extract task order, phase names, and task-to-phase mapping from the TOML file
        <span class="cov3" title="5">taskOrder, phaseNames, taskToPhase, err := extractTaskOrder(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, nil, fmt.Errorf("failed to extract task order: %w", err)
        }</span>

        <span class="cov3" title="5">return &amp;cfg, taskOrder, phaseNames, taskToPhase, nil</span>
}

// GetDefaults returns the default configuration
func GetDefaults() Config <span class="cov3" title="5">{
        return Config{
                Defaults: DefaultsConfig{
                        OutputRoot:         ".devpipe",
                        FastThreshold:      300,
                        UIMode:             "basic",
                        AnimationRefreshMs: 500,     // 500ms = 2 FPS (efficient default)
                        AnimatedGroupBy:    "phase", // "type" or "phase"
                        Git: GitConfig{
                                Mode: "staged_unstaged",
                                Ref:  "HEAD",
                        },
                },
                TaskDefaults: TaskDefaultsConfig{
                        Enabled: boolPtr(true),
                        Workdir: ".",
                },
                Tasks: make(map[string]TaskConfig),
        }
}</span>

// MergeWithDefaults merges loaded config with defaults
func MergeWithDefaults(cfg *Config) Config <span class="cov3" title="4">{
        defaults := GetDefaults()

        if cfg == nil </span><span class="cov1" title="1">{
                return defaults
        }</span>

        // Merge defaults
        <span class="cov2" title="3">if cfg.Defaults.OutputRoot == "" </span><span class="cov2" title="3">{
                cfg.Defaults.OutputRoot = defaults.Defaults.OutputRoot
        }</span>
        <span class="cov2" title="3">if cfg.Defaults.FastThreshold == 0 </span><span class="cov2" title="2">{
                cfg.Defaults.FastThreshold = defaults.Defaults.FastThreshold
        }</span>
        <span class="cov2" title="3">if cfg.Defaults.UIMode == "" </span><span class="cov1" title="1">{
                cfg.Defaults.UIMode = defaults.Defaults.UIMode
        }</span>
        <span class="cov2" title="3">if cfg.Defaults.AnimationRefreshMs == 0 </span><span class="cov2" title="3">{
                cfg.Defaults.AnimationRefreshMs = defaults.Defaults.AnimationRefreshMs
        }</span>
        <span class="cov2" title="3">if cfg.Defaults.AnimatedGroupBy == "" </span><span class="cov2" title="3">{
                cfg.Defaults.AnimatedGroupBy = defaults.Defaults.AnimatedGroupBy
        }</span>
        <span class="cov2" title="3">if cfg.Defaults.Git.Mode == "" </span><span class="cov2" title="3">{
                cfg.Defaults.Git.Mode = defaults.Defaults.Git.Mode
        }</span>
        <span class="cov2" title="3">if cfg.Defaults.Git.Ref == "" </span><span class="cov2" title="3">{
                cfg.Defaults.Git.Ref = defaults.Defaults.Git.Ref
        }</span>

        // Merge task defaults
        <span class="cov2" title="3">if cfg.TaskDefaults.Enabled == nil </span><span class="cov2" title="2">{
                cfg.TaskDefaults.Enabled = defaults.TaskDefaults.Enabled
        }</span>
        <span class="cov2" title="3">if cfg.TaskDefaults.Workdir == "" </span><span class="cov1" title="1">{
                cfg.TaskDefaults.Workdir = defaults.TaskDefaults.Workdir
        }</span>

        <span class="cov2" title="3">return *cfg</span>
}

// ResolveTaskConfig resolves a task config by applying defaults
func (c *Config) ResolveTaskConfig(id string, taskCfg TaskConfig, repoRoot string) TaskConfig <span class="cov4" title="9">{
        // Apply task defaults
        if taskCfg.Workdir == "" </span><span class="cov4" title="7">{
                if c.TaskDefaults.Workdir != "" </span><span class="cov3" title="4">{
                        taskCfg.Workdir = c.TaskDefaults.Workdir
                }</span> else<span class="cov2" title="3"> {
                        taskCfg.Workdir = "."
                }</span>
        }

        // Make workdir absolute relative to repo root
        <span class="cov4" title="9">if !filepath.IsAbs(taskCfg.Workdir) </span><span class="cov4" title="8">{
                taskCfg.Workdir = filepath.Join(repoRoot, taskCfg.Workdir)
        }</span>

        <span class="cov4" title="9">if taskCfg.Enabled == nil </span><span class="cov4" title="8">{
                taskCfg.Enabled = c.TaskDefaults.Enabled
        }</span>

        // Inherit fixType from task_defaults if not set at task level
        <span class="cov4" title="9">if taskCfg.FixType == "" &amp;&amp; c.TaskDefaults.FixType != "" </span><span class="cov2" title="2">{
                taskCfg.FixType = c.TaskDefaults.FixType
        }</span>

        <span class="cov4" title="9">return taskCfg</span>
}

func boolPtr(b bool) *bool <span class="cov6" title="17">{
        return &amp;b
}</span>

func intToString(i int) string <span class="cov5" title="12">{
        return fmt.Sprintf("%d", i)
}</span>

func splitLines(s string) []string <span class="cov4" title="9">{
        return strings.Split(s, "\n")
}</span>

func trimSpace(s string) string <span class="cov9" title="93">{
        return strings.TrimSpace(s)
}</span>

// PhaseInfo holds information about a phase
type PhaseInfo struct {
        ID   string
        Name string
        Desc string
}

// extractTaskOrder parses the TOML file to extract the order of [tasks.X] sections
// Tasks starting with "phase-" are treated as phase headers - all tasks after a phase
// header belong to that phase until the next phase header
// Returns task order, phase info map, and task-to-phase mapping
func extractTaskOrder(path string) ([]string, map[string]PhaseInfo, map[string]string, error) <span class="cov5" title="10">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov1" title="1">{
                return nil, nil, nil, err
        }</span>

        <span class="cov4" title="9">var order []string
        phaseNames := make(map[string]PhaseInfo)
        taskToPhase := make(map[string]string)
        lines := splitLines(string(data))
        phaseCounter := 0
        var currentPhaseID string
        var currentPhaseMarker string

        // Parse [tasks.X] sections to build order
        // When we see [tasks.phase-*], insert a wait marker before it (except for the first phase)
        for i, line := range lines </span><span class="cov8" title="63">{
                trimmed := trimSpace(line)
                if len(trimmed) &gt; 7 &amp;&amp; trimmed[0] == '[' &amp;&amp; trimmed[1:7] == "tasks." </span><span class="cov6" title="19">{
                        // Extract task ID from [tasks.ID]
                        end := -1
                        for j := 7; j &lt; len(trimmed); j++ </span><span class="cov10" title="160">{
                                if trimmed[j] == ']' </span><span class="cov6" title="18">{
                                        end = j
                                        break</span>
                                }
                        }
                        <span class="cov6" title="19">if end &gt; 7 </span><span class="cov6" title="18">{
                                taskID := trimmed[7:end]

                                // Check if this is a phase header
                                if len(taskID) &gt; 6 &amp;&amp; taskID[0:6] == "phase-" </span><span class="cov3" title="5">{
                                        // Insert a wait marker before this phase (except for the first phase)
                                        if phaseCounter &gt; 0 </span><span class="cov2" title="2">{
                                                order = append(order, "wait-"+intToString(phaseCounter))
                                        }</span>
                                        <span class="cov3" title="5">phaseCounter++
                                        currentPhaseID = "wait-" + intToString(phaseCounter)
                                        currentPhaseMarker = taskID // Save the actual phase ID (e.g., "phase-validation")

                                        // Extract phase name and desc from following lines
                                        phaseName := ""
                                        phaseDesc := ""
                                        for j := i + 1; j &lt; len(lines) &amp;&amp; j &lt; i+10; j++ </span><span class="cov6" title="17">{
                                                nextLine := trimSpace(lines[j])
                                                if len(nextLine) &gt; 0 &amp;&amp; nextLine[0] == '[' </span><span class="cov3" title="5">{
                                                        break</span> // Hit next section
                                                }
                                                <span class="cov5" title="12">if strings.HasPrefix(nextLine, "name = ") </span><span class="cov3" title="4">{
                                                        phaseName = extractQuotedValue(nextLine[7:])
                                                }</span>
                                                <span class="cov5" title="12">if strings.HasPrefix(nextLine, "desc = ") </span><span class="cov2" title="3">{
                                                        phaseDesc = extractQuotedValue(nextLine[7:])
                                                }</span>
                                        }

                                        <span class="cov3" title="5">if phaseName != "" </span><span class="cov3" title="4">{
                                                phaseNames[currentPhaseID] = PhaseInfo{
                                                        ID:   currentPhaseMarker,
                                                        Name: phaseName,
                                                        Desc: phaseDesc,
                                                }
                                        }</span>

                                        // Don't add the phase header itself to the order
                                        <span class="cov3" title="5">continue</span>
                                }

                                // Regular task - map it to current phase
                                <span class="cov5" title="13">if currentPhaseMarker != "" </span><span class="cov3" title="5">{
                                        taskToPhase[taskID] = currentPhaseMarker
                                }</span>
                                <span class="cov5" title="13">order = append(order, taskID)</span>
                        }
                }
        }

        <span class="cov4" title="9">return order, phaseNames, taskToPhase, nil</span>
}

func extractQuotedValue(s string) string <span class="cov5" title="13">{
        s = trimSpace(s)
        if len(s) &gt;= 2 &amp;&amp; s[0] == '"' </span><span class="cov5" title="10">{
                // Find closing quote
                for i := 1; i &lt; len(s); i++ </span><span class="cov9" title="129">{
                        if s[i] == '"' </span><span class="cov4" title="9">{
                                return s[1:i]
                        }</span>
                }
        }
        <span class="cov3" title="4">return s</span>
}

// GenerateDefaultConfig creates a minimal config.toml file
func GenerateDefaultConfig(path string, repoRoot string) error <span class="cov2" title="2">{
        // Check if file already exists
        if _, err := os.Stat(path); err == nil </span><span class="cov1" title="1">{
                return fmt.Errorf("config file already exists: %s", path)
        }</span>

        // Write to file
        <span class="cov1" title="1">f, err := os.Create(path)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create config file: %w", err)
        }</span>
        <span class="cov1" title="1">defer f.Close()

        // Write minimal, runnable config
        content := `# devpipe configuration file
# Full reference: https://github.com/drewkhoury/devpipe/blob/main/config.example.toml

[tasks.lint]
name = "Lint"
command = "echo 'Running linter...'"
type = "check"

[tasks.format]
name = "Format Check"
command = "echo 'Checking code formatting...'"
type = "check"

[tasks.build]
name = "Build"
command = "echo 'Building application...'"
type = "build"
`

        if _, err := f.WriteString(content); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write config: %w", err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package config

// BuiltInTasks returns the hardcoded task definitions from Iteration 1
// These are used as fallback when no config.toml is present
func BuiltInTasks(repoRoot string) map[string]TaskConfig <span class="cov8" title="1">{
        return map[string]TaskConfig{
                "lint": {
                        Name:    "Lint",
                        Type:    "quality",
                        Command: repoRoot + "/hello-world.sh lint",
                        Workdir: repoRoot,
                        Enabled: boolPtr(true),
                },
                "format": {
                        Name:    "Format",
                        Type:    "quality",
                        Command: repoRoot + "/hello-world.sh format",
                        Workdir: repoRoot,
                        Enabled: boolPtr(true),
                },
                "type-check": {
                        Name:    "Type Check",
                        Type:    "correctness",
                        Command: repoRoot + "/hello-world.sh type-check",
                        Workdir: repoRoot,
                        Enabled: boolPtr(true),
                },
                "build": {
                        Name:          "Build",
                        Type:          "release",
                        Command:       repoRoot + "/hello-world.sh build",
                        Workdir:       repoRoot,
                        Enabled:       boolPtr(true),
                        MetricsFormat: "artifact",
                        MetricsPath:   "artifacts/build/app.txt",
                },
                "unit-tests": {
                        Name:          "Unit Tests",
                        Type:          "correctness",
                        Command:       repoRoot + "/hello-world.sh unit-tests",
                        Workdir:       repoRoot,
                        Enabled:       boolPtr(true),
                        MetricsFormat: "junit",
                        MetricsPath:   "artifacts/test/junit.xml",
                },
                "e2e-tests": {
                        Name:    "E2E Tests",
                        Type:    "correctness",
                        Command: repoRoot + "/hello-world.sh e2e-tests",
                        Workdir: repoRoot,
                        Enabled: boolPtr(true),
                },
        }
}</span>

// GetTaskOrder returns the default order for built-in tasks
func GetTaskOrder() []string <span class="cov8" title="1">{
        return []string{
                "lint",
                "format",
                "type-check",
                "build",
                "unit-tests",
                "e2e-tests",
        }
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package config

import (
        "fmt"
        "os"
        "strings"

        "github.com/BurntSushi/toml"
)

// ValidationError represents a configuration validation error
type ValidationError struct {
        Field   string
        Message string
}

func (e ValidationError) Error() string <span class="cov3" title="4">{
        if e.Field != "" </span><span class="cov2" title="2">{
                return fmt.Sprintf("%s: %s", e.Field, e.Message)
        }</span>
        <span class="cov2" title="2">return e.Message</span>
}

// ValidationResult holds the results of config validation
type ValidationResult struct {
        Valid    bool
        Errors   []ValidationError
        Warnings []ValidationError
}

// ValidateConfig validates an already-loaded config
func ValidateConfig(cfg *Config) (*ValidationResult, error) <span class="cov6" title="15">{
        result := &amp;ValidationResult{
                Valid:    true,
                Errors:   []ValidationError{},
                Warnings: []ValidationError{},
        }

        if cfg == nil </span><span class="cov1" title="1">{
                return result, nil
        }</span>

        // Validate defaults section
        <span class="cov6" title="14">validateDefaults(&amp;cfg.Defaults, result)

        // Validate task_defaults section
        validateTaskDefaults(&amp;cfg.TaskDefaults, result)

        // Validate tasks
        for taskID, task := range cfg.Tasks </span><span class="cov5" title="10">{
                validateTask(taskID, task, result)
        }</span>

        <span class="cov6" title="14">return result, nil</span>
}

// ValidateConfigFile validates a TOML config file
func ValidateConfigFile(path string) (*ValidationResult, error) <span class="cov3" title="4">{
        result := &amp;ValidationResult{
                Valid:    true,
                Errors:   []ValidationError{},
                Warnings: []ValidationError{},
        }

        // Check if file exists
        if _, err := os.Stat(path); os.IsNotExist(err) </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("config file does not exist: %s", path)
        }</span>

        // Try to parse as TOML first
        <span class="cov3" title="3">var cfg Config
        metadata, err := toml.DecodeFile(path, &amp;cfg)
        if err != nil </span><span class="cov1" title="1">{
                result.Valid = false
                result.Errors = append(result.Errors, ValidationError{
                        Message: fmt.Sprintf("Invalid TOML syntax: %v", err),
                })
                return result, nil
        }</span>

        // Check for unknown fields
        <span class="cov2" title="2">undecoded := metadata.Undecoded()
        if len(undecoded) &gt; 0 </span><span class="cov1" title="1">{
                result.Valid = false
                for _, key := range undecoded </span><span class="cov1" title="1">{
                        result.Errors = append(result.Errors, ValidationError{
                                Field:   key.String(),
                                Message: "Unknown configuration field",
                        })
                }</span>
        }

        // Validate defaults section
        <span class="cov2" title="2">validateDefaults(&amp;cfg.Defaults, result)

        // Validate task_defaults section
        validateTaskDefaults(&amp;cfg.TaskDefaults, result)

        // Validate tasks
        for taskID, task := range cfg.Tasks </span><span class="cov2" title="2">{
                validateTask(taskID, task, result)
        }</span>

        // Additional validation: check for phase headers
        <span class="cov2" title="2">if err := validatePhaseHeaders(path, result); err != nil </span><span class="cov0" title="0">{
                result.Warnings = append(result.Warnings, ValidationError{
                        Message: fmt.Sprintf("Could not validate phase headers: %v", err),
                })
        }</span>

        <span class="cov2" title="2">return result, nil</span>
}

// validateDefaults validates the defaults section
func validateDefaults(defaults *DefaultsConfig, result *ValidationResult) <span class="cov7" title="21">{
        // Validate UIMode
        if defaults.UIMode != "" </span><span class="cov4" title="6">{
                validModes := []string{"basic", "full"}
                if !contains(validModes, defaults.UIMode) </span><span class="cov2" title="2">{
                        result.Valid = false
                        result.Errors = append(result.Errors, ValidationError{
                                Field:   "defaults.uiMode",
                                Message: fmt.Sprintf("Invalid UI mode '%s'. Valid options: %s", defaults.UIMode, strings.Join(validModes, ", ")),
                        })
                }</span>
        }

        // Validate AnimatedGroupBy
        <span class="cov7" title="21">if defaults.AnimatedGroupBy != "" </span><span class="cov1" title="1">{
                validGroupBy := []string{"type", "phase"}
                if !contains(validGroupBy, defaults.AnimatedGroupBy) </span><span class="cov1" title="1">{
                        result.Valid = false
                        result.Errors = append(result.Errors, ValidationError{
                                Field:   "defaults.animatedGroupBy",
                                Message: fmt.Sprintf("Invalid groupBy '%s'. Valid options: %s", defaults.AnimatedGroupBy, strings.Join(validGroupBy, ", ")),
                        })
                }</span>
        }

        // Validate FastThreshold
        <span class="cov7" title="21">if defaults.FastThreshold &lt; 0 </span><span class="cov1" title="1">{
                result.Valid = false
                result.Errors = append(result.Errors, ValidationError{
                        Field:   "defaults.fastThreshold",
                        Message: "Fast threshold must be non-negative",
                })
        }</span>

        // Validate AnimationRefreshMs
        <span class="cov7" title="21">if defaults.AnimationRefreshMs &lt; 0 </span><span class="cov1" title="1">{
                result.Valid = false
                result.Errors = append(result.Errors, ValidationError{
                        Field:   "defaults.animationRefreshMs",
                        Message: "Animation refresh rate must be non-negative",
                })
        }</span>

        // Validate Git config
        <span class="cov7" title="21">validateGitConfig(&amp;defaults.Git, result)</span>
}

// validateGitConfig validates git configuration
func validateGitConfig(git *GitConfig, result *ValidationResult) <span class="cov7" title="24">{
        if git.Mode != "" </span><span class="cov5" title="7">{
                validModes := []string{"staged", "staged_unstaged", "ref"}
                if !contains(validModes, git.Mode) </span><span class="cov2" title="2">{
                        result.Valid = false
                        result.Errors = append(result.Errors, ValidationError{
                                Field:   "defaults.git.mode",
                                Message: fmt.Sprintf("Invalid git mode '%s'. Valid options: %s", git.Mode, strings.Join(validModes, ", ")),
                        })
                }</span>
        }

        // Warn if mode is "ref" but no ref is specified
        <span class="cov7" title="24">if git.Mode == "ref" &amp;&amp; git.Ref == "" </span><span class="cov1" title="1">{
                result.Warnings = append(result.Warnings, ValidationError{
                        Field:   "defaults.git.ref",
                        Message: "Git mode is 'ref' but no ref is specified",
                })
        }</span>
}

// validateTaskDefaults validates the task_defaults section
func validateTaskDefaults(taskDefaults *TaskDefaultsConfig, result *ValidationResult) <span class="cov7" title="21">{
        // Validate fixType if specified
        if taskDefaults.FixType != "" </span><span class="cov4" title="6">{
                validFixTypes := []string{"auto", "helper", "none"}
                if !contains(validFixTypes, taskDefaults.FixType) </span><span class="cov2" title="2">{
                        result.Valid = false
                        result.Errors = append(result.Errors, ValidationError{
                                Field:   "task_defaults.fixType",
                                Message: fmt.Sprintf("Invalid fix type '%s'. Valid options: %s", taskDefaults.FixType, strings.Join(validFixTypes, ", ")),
                        })
                }</span>
        }
}

// validateTask validates a single task configuration
func validateTask(taskID string, task TaskConfig, result *ValidationResult) <span class="cov7" title="23">{
        prefix := fmt.Sprintf("tasks.%s", taskID)

        // Check if it's a phase header
        if strings.HasPrefix(taskID, "phase-") </span><span class="cov3" title="3">{
                // Phase headers should have name but no command
                if task.Command != "" </span><span class="cov1" title="1">{
                        result.Warnings = append(result.Warnings, ValidationError{
                                Field:   prefix + ".command",
                                Message: "Phase headers should not have a command",
                        })
                }</span>
                <span class="cov3" title="3">if task.Name == "" </span><span class="cov1" title="1">{
                        result.Warnings = append(result.Warnings, ValidationError{
                                Field:   prefix + ".name",
                                Message: "Phase header should have a name",
                        })
                }</span>
                <span class="cov3" title="3">return</span>
        }

        // Regular tasks should have a command
        <span class="cov7" title="20">if task.Command == "" </span><span class="cov1" title="1">{
                result.Valid = false
                result.Errors = append(result.Errors, ValidationError{
                        Field:   prefix + ".command",
                        Message: "Task must have a command",
                })
        }</span>

        // Note: task.Type is user-defined and can be any string, so we don't validate it

        // Validate metricsFormat if specified
        <span class="cov7" title="20">if task.MetricsFormat != "" </span><span class="cov5" title="8">{
                validFormats := []string{"junit", "sarif", "artifact"}
                if !contains(validFormats, task.MetricsFormat) </span><span class="cov2" title="2">{
                        result.Valid = false
                        result.Errors = append(result.Errors, ValidationError{
                                Field:   prefix + ".metricsFormat",
                                Message: fmt.Sprintf("Invalid metrics format '%s'. Valid options: %s", task.MetricsFormat, strings.Join(validFormats, ", ")),
                        })
                }</span>

                // Warn if metricsFormat is set but metricsPath is not
                <span class="cov5" title="8">if task.MetricsPath == "" </span><span class="cov1" title="1">{
                        result.Warnings = append(result.Warnings, ValidationError{
                                Field:   prefix + ".metricsPath",
                                Message: "metricsFormat is set but metricsPath is not specified",
                        })
                }</span>
        }

        // Validate fixType if specified
        <span class="cov7" title="20">if task.FixType != "" </span><span class="cov3" title="3">{
                validFixTypes := []string{"auto", "helper", "none"}
                if !contains(validFixTypes, task.FixType) </span><span class="cov1" title="1">{
                        result.Valid = false
                        result.Errors = append(result.Errors, ValidationError{
                                Field:   prefix + ".fixType",
                                Message: fmt.Sprintf("Invalid fix type '%s'. Valid options: %s", task.FixType, strings.Join(validFixTypes, ", ")),
                        })
                }</span>

                // ERROR if fixType is set at task level (and not "none") but no fixCommand
                <span class="cov3" title="3">if task.FixType != "none" &amp;&amp; task.FixCommand == "" </span><span class="cov1" title="1">{
                        result.Valid = false
                        result.Errors = append(result.Errors, ValidationError{
                                Field:   prefix + ".fixCommand",
                                Message: "fixType is set but fixCommand is not specified",
                        })
                }</span>
        }

        // Warn if metricsPath is set but metricsFormat is not
        <span class="cov7" title="20">if task.MetricsPath != "" &amp;&amp; task.MetricsFormat == "" </span><span class="cov1" title="1">{
                result.Warnings = append(result.Warnings, ValidationError{
                        Field:   prefix + ".metricsFormat",
                        Message: "metricsPath is set but metricsFormat is not specified",
                })
        }</span>
}

// validatePhaseHeaders checks that phase headers are properly formatted
func validatePhaseHeaders(path string, result *ValidationResult) error <span class="cov4" title="5">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov3" title="4">lines := strings.Split(string(data), "\n")
        var currentSection string

        for _, line := range lines </span><span class="cov7" title="21">{
                trimmed := strings.TrimSpace(line)

                // Check for section headers
                if strings.HasPrefix(trimmed, "[tasks.phase-") </span><span class="cov2" title="2">{
                        // Extract section name
                        end := strings.Index(trimmed, "]")
                        if end &gt; 0 </span><span class="cov2" title="2">{
                                currentSection = trimmed[1:end]
                        }</span>
                }

                // If we're in a phase section, check for required fields
                <span class="cov7" title="21">if currentSection != "" &amp;&amp; strings.HasPrefix(currentSection, "tasks.phase-") </span><span class="cov5" title="8">{
                        if strings.HasPrefix(trimmed, "[") &amp;&amp; trimmed != "["+currentSection+"]" </span><span class="cov2" title="2">{
                                // We've moved to a new section
                                currentSection = ""
                        }</span>
                }
        }

        <span class="cov3" title="4">return nil</span>
}

// contains checks if a slice contains a string
func contains(slice []string, item string) bool <span class="cov8" title="34">{
        for _, s := range slice </span><span class="cov10" title="69">{
                if s == item </span><span class="cov7" title="22">{
                        return true
                }</span>
        }
        <span class="cov6" title="12">return false</span>
}

// PrintValidationResult prints the validation result in a human-readable format
func PrintValidationResult(path string, result *ValidationResult) <span class="cov3" title="4">{
        fmt.Println("â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”")
        fmt.Printf("ðŸ“‹ Validating: %s\n", path)

        if result.Valid &amp;&amp; len(result.Warnings) == 0 </span><span class="cov1" title="1">{
                fmt.Println("âœ… Configuration is valid!")
                fmt.Println()
                return
        }</span>

        <span class="cov3" title="3">if len(result.Errors) &gt; 0 </span><span class="cov2" title="2">{
                fmt.Printf("\nâŒ Found %d error(s):\n", len(result.Errors))
                for _, err := range result.Errors </span><span class="cov3" title="3">{
                        if err.Field != "" </span><span class="cov2" title="2">{
                                fmt.Printf("  â€¢ [%s] %s\n", err.Field, err.Message)
                        }</span> else<span class="cov1" title="1"> {
                                fmt.Printf("  â€¢ %s\n", err.Message)
                        }</span>
                }
                <span class="cov2" title="2">fmt.Println()</span>
        }

        <span class="cov3" title="3">if len(result.Warnings) &gt; 0 </span><span class="cov3" title="3">{
                fmt.Printf("âš ï¸  Found %d warning(s):\n", len(result.Warnings))
                for _, warn := range result.Warnings </span><span class="cov3" title="4">{
                        if warn.Field != "" </span><span class="cov2" title="2">{
                                fmt.Printf("  â€¢ [%s] %s\n", warn.Field, warn.Message)
                        }</span> else<span class="cov2" title="2"> {
                                fmt.Printf("  â€¢ %s\n", warn.Message)
                        }</span>
                }
                <span class="cov3" title="3">fmt.Println()</span>
        }

        <span class="cov3" title="3">if !result.Valid </span><span class="cov2" title="2">{
                fmt.Println("âŒ Configuration is INVALID")
        }</span> else<span class="cov1" title="1"> {
                fmt.Println("âœ… Configuration is valid (with warnings)")
        }</span>
        <span class="cov3" title="3">fmt.Println()</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Package dashboard generates HTML reports and dashboards from pipeline run data.
package dashboard

import (
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
        "sort"
        "time"

        "github.com/drew/devpipe/assets"
        "github.com/drew/devpipe/internal/model"
)

// Summary holds aggregated data across all runs
type Summary struct {
        TotalRuns       int                  `json:"totalRuns"`
        RecentRuns      []RunSummary         `json:"recentRuns"`
        TaskStats       map[string]TaskStats `json:"taskStats"`       // All runs
        TaskStatsRecent map[string]TaskStats `json:"taskStatsRecent"` // Most recent run only
        TaskStatsLast25 map[string]TaskStats `json:"taskStatsLast25"` // Last 25 runs
        LastGenerated   string               `json:"lastGenerated"`
        Username        string               `json:"username"`
        Greeting        string               `json:"greeting"`
        Version         string               `json:"version"`
}

// RunSummary is a condensed view of a single run
type RunSummary struct {
        RunID           string `json:"runId"`
        Timestamp       string `json:"timestamp"`
        Status          string `json:"status"` // "PASS", "FAIL", "PARTIAL"
        Duration        int64  `json:"duration"`
        PassCount       int    `json:"passCount"`
        FailCount       int    `json:"failCount"`
        SkipCount       int    `json:"skipCount"`
        TotalTasks      int    `json:"totalTasks"`
        Command         string `json:"command"`         // Full command line that was executed
        PipelineVersion string `json:"pipelineVersion"` // devpipe version used to run the pipeline
}

// TaskStats holds statistics for a specific task across runs
type TaskStats struct {
        ID          string  `json:"id"`
        Name        string  `json:"name"`
        TotalRuns   int     `json:"totalRuns"`
        PassCount   int     `json:"passCount"`
        FailCount   int     `json:"failCount"`
        SkipCount   int     `json:"skipCount"`
        AvgDuration float64 `json:"avgDuration"`
        LastStatus  string  `json:"lastStatus"`
}

// GenerateDashboard reads all runs and generates summary.json and report.html
func GenerateDashboard(outputRoot string) error <span class="cov1" title="1">{
        return GenerateDashboardWithVersion(outputRoot, "dev")
}</span>

// GenerateDashboardWithVersion generates dashboard with version info
func GenerateDashboardWithVersion(outputRoot, version string) error <span class="cov2" title="2">{
        return GenerateDashboardWithOptions(outputRoot, version, false, "")
}</span>

// GenerateDashboardWithOptions generates dashboard with full control
func GenerateDashboardWithOptions(outputRoot, version string, regenerateAll bool, currentRunID string) error <span class="cov3" title="5">{
        runsDir := filepath.Join(outputRoot, "runs")

        // Read all run.json files
        runs, err := loadAllRuns(runsDir)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load runs: %w", err)
        }</span>

        // Aggregate data
        <span class="cov3" title="5">summary := aggregateRuns(runs, version)

        // Write summary.json
        summaryPath := filepath.Join(outputRoot, "summary.json")
        if err := writeSummaryJSON(summaryPath, summary); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write summary.json: %w", err)
        }</span>

        // Copy mascot image to output directory
        <span class="cov3" title="5">if err := copyMascotAssets(outputRoot); err != nil </span><span class="cov0" title="0">{
                // Don't fail if mascot copy fails, just warn
                fmt.Fprintf(os.Stderr, "WARNING: failed to copy mascot assets: %v\n", err)
        }</span>

        // Generate HTML dashboard
        <span class="cov3" title="5">htmlPath := filepath.Join(outputRoot, "report.html")
        if err := writeHTMLDashboard(htmlPath, summary); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write report.html: %w", err)
        }</span>

        // Generate individual run detail pages
        <span class="cov3" title="5">for _, run := range runs </span><span class="cov2" title="3">{
                // Skip report generation for existing runs unless regenerateAll is true
                // or this is the current run
                if !regenerateAll &amp;&amp; run.RunID != currentRunID &amp;&amp; run.ReportVersion != "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov2" title="3">runDir := filepath.Join(outputRoot, "runs", run.RunID)

                // Update ReportVersion in run.json
                run.ReportVersion = version
                if err := writeRunJSON(filepath.Join(runDir, "run.json"), run); err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "WARNING: failed to update run.json for run %s: %v\n", run.RunID, err)
                }</span>

                // Generate run detail HTML
                <span class="cov2" title="3">detailPath := filepath.Join(runDir, "report.html")
                if err := writeRunDetailHTML(detailPath, run); err != nil </span><span class="cov0" title="0">{
                        // Don't fail if one detail page fails, but log it
                        fmt.Fprintf(os.Stderr, "WARNING: failed to generate report for run %s: %v\n", run.RunID, err)
                        continue</span>
                }

                // Generate IDE viewer HTML with embedded file list
                <span class="cov2" title="3">idePath := filepath.Join(runDir, "ide.html")
                if err := writeIDEViewer(idePath, run.RunID, runDir); err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "WARNING: failed to generate IDE for run %s: %v\n", run.RunID, err)
                }</span>
        }

        <span class="cov3" title="5">return nil</span>
}

// writeRunJSON writes the run record to run.json
func writeRunJSON(path string, run model.RunRecord) error <span class="cov3" title="4">{
        f, err := os.Create(path)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov3" title="4">defer f.Close()

        encoder := json.NewEncoder(f)
        encoder.SetIndent("", "  ")
        return encoder.Encode(run)</span>
}

// loadAllRuns reads all run.json files from the runs directory
func loadAllRuns(runsDir string) ([]model.RunRecord, error) <span class="cov4" title="10">{
        entries, err := os.ReadDir(runsDir)
        if err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return []model.RunRecord{}, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov4" title="10">var runs []model.RunRecord
        for _, entry := range entries </span><span class="cov5" title="11">{
                if !entry.IsDir() </span><span class="cov1" title="1">{
                        continue</span>
                }

                <span class="cov4" title="10">runJSONPath := filepath.Join(runsDir, entry.Name(), "run.json")
                data, err := os.ReadFile(runJSONPath)
                if err != nil </span><span class="cov1" title="1">{
                        continue</span> // Skip if can't read
                }

                <span class="cov4" title="9">var run model.RunRecord
                if err := json.Unmarshal(data, &amp;run); err != nil </span><span class="cov2" title="2">{
                        continue</span> // Skip if can't parse
                }

                <span class="cov4" title="7">runs = append(runs, run)</span>
        }

        // Sort by timestamp (newest first)
        <span class="cov4" title="10">sort.Slice(runs, func(i, j int) bool </span><span class="cov1" title="1">{
                return runs[i].Timestamp &gt; runs[j].Timestamp
        }</span>)

        <span class="cov4" title="10">return runs, nil</span>
}

// aggregateRuns creates a summary from all runs
func aggregateRuns(runs []model.RunRecord, version string) Summary <span class="cov4" title="7">{
        // Get username
        username := os.Getenv("USER")
        if username == "" </span><span class="cov0" title="0">{
                username = os.Getenv("USERNAME") // Windows fallback
        }</span>
        <span class="cov4" title="7">if username == "" </span><span class="cov0" title="0">{
                username = "friend"
        }</span>

        // Random greeting
        <span class="cov4" title="7">greetings := []string{
                "Hello",
                "Hi",
                "Hey",
                "Howdy",
                "Greetings",
                "Welcome back",
                "Good to see you",
                "Hey there",
                "Ahoy",
                "Yo",
        }
        greeting := greetings[time.Now().Unix()%int64(len(greetings))]

        summary := Summary{
                TotalRuns:       len(runs),
                RecentRuns:      []RunSummary{},
                TaskStats:       make(map[string]TaskStats),
                TaskStatsRecent: make(map[string]TaskStats),
                TaskStatsLast25: make(map[string]TaskStats),
                LastGenerated:   time.Now().UTC().Format(time.RFC3339),
                Username:        username,
                Greeting:        greeting,
                Version:         version,
        }

        // Add recent runs (limit to 100 for pagination)
        for i, run := range runs </span><span class="cov9" title="155">{
                if i &lt; 100 </span><span class="cov8" title="105">{
                        runSummary := summarizeRun(run)
                        summary.RecentRuns = append(summary.RecentRuns, runSummary)
                }</span>
        }

        // Calculate task stats for different ranges
        <span class="cov4" title="7">summary.TaskStats = calculateTaskStats(runs, len(runs))                // All runs
        summary.TaskStatsRecent = calculateTaskStats(runs, 1)                  // Most recent run
        summary.TaskStatsLast25 = calculateTaskStats(runs, min(25, len(runs))) // Last 25 runs

        return summary</span>
}

// calculateTaskStats aggregates task statistics for a given number of recent runs
func calculateTaskStats(runs []model.RunRecord, numRuns int) map[string]TaskStats <span class="cov6" title="24">{
        taskStats := make(map[string]TaskStats)
        taskDurations := make(map[string][]int64)

        // Process only the specified number of runs
        for i := 0; i &lt; numRuns &amp;&amp; i &lt; len(runs); i++ </span><span class="cov9" title="194">{
                run := runs[i]

                for _, task := range run.Tasks </span><span class="cov10" title="199">{
                        stats, exists := taskStats[task.ID]
                        if !exists </span><span class="cov6" title="22">{
                                stats = TaskStats{
                                        ID:   task.ID,
                                        Name: task.Name,
                                }
                        }</span>

                        <span class="cov10" title="199">stats.TotalRuns++
                        switch task.Status </span>{
                        case model.StatusPass:<span class="cov9" title="194">
                                stats.PassCount++</span>
                        case model.StatusFail:<span class="cov3" title="4">
                                stats.FailCount++</span>
                        case model.StatusSkipped:<span class="cov1" title="1">
                                stats.SkipCount++</span>
                        }

                        // Track duration for average
                        <span class="cov10" title="199">if !task.Skipped </span><span class="cov9" title="198">{
                                taskDurations[task.ID] = append(taskDurations[task.ID], task.DurationMs)
                        }</span>

                        // Update last status (from most recent run in this range)
                        <span class="cov10" title="199">if i == 0 </span><span class="cov6" title="23">{
                                stats.LastStatus = string(task.Status)
                        }</span>

                        <span class="cov10" title="199">taskStats[task.ID] = stats</span>
                }
        }

        // Calculate average durations
        <span class="cov6" title="24">for id, durations := range taskDurations </span><span class="cov6" title="21">{
                if len(durations) &gt; 0 </span><span class="cov6" title="21">{
                        var sum int64
                        for _, d := range durations </span><span class="cov9" title="198">{
                                sum += d
                        }</span>
                        <span class="cov6" title="21">stats := taskStats[id]
                        stats.AvgDuration = float64(sum) / float64(len(durations))
                        taskStats[id] = stats</span>
                }
        }

        <span class="cov6" title="24">return taskStats</span>
}

// min returns the minimum of two integers
func min(a, b int) int <span class="cov5" title="12">{
        if a &lt; b </span><span class="cov3" title="4">{
                return a
        }</span>
        <span class="cov4" title="8">return b</span>
}

// summarizeRun creates a RunSummary from a RunRecord
func summarizeRun(run model.RunRecord) RunSummary <span class="cov8" title="107">{
        summary := RunSummary{
                RunID:           run.RunID,
                Timestamp:       run.Timestamp,
                TotalTasks:      len(run.Tasks),
                Command:         cleanCommand(run.Command),
                PipelineVersion: run.PipelineVersion,
        }

        anyFailed := false
        var totalDuration int64

        for _, task := range run.Tasks </span><span class="cov9" title="112">{
                totalDuration += task.DurationMs

                switch task.Status </span>{
                case model.StatusPass:<span class="cov8" title="107">
                        summary.PassCount++</span>
                case model.StatusFail:<span class="cov2" title="2">
                        summary.FailCount++
                        anyFailed = true</span>
                case model.StatusSkipped:<span class="cov2" title="3">
                        summary.SkipCount++</span>
                }
        }

        <span class="cov8" title="107">summary.Duration = totalDuration

        if anyFailed </span><span class="cov2" title="2">{
                summary.Status = "FAIL"
        }</span> else<span class="cov8" title="105"> if summary.SkipCount == summary.TotalTasks </span><span class="cov1" title="1">{
                summary.Status = "SKIPPED"
        }</span> else<span class="cov8" title="104"> {
                summary.Status = "PASS"
        }</span>

        <span class="cov8" title="107">return summary</span>
}

// writeSummaryJSON writes the summary to a JSON file
func writeSummaryJSON(path string, summary Summary) error <span class="cov4" title="7">{
        data, err := json.MarshalIndent(summary, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov4" title="7">return os.WriteFile(path, data, 0644)</span>
}

// cleanCommand removes shell prompt cruft from old command strings
// Old format: "drew@drews-MBP.attlocal.net devpipe % ./devpipe --config ..."
// New format: "./devpipe --config ..."
func cleanCommand(cmd string) string <span class="cov9" title="114">{
        // Look for the pattern: username@hostname directory % command
        // We want to extract just the command part after the %
        for i := 0; i &lt; len(cmd); i++ </span><span class="cov8" title="69">{
                if cmd[i] == '%' &amp;&amp; i+1 &lt; len(cmd) &amp;&amp; cmd[i+1] == ' ' </span><span class="cov2" title="2">{
                        // Found "% ", return everything after it
                        return cmd[i+2:]
                }</span>
        }
        // No cruft found, return as-is
        <span class="cov9" title="112">return cmd</span>
}

// copyMascotAssets writes the embedded mascot image to the output directory
func copyMascotAssets(outputRoot string) error <span class="cov4" title="6">{
        mascotDir := filepath.Join(outputRoot, "mascot")
        if err := os.MkdirAll(mascotDir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create mascot directory: %w", err)
        }</span>

        <span class="cov4" title="6">mascotPath := filepath.Join(mascotDir, "squirrel-blank-eyes-transparent-cropped.png")
        if err := os.WriteFile(mascotPath, assets.MascotImage, 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write mascot image: %w", err)
        }</span>

        <span class="cov4" title="6">return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package dashboard

import (
        "fmt"
        "html/template"
        "os"
        "path/filepath"
        "strings"
        "time"

        "github.com/acarl005/stripansi"

        "github.com/drew/devpipe/internal/model"
)

// writeHTMLDashboard generates the HTML report
func writeHTMLDashboard(path string, summary Summary) error <span class="cov4" title="7">{
        type DashboardData struct {
                Summary
                Timezone string
        }

        data := DashboardData{
                Summary:  summary,
                Timezone: getLocalTimezone(),
        }

        tmpl, err := template.New("dashboard").Funcs(template.FuncMap{
                "formatDuration": formatDuration,
                "formatTime":     formatTime,
                "statusClass":    statusClass,
                "statusSymbol":   statusSymbol,
                "shortRunID":     shortRunID,
                "truncate":       truncateString,
                "phaseEmoji":     phaseEmoji,
                "float64":        func(i int) float64 </span><span class="cov5" title="20">{ return float64(i) }</span>,
                "mul":            func(a, b float64) float64 <span class="cov4" title="10">{ return a * b }</span>,
                "div":            func(a, b float64) float64 <span class="cov4" title="10">{ return a / b }</span>,
                "int64":          func(f float64) int64 <span class="cov4" title="10">{ return int64(f) }</span>,
        }).Parse(dashboardTemplate)

        <span class="cov4" title="7">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov4" title="7">f, err := os.Create(path)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>
        <span class="cov3" title="6">defer f.Close()

        return tmpl.Execute(f, data)</span>
}

func formatDuration(ms int64) string <span class="cov7" title="50">{
        if ms &lt; 1000 </span><span class="cov3" title="5">{
                return fmt.Sprintf("%dms", ms)
        }</span>
        <span class="cov6" title="45">seconds := float64(ms) / 1000.0
        if seconds &lt; 60 </span><span class="cov6" title="43">{
                return fmt.Sprintf("%.1fs", seconds)
        }</span>
        <span class="cov2" title="2">minutes := int(seconds / 60)
        secs := int(seconds) % 60
        return fmt.Sprintf("%dm %ds", minutes, secs)</span>
}

func formatTime(timestamp string) string <span class="cov6" title="43">{
        t, err := time.Parse(time.RFC3339, timestamp)
        if err != nil </span><span class="cov6" title="26">{
                return timestamp
        }</span>
        // Convert to local timezone
        <span class="cov5" title="17">local := t.Local()
        return local.Format("2006-01-02 15:04:05")</span>
}

func getLocalTimezone() string <span class="cov5" title="17">{
        t := time.Now()
        zone, _ := t.Zone()
        return zone
}</span>

func statusClass(status string) string <span class="cov5" title="21">{
        switch status </span>{
        case "PASS":<span class="cov5" title="14">
                return "pass"</span>
        case "FAIL":<span class="cov2" title="2">
                return "fail"</span>
        case "SKIPPED":<span class="cov2" title="2">
                return "skip"</span>
        default:<span class="cov2" title="3">
                return ""</span>
        }
}

func statusSymbol(status string) string <span class="cov5" title="21">{
        switch status </span>{
        case "PASS":<span class="cov5" title="14">
                return "âœ“"</span>
        case "FAIL":<span class="cov2" title="2">
                return "âœ—"</span>
        case "SKIPPED":<span class="cov2" title="2">
                return "âŠ˜"</span>
        default:<span class="cov2" title="3">
                return "â€¢"</span>
        }
}

// shortRunID extracts the short ID from a full run ID
// Example: "2025-11-30T08-15-34Z_003617" -&gt; "003617"
func shortRunID(fullID string) string <span class="cov4" title="8">{
        // Find the last underscore and return everything after it
        for i := len(fullID) - 1; i &gt;= 0; i-- </span><span class="cov7" title="51">{
                if fullID[i] == '_' </span><span class="cov2" title="2">{
                        return fullID[i+1:]
                }</span>
        }
        // If no underscore found, return the full ID
        <span class="cov3" title="6">return fullID</span>
}

// truncateString truncates a string to maxLen characters and adds "..." if truncated
func truncateString(s string, maxLen int) string <span class="cov3" title="5">{
        if len(s) &lt;= maxLen </span><span class="cov2" title="3">{
                return s
        }</span>
        <span class="cov2" title="2">return s[:maxLen] + "..."</span>
}

// phaseEmoji returns an emoji for a phase based on its name or ID
func phaseEmoji(phaseName string) string <span class="cov5" title="24">{
        // Normalize to lowercase for matching
        name := strings.ToLower(phaseName)

        // Map phase names/keywords to emojis
        emojiMap := map[string]string{
                "validation":  "ðŸ§ª",  // Test tube for validation/testing
                "test":        "ðŸ§ª",  // Test tube
                "testing":     "ðŸ§ª",  // Test tube
                "build":       "ðŸ“¦",  // Package for build
                "package":     "ðŸ“¦",  // Package
                "compile":     "ðŸ”¨",  // Hammer for compilation
                "deploy":      "ðŸš€",  // Rocket for deployment
                "release":     "ðŸš€",  // Rocket for release
                "lint":        "ðŸ”",  // Magnifying glass for linting
                "security":    "ðŸ”’",  // Lock for security
                "e2e":         "ðŸŽ¯",  // Target for end-to-end tests
                "end-to-end":  "ðŸŽ¯",  // Target
                "integration": "ðŸ”—",  // Link for integration
                "setup":       "âš™ï¸", // Gear for setup
                "cleanup":     "ðŸ§¹",  // Broom for cleanup
                "docs":        "ðŸ“š",  // Books for documentation
                "publish":     "ðŸ“¤",  // Outbox for publishing
        }

        // Check for exact match first
        if emoji, ok := emojiMap[name]; ok </span><span class="cov4" title="12">{
                return emoji
        }</span>

        // Check if any keyword is contained in the phase name
        <span class="cov4" title="12">for keyword, emoji := range emojiMap </span><span class="cov9" title="196">{
                if strings.Contains(name, keyword) </span><span class="cov1" title="1">{
                        return emoji
                }</span>
        }

        // Default emoji
        <span class="cov4" title="11">return "ðŸ“‹"</span> // Clipboard as default
}

// writeRunDetailHTML generates a detail page for a single run
func writeRunDetailHTML(path string, run model.RunRecord) error <span class="cov4" title="9">{
        // Prepare data with log previews
        type TaskWithLog struct {
                model.TaskResult
                LogPreview   []string
                ArtifactPath string
                ArtifactSize int64
        }

        type DetailData struct {
                model.RunRecord
                TasksWithLogs    []TaskWithLog
                Timezone         string
                RawConfigContent string
                Phases           []PhaseGroup
        }

        data := DetailData{
                RunRecord:     run,
                TasksWithLogs: make([]TaskWithLog, 0, len(run.Tasks)),
                Timezone:      getLocalTimezone(),
        }

        // Load raw config file if it exists
        configPath := filepath.Join(filepath.Dir(path), "config.toml")
        if run.ConfigPath != "" </span><span class="cov2" title="2">{
                if configData, err := os.ReadFile(configPath); err == nil </span><span class="cov2" title="2">{
                        data.RawConfigContent = string(configData)
                }</span>
        }

        // Parse phases from config
        <span class="cov4" title="9">if phases, err := ParsePhasesFromConfig(configPath, run.Tasks); err == nil </span><span class="cov4" title="9">{
                data.Phases = phases
        }</span>

        // Load log previews and artifact info for each task
        <span class="cov4" title="9">for _, task := range run.Tasks </span><span class="cov4" title="11">{
                taskWithLog := TaskWithLog{
                        TaskResult: task,
                        LogPreview: readLastLines(task.LogPath, 10),
                }

                // Check for artifact file (stored in metrics for artifact format)
                if task.Metrics != nil &amp;&amp; task.Metrics.SummaryFormat == "artifact" </span>{<span class="cov1" title="1">
                        // The artifact path should be in the workdir + metrics path from task definition
                        // We need to reconstruct it from the run record
                        // For now, check if we can get it from the task's workdir
                }</span>

                <span class="cov4" title="11">data.TasksWithLogs = append(data.TasksWithLogs, taskWithLog)</span>
        }

        <span class="cov4" title="9">tmpl, err := template.New("rundetail").Funcs(template.FuncMap{
                "formatDuration": formatDuration,
                "formatTime":     formatTime,
                "statusClass":    statusClass,
                "statusSymbol":   statusSymbol,
                "phaseEmoji":     phaseEmoji,
                "string":         func(s model.TaskStatus) string </span><span class="cov6" title="35">{ return string(s) }</span>,
                "add": func(a, b interface{}) int <span class="cov0" title="0">{
                        return int(toFloat64(a)) + int(toFloat64(b))
                }</span>,
                "gt": func(a, b interface{}) bool <span class="cov0" title="0">{
                        return toFloat64(a) &gt; toFloat64(b)
                }</span>,
                "sub": func(a, b interface{}) float64 <span class="cov0" title="0">{
                        return toFloat64(a) - toFloat64(b)
                }</span>,
                "mul": func(a, b interface{}) float64 <span class="cov0" title="0">{
                        return toFloat64(a) * toFloat64(b)
                }</span>,
                "div": func(a, b interface{}) float64 <span class="cov0" title="0">{
                        aVal := toFloat64(a)
                        bVal := toFloat64(b)
                        if bVal == 0 </span><span class="cov0" title="0">{
                                return 0
                        }</span>
                        <span class="cov0" title="0">return aVal / bVal</span>
                },
                "deref": func(i *int) int <span class="cov2" title="2">{
                        if i != nil </span><span class="cov2" title="2">{
                                return *i
                        }</span>
                        <span class="cov0" title="0">return 0</span>
                },
                "hasPrefix": func(s, prefix string) bool <span class="cov0" title="0">{ return len(s) &gt;= len(prefix) &amp;&amp; s[:len(prefix)] == prefix }</span>,
                "trimPrefix": func(s, prefix string) string <span class="cov0" title="0">{
                        if len(s) &gt;= len(prefix) &amp;&amp; s[:len(prefix)] == prefix </span><span class="cov0" title="0">{
                                return s[len(prefix):]
                        }</span>
                        <span class="cov0" title="0">return s</span>
                },
                "slice": func() []model.ConfigValue <span class="cov0" title="0">{ return []model.ConfigValue{} }</span>,
                "append": func(slice []model.ConfigValue, item model.ConfigValue) []model.ConfigValue <span class="cov0" title="0">{
                        return append(slice, item)
                }</span>,
                "truncate": func(s string, maxLen int) string <span class="cov4" title="11">{
                        if len(s) &lt;= maxLen </span><span class="cov4" title="11">{
                                return s
                        }</span>
                        <span class="cov0" title="0">return s[:maxLen-3] + "..."</span>
                },
        }).Parse(runDetailTemplate)

        <span class="cov4" title="9">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov4" title="9">f, err := os.Create(path)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov4" title="9">defer f.Close()

        return tmpl.Execute(f, data)</span>
}

// toFloat64 converts various numeric types to float64 for template arithmetic
func toFloat64(v interface{}) float64 <span class="cov5" title="20">{
        switch val := v.(type) </span>{
        case int:<span class="cov4" title="7">
                return float64(val)</span>
        case int64:<span class="cov1" title="1">
                return float64(val)</span>
        case float64:<span class="cov4" title="9">
                return val</span>
        case float32:<span class="cov1" title="1">
                return float64(val)</span>
        default:<span class="cov2" title="2">
                return 0</span>
        }
}

// readLastLines reads the last N lines from a file and strips ANSI codes
func readLastLines(path string, n int) []string <span class="cov5" title="17">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov4" title="10">{
                return []string{"Error reading log file"}
        }</span>

        // Strip ANSI codes from entire content first
        <span class="cov4" title="7">cleanData := stripansi.Strip(string(data))

        // Split by newlines
        allLines := []string{}
        currentLine := ""
        for _, ch := range cleanData </span><span class="cov10" title="332">{
                if ch == '\n' </span><span class="cov6" title="37">{
                        allLines = append(allLines, currentLine)
                        currentLine = ""
                }</span> else<span class="cov9" title="295"> {
                        currentLine += string(ch)
                }</span>
        }
        <span class="cov4" title="7">if currentLine != "" </span><span class="cov4" title="7">{
                allLines = append(allLines, currentLine)
        }</span>

        // Return last N lines
        <span class="cov4" title="7">if len(allLines) &lt;= n </span><span class="cov3" title="4">{
                return allLines
        }</span>
        <span class="cov2" title="3">return allLines[len(allLines)-n:]</span>
}

const dashboardTemplate = `&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;devpipe Dashboard&lt;/title&gt;
    &lt;style&gt;
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #f5f5f5;
            color: #333;
            line-height: 1.6;
        }
        
        .container {
            max-width: 1100px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            background: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .header-content {
            flex: 1;
        }
        
        h1 {
            font-size: 32px;
            margin-bottom: 8px;
            color: #2c3e50;
        }
        
        .tagline {
            color: #7f8c8d;
            font-size: 16px;
            margin-bottom: 12px;
        }
        
        .header-stats {
            color: #7f8c8d;
            font-size: 14px;
            margin-bottom: 8px;
        }
        
        .header-stats strong {
            color: #2c3e50;
            font-weight: 600;
        }
        
        .subtitle {
            color: #95a5a6;
            font-size: 13px;
        }
        
        .mascot-label {
            text-align: center;
            color: #95a5a6;
            font-size: 12px;
        }
        
        .mascot-wrapper {
            display: flex;
            align-items: flex-start;
        }
        
        .speech-bubble {
            position: relative;
            background: #f8f9fa;
            border: 2px solid #dee2e6;
            border-radius: 12px;
            padding: 10px 14px;
            font-size: 13px;
            color: #2c3e50;
            white-space: nowrap;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            margin-top: 50px;
        }
        
        .speech-bubble:after {
            content: '';
            position: absolute;
            right: -10px;
            top: 50%;
            transform: translateY(-50%);
            width: 0;
            height: 0;
            border-left: 10px solid #dee2e6;
            border-top: 8px solid transparent;
            border-bottom: 8px solid transparent;
        }
        
        .speech-bubble:before {
            content: '';
            position: absolute;
            right: -7px;
            top: 50%;
            transform: translateY(-50%);
            width: 0;
            height: 0;
            border-left: 8px solid #f8f9fa;
            border-top: 6px solid transparent;
            border-bottom: 6px solid transparent;
            z-index: 1;
        }
        
        .version-info {
            color: #95a5a6;
            font-size: 13px;
            font-family: monospace;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .stat-card {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .stat-value {
            font-size: 36px;
            font-weight: bold;
            color: #2c3e50;
        }
        
        .stat-label {
            color: #7f8c8d;
            font-size: 14px;
            margin-top: 5px;
        }
        
        .section {
            background: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 30px;
        }
        
        h2 {
            font-size: 24px;
            margin-bottom: 20px;
            color: #2c3e50;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            table-layout: fixed;
        }
        
        th {
            text-align: left;
            padding: 12px;
            background: #f8f9fa;
            font-weight: 600;
            color: #2c3e50;
            border-bottom: 2px solid #dee2e6;
        }
        
        td {
            padding: 12px;
            border-bottom: 1px solid #dee2e6;
        }
        
        /* Fixed column widths for Recent Runs table */
        #runsTable th:nth-child(1),
        #runsTable td:nth-child(1) { width: 90px; white-space: nowrap; } /* Run ID (short) */
        #runsTable th:nth-child(2),
        #runsTable td:nth-child(2) { width: 170px; white-space: nowrap; } /* Timestamp */
        #runsTable th:nth-child(3),
        #runsTable td:nth-child(3) { width: 110px; } /* Status */
        #runsTable th:nth-child(4),
        #runsTable td:nth-child(4) { width: 80px; white-space: nowrap; } /* Duration */
        #runsTable th:nth-child(5),
        #runsTable td:nth-child(5) { width: 60px; text-align: center; } /* Tasks */
        #runsTable th:nth-child(6),
        #runsTable td:nth-child(6) { width: auto; min-width: 300px; } /* Command - takes remaining space */
        
        tr:hover {
            background: #f8f9fa;
        }
        
        .status-pass {
            color: #27ae60;
            font-weight: bold;
        }
        
        .status-fail {
            color: #e74c3c;
            font-weight: bold;
        }
        
        .status-skip {
            color: #f39c12;
            font-weight: bold;
        }
        
        .badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
        }
        
        .badge-pass {
            background: #d4edda;
            color: #155724;
        }
        
        .badge-fail {
            background: #f8d7da;
            color: #721c24;
        }
        
        .badge-skip {
            background: #fff3cd;
            color: #856404;
        }
        
        .mono {
            font-family: 'Monaco', 'Menlo', 'Courier New', monospace;
            font-size: 13px;
        }
        
        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: #7f8c8d;
        }
        
        .empty-state-icon {
            font-size: 48px;
            margin-bottom: 20px;
        }
        
        .load-more-btn {
            padding: 12px 24px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .load-more-btn:hover {
            background: #2980b9;
        }
        
        .load-more-btn:disabled {
            background: #95a5a6;
            cursor: not-allowed;
        }
        
        /* Mascot Styles */
        .mascot {
            width: 200px;
            height: 200px;
            flex-shrink: 0;
            pointer-events: none;
            margin-left: 30px;
        }
        
        .mascot-container {
            position: relative;
            width: 100%;
            height: 100%;
        }
        
        .mascot-image {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }
        
        .mascot-eyes-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        .mascot-eye {
            position: absolute;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .mascot-eye-left {
            top: 29.5%;
            left: 13.1%;
            width: 13.08px;
            height: 19.91px;
        }
        
        .mascot-eye-right {
            top: 29.7%;
            left: 37.4%;
            width: 16.50px;
            height: 21.61px;
        }
        
        .mascot-pupil {
            position: relative;
            width: 5.69px;
            height: 6.83px;
            background: #ffffff;
            border-radius: 50%;
            transition: transform 0.1s ease-out;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class="container"&gt;
        &lt;header&gt;
            &lt;div class="header-content"&gt;
                &lt;h1&gt;ðŸ“Š DevPipe Dashboard&lt;/h1&gt;
                &lt;div class="tagline"&gt;Fast, local pipeline runner for development workflows.&lt;/div&gt;
                &lt;div class="header-stats"&gt;&lt;strong&gt;{{.TotalRuns}}&lt;/strong&gt; Total Runs, &lt;strong&gt;{{len .TaskStats}}&lt;/strong&gt; Tasks.&lt;/div&gt;
                &lt;br /&gt;
                &lt;div class="version-info"&gt;{{.Version}}&lt;/div&gt;
                &lt;div class="subtitle"&gt;Last updated: {{formatTime .LastGenerated}}&lt;/div&gt;
            &lt;/div&gt;
            &lt;!-- Mascot --&gt;
            &lt;div class="mascot-wrapper"&gt;
                &lt;div class="speech-bubble"&gt;{{.Greeting}} {{.Username}}!&lt;/div&gt;
                &lt;div&gt;
                    &lt;div class="mascot"&gt;
                        &lt;div class="mascot-container"&gt;
                            &lt;img src="mascot/squirrel-blank-eyes-transparent-cropped.png" alt="DevPipe Squirrel" class="mascot-image" onerror="this.style.display='none'"&gt;
                            &lt;div class="mascot-eyes-overlay"&gt;
                                &lt;div class="mascot-eye mascot-eye-left"&gt;
                                    &lt;div class="mascot-pupil"&gt;&lt;/div&gt;
                                &lt;/div&gt;
                                &lt;div class="mascot-eye mascot-eye-right"&gt;
                                    &lt;div class="mascot-pupil"&gt;&lt;/div&gt;
                                &lt;/div&gt;
                            &lt;/div&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;
                    &lt;div class="mascot-label"&gt;(flowmunk)&lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/header&gt;
        
        &lt;div class="section"&gt;
            &lt;h2&gt;Recent Runs&lt;/h2&gt;
            {{if .RecentRuns}}
            &lt;table id="runsTable"&gt;
                &lt;thead&gt;
                    &lt;tr&gt;
                        &lt;th&gt;Run ID&lt;/th&gt;
                        &lt;th&gt;Timestamp ({{.Timezone}})&lt;/th&gt;
                        &lt;th&gt;Status&lt;/th&gt;
                        &lt;th&gt;Duration&lt;/th&gt;
                        &lt;th&gt;Tasks&lt;/th&gt;
                        &lt;th&gt;Version&lt;/th&gt;
                        &lt;th&gt;Command&lt;/th&gt;
                    &lt;/tr&gt;
                &lt;/thead&gt;
                &lt;tbody id="runsTableBody"&gt;
                    {{range .RecentRuns}}
                    &lt;tr class="run-row" data-index="{{$.RecentRuns | len}}"&gt;
                        &lt;td class="mono"&gt;&lt;a href="runs/{{.RunID}}/report.html" title="{{.RunID}}"&gt;{{shortRunID .RunID}}&lt;/a&gt;&lt;/td&gt;
                        &lt;td&gt;{{formatTime .Timestamp}}&lt;/td&gt;
                        &lt;td&gt;
                            &lt;span class="badge badge-{{.Status | statusClass}}"&gt;
                                {{statusSymbol .Status}} {{.Status}}
                            &lt;/span&gt;
                        &lt;/td&gt;
                        &lt;td&gt;{{formatDuration .Duration}}&lt;/td&gt;
                        &lt;td&gt;{{.TotalTasks}}&lt;/td&gt;
                        &lt;td class="mono" style="font-size: 11px;"&gt;{{.PipelineVersion}}&lt;/td&gt;
                        &lt;td class="mono" style="font-size: 11px; max-width: 400px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;" title="{{.Command}}"&gt;{{.Command}}&lt;/td&gt;
                    &lt;/tr&gt;
                    {{end}}
                &lt;/tbody&gt;
            &lt;/table&gt;
            &lt;div id="loadMoreContainer" style="text-align: center; margin-top: 20px;"&gt;
                &lt;button id="loadMoreBtn" class="load-more-btn" onclick="loadMoreRuns()" style="display: none;"&gt;
                    Load More (25)
                &lt;/button&gt;
            &lt;/div&gt;
            {{else}}
            &lt;div class="empty-state"&gt;
                &lt;div class="empty-state-icon"&gt;ðŸ“­&lt;/div&gt;
                &lt;p&gt;No runs yet. Run devpipe to see results here!&lt;/p&gt;
            &lt;/div&gt;
            {{end}}
        &lt;/div&gt;
        
        &lt;div class="section"&gt;
            &lt;div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;"&gt;
                &lt;h2 style="margin: 0;"&gt;Task Statistics&lt;/h2&gt;
                &lt;div style="display: flex; align-items: center; gap: 10px;"&gt;
                    &lt;label for="statsFilter" style="font-size: 14px; color: #7f8c8d;"&gt;Show stats for:&lt;/label&gt;
                    &lt;select id="statsFilter" onchange="filterTaskStats()" style="padding: 8px 12px; border: 1px solid #dee2e6; border-radius: 4px; font-size: 14px; background: white; cursor: pointer;"&gt;
                        &lt;option value="recent"&gt;Most Recent Run&lt;/option&gt;
                        &lt;option value="last25" selected&gt;Last 25 Runs&lt;/option&gt;
                        &lt;option value="all"&gt;All Runs&lt;/option&gt;
                    &lt;/select&gt;
                &lt;/div&gt;
            &lt;/div&gt;
            {{if .TaskStats}}
            
            &lt;!-- All Runs Stats --&gt;
            &lt;table class="task-stats-table" data-filter="all" style="display: none;"&gt;
                &lt;thead&gt;
                    &lt;tr&gt;
                        &lt;th&gt;Task&lt;/th&gt;
                        &lt;th&gt;Total Runs&lt;/th&gt;
                        &lt;th&gt;Pass Rate&lt;/th&gt;
                        &lt;th&gt;Avg Duration&lt;/th&gt;
                    &lt;/tr&gt;
                &lt;/thead&gt;
                &lt;tbody&gt;
                    {{range .TaskStats}}
                    &lt;tr&gt;
                        &lt;td&gt;&lt;strong&gt;{{.Name}}&lt;/strong&gt; &lt;span class="mono" style="color: #7f8c8d;"&gt;({{.ID}})&lt;/span&gt;&lt;/td&gt;
                        &lt;td&gt;{{.TotalRuns}}&lt;/td&gt;
                        &lt;td&gt;
                            {{if gt .TotalRuns 0}}
                            {{printf "%.0f%%" (div (mul (float64 .PassCount) 100.0) (float64 .TotalRuns))}}
                            ({{.PassCount}}/{{.TotalRuns}})
                            {{else}}
                            N/A
                            {{end}}
                        &lt;/td&gt;
                        &lt;td&gt;{{formatDuration (int64 .AvgDuration)}}&lt;/td&gt;
                    &lt;/tr&gt;
                    {{end}}
                &lt;/tbody&gt;
            &lt;/table&gt;
            
            &lt;!-- Last 25 Runs Stats --&gt;
            &lt;table class="task-stats-table" data-filter="last25" style="display: table;"&gt;
                &lt;thead&gt;
                    &lt;tr&gt;
                        &lt;th&gt;Task&lt;/th&gt;
                        &lt;th&gt;Total Runs&lt;/th&gt;
                        &lt;th&gt;Pass Rate&lt;/th&gt;
                        &lt;th&gt;Avg Duration&lt;/th&gt;
                    &lt;/tr&gt;
                &lt;/thead&gt;
                &lt;tbody&gt;
                    {{range .TaskStatsLast25}}
                    &lt;tr&gt;
                        &lt;td&gt;&lt;strong&gt;{{.Name}}&lt;/strong&gt; &lt;span class="mono" style="color: #7f8c8d;"&gt;({{.ID}})&lt;/span&gt;&lt;/td&gt;
                        &lt;td&gt;{{.TotalRuns}}&lt;/td&gt;
                        &lt;td&gt;
                            {{if gt .TotalRuns 0}}
                            {{printf "%.0f%%" (div (mul (float64 .PassCount) 100.0) (float64 .TotalRuns))}}
                            ({{.PassCount}}/{{.TotalRuns}})
                            {{else}}
                            N/A
                            {{end}}
                        &lt;/td&gt;
                        &lt;td&gt;{{formatDuration (int64 .AvgDuration)}}&lt;/td&gt;
                    &lt;/tr&gt;
                    {{end}}
                &lt;/tbody&gt;
            &lt;/table&gt;
            
            &lt;!-- Most Recent Run Stats --&gt;
            &lt;table class="task-stats-table" data-filter="recent" style="display: none;"&gt;
                &lt;thead&gt;
                    &lt;tr&gt;
                        &lt;th&gt;Task&lt;/th&gt;
                        &lt;th&gt;Total Runs&lt;/th&gt;
                        &lt;th&gt;Pass Rate&lt;/th&gt;
                        &lt;th&gt;Avg Duration&lt;/th&gt;
                    &lt;/tr&gt;
                &lt;/thead&gt;
                &lt;tbody&gt;
                    {{range .TaskStatsRecent}}
                    &lt;tr&gt;
                        &lt;td&gt;&lt;strong&gt;{{.Name}}&lt;/strong&gt; &lt;span class="mono" style="color: #7f8c8d;"&gt;({{.ID}})&lt;/span&gt;&lt;/td&gt;
                        &lt;td&gt;{{.TotalRuns}}&lt;/td&gt;
                        &lt;td&gt;
                            {{if gt .TotalRuns 0}}
                            {{printf "%.0f%%" (div (mul (float64 .PassCount) 100.0) (float64 .TotalRuns))}}
                            ({{.PassCount}}/{{.TotalRuns}})
                            {{else}}
                            N/A
                            {{end}}
                        &lt;/td&gt;
                        &lt;td&gt;{{formatDuration (int64 .AvgDuration)}}&lt;/td&gt;
                    &lt;/tr&gt;
                    {{end}}
                &lt;/tbody&gt;
            &lt;/table&gt;
            
            {{else}}
            &lt;div class="empty-state"&gt;
                &lt;div class="empty-state-icon"&gt;ðŸ“Š&lt;/div&gt;
                &lt;p&gt;No task statistics available yet.&lt;/p&gt;
            &lt;/div&gt;
            {{end}}
        &lt;/div&gt;
    &lt;/div&gt;
    
    &lt;script&gt;
        // Pagination for Recent Runs
        let visibleRunCount = 25;
        const runsPerLoad = 25;
        const maxRuns = 100;
        
        function initializePagination() {
            const allRows = document.querySelectorAll('.run-row');
            const totalRuns = allRows.length;
            
            // Hide rows beyond the initial count
            allRows.forEach((row, index) =&gt; {
                if (index &gt;= visibleRunCount) {
                    row.style.display = 'none';
                }
            });
            
            // Show "Load More" button if there are more runs to display
            const loadMoreBtn = document.getElementById('loadMoreBtn');
            if (totalRuns &gt; visibleRunCount) {
                loadMoreBtn.style.display = 'inline-block';
                updateLoadMoreButton(totalRuns);
            }
        }
        
        function loadMoreRuns() {
            const allRows = document.querySelectorAll('.run-row');
            const totalRuns = allRows.length;
            
            // Show next batch of runs
            const newVisibleCount = Math.min(visibleRunCount + runsPerLoad, totalRuns);
            
            for (let i = visibleRunCount; i &lt; newVisibleCount; i++) {
                allRows[i].style.display = '';
            }
            
            visibleRunCount = newVisibleCount;
            
            // Update or hide the button
            if (visibleRunCount &gt;= totalRuns) {
                document.getElementById('loadMoreBtn').style.display = 'none';
            } else {
                updateLoadMoreButton(totalRuns);
            }
        }
        
        function updateLoadMoreButton(totalRuns) {
            const remaining = totalRuns - visibleRunCount;
            const nextBatch = Math.min(runsPerLoad, remaining);
            document.getElementById('loadMoreBtn').textContent = 'Load More (' + nextBatch + ')';
        }
        
        // Task Statistics Filtering - Simple table toggling
        function filterTaskStats() {
            const filter = document.getElementById('statsFilter').value;
            const tables = document.querySelectorAll('.task-stats-table');
            
            // Hide all tables
            tables.forEach(table =&gt; {
                table.style.display = 'none';
            });
            
            // Show the selected table
            const selectedTable = document.querySelector('.task-stats-table[data-filter="' + filter + '"]');
            if (selectedTable) {
                selectedTable.style.display = 'table';
            }
        }
        
        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            initializePagination();
        });
        
        // Mascot eye tracking
        (function() {
            const pupils = document.querySelectorAll('.mascot-pupil');
            const eyes = document.querySelectorAll('.mascot-eye');
            const mascot = document.querySelector('.mascot');
            
            // Base movement bounds for 200px mascot
            const baseLeftMaxDistanceX = 1.3;
            const baseLeftMaxDistanceY = 2.7;
            const baseRightMaxDistanceX = 3.0;
            const baseRightMaxDistanceY = 2.7;
            
            document.addEventListener('mousemove', function(e) {
                pupils.forEach(function(pupil, index) {
                    const eye = eyes[index];
                    const eyeRect = eye.getBoundingClientRect();
                    
                    // Get eye center position
                    const eyeCenterX = eyeRect.left + eyeRect.width / 2;
                    const eyeCenterY = eyeRect.top + eyeRect.height / 2;
                    
                    // Calculate angle to mouse
                    const angleRad = Math.atan2(e.clientY - eyeCenterY, e.clientX - eyeCenterX);
                    
                    // Get current mascot size and calculate scale factor
                    const currentSize = parseFloat(mascot.style.width) || 200;
                    const scaleFactor = currentSize / 200;
                    
                    // Scale movement bounds based on current size
                    const leftMaxDistanceX = baseLeftMaxDistanceX * scaleFactor;
                    const leftMaxDistanceY = baseLeftMaxDistanceY * scaleFactor;
                    const rightMaxDistanceX = baseRightMaxDistanceX * scaleFactor;
                    const rightMaxDistanceY = baseRightMaxDistanceY * scaleFactor;
                    
                    // Get max distance for this eye
                    const maxDistanceX = index === 0 ? leftMaxDistanceX : rightMaxDistanceX;
                    const maxDistanceY = index === 0 ? leftMaxDistanceY : rightMaxDistanceY;
                    
                    // Calculate pupil position
                    let pupilX = Math.cos(angleRad) * maxDistanceX;
                    let pupilY = Math.sin(angleRad) * maxDistanceY;
                    
                    // Constrain to ellipse
                    const normalizedX = pupilX / maxDistanceX;
                    const normalizedY = pupilY / maxDistanceY;
                    const distanceFromCenter = Math.sqrt(normalizedX * normalizedX + normalizedY * normalizedY);
                    
                    if (distanceFromCenter &gt; 1) {
                        pupilX = (normalizedX / distanceFromCenter) * maxDistanceX;
                        pupilY = (normalizedY / distanceFromCenter) * maxDistanceY;
                    }
                    
                    // Apply transform
                    pupil.style.transform = 'translate(' + pupilX + 'px, ' + pupilY + 'px)';
                });
            });
        })();
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
`

const runDetailTemplate = `&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;Run {{.RunID}} - devpipe&lt;/title&gt;
    &lt;style&gt;
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #f5f5f5;
            color: #333;
            line-height: 1.6;
        }
        
        .container {
            max-width: 1100px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .breadcrumb {
            margin-bottom: 20px;
            color: #7f8c8d;
        }
        
        .breadcrumb a {
            color: #3498db;
            text-decoration: none;
        }
        
        .breadcrumb a:hover {
            text-decoration: underline;
        }
        
        header {
            background: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 30px;
        }
        
        h1 {
            font-size: 28px;
            margin-bottom: 10px;
            color: #2c3e50;
        }
        
        .run-meta {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        
        .meta-item {
            display: flex;
            flex-direction: column;
        }
        
        .meta-label {
            font-size: 12px;
            color: #7f8c8d;
            text-transform: uppercase;
            margin-bottom: 5px;
        }
        
        .meta-value {
            font-size: 16px;
            color: #2c3e50;
        }
        
        .section {
            background: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 30px;
        }
        
        h2 {
            font-size: 20px;
            margin-bottom: 20px;
            color: #2c3e50;
        }
        
        .task-card {
            border: 1px solid #dee2e6;
            border-radius: 6px;
            padding: 20px;
            margin-bottom: 15px;
        }
        
        .task-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 15px;
            gap: 15px;
        }
        
        .task-header &gt; div:first-child {
            flex: 1;
            min-width: 0;
        }
        
        .task-title {
            font-size: 18px;
            font-weight: 600;
            color: #2c3e50;
            word-break: break-word;
        }
        
        .task-id {
            font-family: 'Monaco', 'Menlo', 'Courier New', monospace;
            font-size: 13px;
            color: #7f8c8d;
            margin-left: 10px;
        }
        
        .task-details {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        
        .detail-item {
            display: flex;
            flex-direction: column;
        }
        
        .detail-label {
            font-size: 11px;
            color: #7f8c8d;
            text-transform: uppercase;
            margin-bottom: 3px;
        }
        
        .detail-value {
            font-size: 14px;
            color: #2c3e50;
        }
        
        .exit-code-success {
            color: #27ae60;
            font-weight: bold;
        }
        
        .exit-code-error {
            color: #e74c3c;
            font-weight: bold;
        }
        
        .status-pass {
            color: #27ae60;
            font-weight: bold;
        }
        
        .status-fail {
            color: #e74c3c;
            font-weight: bold;
        }
        
        .status-skip {
            color: #f39c12;
            font-weight: bold;
        }
        
        .badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
        }
        
        .badge-pass {
            background: #d4edda;
            color: #155724;
        }
        
        .badge-fail {
            background: #f8d7da;
            color: #721c24;
        }
        
        .badge-skip {
            background: #fff3cd;
            color: #856404;
        }
        
        .mono {
            font-family: 'Monaco', 'Menlo', 'Courier New', monospace;
            font-size: 13px;
        }
        
        .metrics-box {
            background: #f8f9fa;
            border-left: 4px solid #3498db;
            padding: 15px;
            margin-top: 15px;
            border-radius: 4px;
        }
        
        /* Phase Flow Styles */
        .phase-flow-container {
            position: relative;
        }
        
        .phase-flow-container.fullscreen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 9999;
            background: white;
            padding: 20px;
            overflow-y: auto;
            margin: 0;
            display: flex;
            flex-direction: column;
        }
        
        .phase-flow-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-shrink: 0;
        }
        
        .fullscreen-btn {
            padding: 8px 16px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        
        .fullscreen-btn:hover {
            background: #2980b9;
        }
        
        .fullscreen-btn.active {
            background: #27ae60;
        }
        
        .fullscreen-btn.active:hover {
            background: #229954;
        }
        
        /* Column slider styles */
        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .slider-label {
            font-size: 14px;
            color: #2c3e50;
            font-weight: 500;
            white-space: nowrap;
        }
        
        .column-slider {
            width: 120px;
            height: 6px;
            border-radius: 3px;
            background: #dee2e6;
            outline: none;
            -webkit-appearance: none;
        }
        
        .column-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #3498db;
            cursor: pointer;
        }
        
        .column-slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #3498db;
            cursor: pointer;
            border: none;
        }
        
        .phase-flow-scroll {
            overflow-x: auto;
            overflow-y: hidden;
            padding-bottom: 10px;
        }
        
        .phase-flow-container.fullscreen .phase-flow-scroll {
            flex: 1;
            overflow-x: auto;
            overflow-y: auto;
            min-height: 0;
        }
        
        .phase-flow {
            display: flex;
            gap: 40px;
            min-width: min-content;
        }
        
        .phase-container {
            flex-shrink: 0;
            width: fit-content;
            background: #f8f9fa;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            overflow: visible;
        }
        
        .phase-header {
            background: #f8f9fa;
            border-bottom: 2px solid #dee2e6;
            padding: 12px;
        }
        
        .phase-header-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .phase-header h3 {
            font-size: 18px;
            color: #2c3e50;
            margin: 0;
        }
        
        .phase-status {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .phase-status-icon {
            font-size: 20px;
        }
        
        .phase-status-icon.success { color: #27ae60; }
        .phase-status-icon.fail { color: #e74c3c; }
        
        .phase-desc {
            font-size: 12px;
            color: #7f8c8d;
            margin-top: 6px;
            margin-bottom: 4px;
            line-height: 1.5;
            overflow: hidden;
            text-overflow: ellipsis;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
        }
        
        .phase-meta {
            font-size: 13px;
            color: #7f8c8d;
            display: flex;
            justify-content: space-between;
        }
        
        .phase-tasks {
            padding: 12px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .phase-tasks.compact {
            display: grid;
            grid-auto-flow: column;
        }
        
        .phase-task-card {
            background: white;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            padding: 12px;
            cursor: pointer;
            transition: all 0.2s;
            box-sizing: border-box;
        }
        
        .phase-task-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            border-color: #3498db;
        }
        
        .phase-task-card-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 6px;
        }
        
        .phase-task-icon {
            font-size: 18px;
        }
        
        .phase-task-icon.success { color: #27ae60; }
        .phase-task-icon.fail { color: #e74c3c; }
        .phase-task-icon.skip { color: #f39c12; }
        
        .phase-task-name {
            font-weight: 600;
            font-size: 14px;
            color: #2c3e50;
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            min-width: 0;
        }
        
        .phase-task-duration {
            font-size: 12px;
            color: #7f8c8d;
            font-weight: 500;
        }
        
        .phase-task-desc {
            font-size: 11px;
            color: #7f8c8d;
            margin-top: 4px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .phase-task-type {
            display: inline-block;
            font-size: 10px;
            padding: 2px 6px;
            background: #ecf0f1;
            color: #7f8c8d;
            border-radius: 3px;
            margin-top: 4px;
        }
        
        .phase-arrow {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
            color: #95a5a6;
            flex-shrink: 0;
        }
        
        .metrics-title {
            font-weight: 600;
            margin-bottom: 10px;
            color: #2c3e50;
        }
        
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
        }
        
        .log-link {
            display: inline-block;
            margin-top: 10px;
            color: #3498db;
            text-decoration: none;
            font-size: 14px;
        }
        
        .log-link:hover {
            text-decoration: underline;
        }
        
        /* Mascot Styles */
        .mascot {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 200px;
            height: 200px;
            z-index: 1000;
            pointer-events: none;
            transition: opacity 0.3s ease-out;
        }
        
        .mascot.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        @media (max-width: 1500px) {
            .mascot {
                display: none;
            }
        }
        
        .mascot-container {
            position: relative;
            width: 100%;
            height: 100%;
        }
        
        .mascot-image {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }
        
        .mascot-eyes-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        .mascot-eye {
            position: absolute;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .mascot-eye-left {
            top: 29.5%;
            left: 13.1%;
            width: 13.08px;
            height: 19.91px;
        }
        
        .mascot-eye-right {
            top: 29.7%;
            left: 37.4%;
            width: 16.50px;
            height: 21.61px;
        }
        
        .mascot-pupil {
            position: relative;
            width: 5.69px;
            height: 6.83px;
            background: #ffffff;
            border-radius: 50%;
            transition: transform 0.1s ease-out;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;!-- Mascot --&gt;
    &lt;div class="mascot"&gt;
        &lt;div class="mascot-container"&gt;
            &lt;img src="../../mascot/squirrel-blank-eyes-transparent.png" alt="DevPipe Squirrel" class="mascot-image" onerror="this.style.display='none'"&gt;
            &lt;div class="mascot-eyes-overlay"&gt;
                &lt;div class="mascot-eye mascot-eye-left"&gt;
                    &lt;div class="mascot-pupil"&gt;&lt;/div&gt;
                &lt;/div&gt;
                &lt;div class="mascot-eye mascot-eye-right"&gt;
                    &lt;div class="mascot-pupil"&gt;&lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class="container"&gt;
        &lt;div class="breadcrumb"&gt;
            &lt;a href="../../report.html"&gt;â† Back to Dashboard&lt;/a&gt;
        &lt;/div&gt;
        
        &lt;header&gt;
            &lt;h1&gt;Run Details&lt;/h1&gt;
            &lt;div class="run-meta"&gt;
                &lt;div class="meta-item"&gt;
                    &lt;div class="meta-label"&gt;Run ID&lt;/div&gt;
                    &lt;div class="meta-value mono"&gt;{{.RunID}}&lt;/div&gt;
                &lt;/div&gt;
                &lt;div class="meta-item"&gt;
                    &lt;div class="meta-label"&gt;Timestamp ({{.Timezone}})&lt;/div&gt;
                    &lt;div class="meta-value"&gt;{{formatTime .Timestamp}}&lt;/div&gt;
                &lt;/div&gt;
                &lt;div class="meta-item"&gt;
                    &lt;div class="meta-label"&gt;Repo Root&lt;/div&gt;
                    &lt;div class="meta-value mono"&gt;{{.RepoRoot}}&lt;/div&gt;
                &lt;/div&gt;
                {{if .PipelineVersion}}
                &lt;div class="meta-item"&gt;
                    &lt;div class="meta-label"&gt;Pipeline Version&lt;/div&gt;
                    &lt;div class="meta-value mono"&gt;{{.PipelineVersion}}&lt;/div&gt;
                &lt;/div&gt;
                {{end}}
                {{if .ReportVersion}}
                &lt;div class="meta-item"&gt;
                    &lt;div class="meta-label"&gt;Report Version&lt;/div&gt;
                    &lt;div class="meta-value mono"&gt;{{.ReportVersion}}&lt;/div&gt;
                &lt;/div&gt;
                {{end}}
            &lt;/div&gt;
        &lt;/header&gt;
        
        &lt;div class="section"&gt;
            &lt;h2&gt;Run&lt;/h2&gt;
            
            {{if .Command}}
            &lt;div class="detail-item" style="margin-bottom: 20px;"&gt;
                &lt;div class="detail-label"&gt;Command&lt;/div&gt;
                &lt;div class="detail-value mono" style="font-size: 11px; background: #f8f9fa; padding: 8px; border-radius: 4px;"&gt;{{.Command}}&lt;/div&gt;
            &lt;/div&gt;
            {{end}}
            
            &lt;div style="display: grid; grid-template-columns: 1fr 1fr; gap: 30px; margin-bottom: 20px;"&gt;
                &lt;div&gt;
                    &lt;h3 style="font-size: 16px; color: #2c3e50; margin-bottom: 15px; padding-bottom: 8px; border-bottom: 2px solid #dee2e6;"&gt;Configuration&lt;/h3&gt;
                    &lt;div class="task-details" style="grid-template-columns: 1fr;"&gt;
                        &lt;div class="detail-item"&gt;
                            &lt;div class="detail-label"&gt;Config File&lt;/div&gt;
                            &lt;div class="detail-value"&gt;
                                {{if .ConfigPath}}
                                &lt;a href="config.toml" class="log-link"&gt;{{.ConfigPath}}&lt;/a&gt;
                                {{else}}
                                Built-in tasks
                                {{end}}
                            &lt;/div&gt;
                        &lt;/div&gt;
                        &lt;div class="detail-item"&gt;
                            &lt;div class="detail-label"&gt;Fast Mode&lt;/div&gt;
                            &lt;div class="detail-value"&gt;{{if .Flags.Fast}}Yes{{else}}No{{end}}&lt;/div&gt;
                        &lt;/div&gt;
                        &lt;div class="detail-item"&gt;
                            &lt;div class="detail-label"&gt;Fail Fast&lt;/div&gt;
                            &lt;div class="detail-value"&gt;{{if .Flags.FailFast}}Yes{{else}}No{{end}}&lt;/div&gt;
                        &lt;/div&gt;
                        &lt;div class="detail-item"&gt;
                            &lt;div class="detail-label"&gt;Dry Run&lt;/div&gt;
                            &lt;div class="detail-value"&gt;{{if .Flags.DryRun}}Yes{{else}}No{{end}}&lt;/div&gt;
                        &lt;/div&gt;
                        {{if .Flags.Only}}
                        &lt;div class="detail-item"&gt;
                            &lt;div class="detail-label"&gt;Only&lt;/div&gt;
                            &lt;div class="detail-value mono"&gt;{{.Flags.Only}}&lt;/div&gt;
                        &lt;/div&gt;
                        {{end}}
                        {{if .Flags.Skip}}
                        &lt;div class="detail-item"&gt;
                            &lt;div class="detail-label"&gt;Skip&lt;/div&gt;
                            &lt;div class="detail-value mono"&gt;{{range .Flags.Skip}}{{.}} {{end}}&lt;/div&gt;
                        &lt;/div&gt;
                        {{end}}
                    &lt;/div&gt;
                &lt;/div&gt;
                
                {{if .Git}}
                &lt;div&gt;
                    &lt;h3 style="font-size: 16px; color: #2c3e50; margin-bottom: 15px; padding-bottom: 8px; border-bottom: 2px solid #dee2e6;"&gt;Git Information&lt;/h3&gt;
                    &lt;div class="task-details" style="grid-template-columns: 1fr;"&gt;
                        &lt;div class="detail-item"&gt;
                            &lt;div class="detail-label"&gt;Mode&lt;/div&gt;
                            &lt;div class="detail-value"&gt;{{.Git.mode}}&lt;/div&gt;
                        &lt;/div&gt;
                        &lt;div class="detail-item"&gt;
                            &lt;div class="detail-label"&gt;Reference&lt;/div&gt;
                            &lt;div class="detail-value mono"&gt;{{.Git.ref}}&lt;/div&gt;
                        &lt;/div&gt;
                        {{if .Git.changedFiles}}
                        &lt;div class="detail-item"&gt;
                            &lt;div class="detail-label"&gt;Changed Files ({{len .Git.changedFiles}})&lt;/div&gt;
                            &lt;div class="detail-value mono" style="font-size: 12px; line-height: 1.8;"&gt;
                                {{range .Git.changedFiles}}
                                &lt;div&gt;{{.}}&lt;/div&gt;
                                {{end}}
                            &lt;/div&gt;
                        &lt;/div&gt;
                        {{else}}
                        &lt;div class="detail-item"&gt;
                            &lt;div class="detail-label"&gt;Changed Files&lt;/div&gt;
                            &lt;div class="detail-value"&gt;0 files&lt;/div&gt;
                        &lt;/div&gt;
                        {{end}}
                    &lt;/div&gt;
                &lt;/div&gt;
                {{end}}
            &lt;/div&gt;
        &lt;/div&gt;
        
        {{if or .EffectiveConfig .ConfigPath}}
        &lt;div class="section"&gt;
            &lt;details&gt;
                &lt;summary style="cursor: pointer; font-weight: 600; color: #2c3e50; font-size: 20px; margin-bottom: 20px;"&gt;
                    &lt;h2 style="display: inline;"&gt;âš™ï¸ Configuration&lt;/h2&gt;
                &lt;/summary&gt;
                &lt;div&gt;
                    {{if .EffectiveConfig}}
                    &lt;div&gt;
                        &lt;div style="border: 1px solid #dee2e6; border-radius: 6px; padding: 15px; background: #f8f9fa;"&gt;
                            &lt;h3 style="font-weight: 600; color: #2c3e50; font-size: 16px; margin: 0 0 10px 0;"&gt;âš™ï¸ Effective Configuration&lt;/h3&gt;
                            &lt;p style="color: #7f8c8d; margin: 15px 0; font-size: 13px;"&gt;
                                Final configuration values used for this run, including their sources and overrides.
                            &lt;/p&gt;
                        
                        {{$defaults := slice}}
                        {{$defaultsGit := slice}}
                        {{$taskDefaults := slice}}
                        {{$tasks := slice}}
                        {{range .EffectiveConfig.Values}}
                            {{if hasPrefix .Key "defaults.git."}}
                                {{$defaultsGit = append $defaultsGit .}}
                            {{else if hasPrefix .Key "defaults."}}
                                {{$defaults = append $defaults .}}
                            {{else if hasPrefix .Key "task_defaults."}}
                                {{$taskDefaults = append $taskDefaults .}}
                            {{else if hasPrefix .Key "tasks."}}
                                {{$tasks = append $tasks .}}
                            {{end}}
                        {{end}}
                        
                        {{if $defaults}}
                        &lt;div style="margin-top: 20px;"&gt;
                            &lt;h4 style="color: #2c3e50; font-size: 14px; margin-bottom: 10px; padding-bottom: 5px; border-bottom: 2px solid #dee2e6;"&gt;Defaults&lt;/h4&gt;
                            &lt;table style="width: 100%; font-size: 13px;"&gt;
                                {{range $defaults}}
                                &lt;tr&gt;
                                    &lt;td class="mono" style="color: #495057; padding: 6px 0; width: 30%;"&gt;{{trimPrefix .Key "defaults."}}&lt;/td&gt;
                                    &lt;td class="mono" style="font-weight: bold; padding: 6px 0;"&gt;{{.Value}}&lt;/td&gt;
                                    &lt;td style="padding: 6px 0; text-align: right;"&gt;
                                        {{if eq .Source "config-file"}}
                                        &lt;span class="badge" style="background: #d4edda; color: #155724; font-size: 10px;"&gt;ðŸ“„ Config&lt;/span&gt;
                                        {{else if eq .Source "cli-flag"}}
                                        &lt;span class="badge" style="background: #cce5ff; color: #004085; font-size: 10px;"&gt;ðŸš© CLI&lt;/span&gt;
                                        {{else if eq .Source "default"}}
                                        &lt;span class="badge" style="background: #e2e3e5; color: #383d41; font-size: 10px;"&gt;âš™ï¸ Default&lt;/span&gt;
                                        {{end}}
                                        {{if .Overrode}}
                                        &lt;br&gt;&lt;span style="color: #7f8c8d; font-size: 11px;"&gt;(was: {{.Overrode}})&lt;/span&gt;
                                        {{end}}
                                    &lt;/td&gt;
                                &lt;/tr&gt;
                                {{end}}
                            &lt;/table&gt;
                        &lt;/div&gt;
                        {{end}}
                        
                        {{if $defaultsGit}}
                        &lt;div style="margin-top: 20px;"&gt;
                            &lt;h4 style="color: #2c3e50; font-size: 14px; margin-bottom: 10px; padding-bottom: 5px; border-bottom: 2px solid #dee2e6;"&gt;Git Settings&lt;/h4&gt;
                            &lt;table style="width: 100%; font-size: 13px;"&gt;
                                {{range $defaultsGit}}
                                &lt;tr&gt;
                                    &lt;td class="mono" style="color: #495057; padding: 6px 0; width: 30%;"&gt;{{trimPrefix .Key "defaults.git."}}&lt;/td&gt;
                                    &lt;td class="mono" style="font-weight: bold; padding: 6px 0;"&gt;{{.Value}}&lt;/td&gt;
                                    &lt;td style="padding: 6px 0; text-align: right;"&gt;
                                        {{if eq .Source "config-file"}}
                                        &lt;span class="badge" style="background: #d4edda; color: #155724; font-size: 10px;"&gt;ðŸ“„ Config&lt;/span&gt;
                                        {{else if eq .Source "cli-flag"}}
                                        &lt;span class="badge" style="background: #cce5ff; color: #004085; font-size: 10px;"&gt;ðŸš© CLI&lt;/span&gt;
                                        {{else if eq .Source "default"}}
                                        &lt;span class="badge" style="background: #e2e3e5; color: #383d41; font-size: 10px;"&gt;âš™ï¸ Default&lt;/span&gt;
                                        {{end}}
                                        {{if .Overrode}}
                                        &lt;br&gt;&lt;span style="color: #7f8c8d; font-size: 11px;"&gt;(was: {{.Overrode}})&lt;/span&gt;
                                        {{end}}
                                    &lt;/td&gt;
                                &lt;/tr&gt;
                                {{end}}
                            &lt;/table&gt;
                        &lt;/div&gt;
                        {{end}}
                        
                        {{if $taskDefaults}}
                        &lt;div style="margin-top: 20px;"&gt;
                            &lt;h4 style="color: #2c3e50; font-size: 14px; margin-bottom: 10px; padding-bottom: 5px; border-bottom: 2px solid #dee2e6;"&gt;Task Defaults&lt;/h4&gt;
                            &lt;table style="width: 100%; font-size: 13px;"&gt;
                                {{range $taskDefaults}}
                                &lt;tr&gt;
                                    &lt;td class="mono" style="color: #495057; padding: 6px 0; width: 30%;"&gt;{{trimPrefix .Key "task_defaults."}}&lt;/td&gt;
                                    &lt;td class="mono" style="font-weight: bold; padding: 6px 0;"&gt;{{.Value}}&lt;/td&gt;
                                    &lt;td style="padding: 6px 0; text-align: right;"&gt;
                                        {{if eq .Source "config-file"}}
                                        &lt;span class="badge" style="background: #d4edda; color: #155724; font-size: 10px;"&gt;ðŸ“„ Config&lt;/span&gt;
                                        {{else if eq .Source "default"}}
                                        &lt;span class="badge" style="background: #e2e3e5; color: #383d41; font-size: 10px;"&gt;âš™ï¸ Default&lt;/span&gt;
                                        {{end}}
                                    &lt;/td&gt;
                                &lt;/tr&gt;
                                {{end}}
                            &lt;/table&gt;
                        &lt;/div&gt;
                        {{end}}
                        
                        {{if $tasks}}
                        &lt;div style="margin-top: 20px;"&gt;
                            &lt;h4 style="color: #2c3e50; font-size: 14px; margin-bottom: 10px; padding-bottom: 5px; border-bottom: 2px solid #dee2e6;"&gt;Task Overrides&lt;/h4&gt;
                            &lt;table style="width: 100%; font-size: 13px;"&gt;
                                {{range $tasks}}
                                &lt;tr&gt;
                                    &lt;td class="mono" style="color: #495057; padding: 6px 0; width: 30%;"&gt;{{.Key}}&lt;/td&gt;
                                    &lt;td class="mono" style="font-weight: bold; padding: 6px 0;"&gt;{{.Value}}&lt;/td&gt;
                                    &lt;td style="padding: 6px 0; text-align: right;"&gt;
                                        {{if eq .Source "historical"}}
                                        &lt;span class="badge" style="background: #fff3cd; color: #856404; font-size: 10px;"&gt;ðŸ“Š Historical&lt;/span&gt;
                                        {{else if eq .Source "config-file"}}
                                        &lt;span class="badge" style="background: #d4edda; color: #155724; font-size: 10px;"&gt;ðŸ“„ Config&lt;/span&gt;
                                        {{end}}
                                        {{if .Overrode}}
                                        &lt;br&gt;&lt;span style="color: #7f8c8d; font-size: 11px;"&gt;(was: {{.Overrode}})&lt;/span&gt;
                                        {{end}}
                                    &lt;/td&gt;
                                &lt;/tr&gt;
                                {{end}}
                            &lt;/table&gt;
                        &lt;/div&gt;
                        {{end}}
                        &lt;/div&gt;
                    &lt;/div&gt;
                    {{end}}
                    
                    {{if .ConfigPath}}
                    &lt;div style="margin-top: 20px;"&gt;
                        &lt;div style="border: 1px solid #dee2e6; border-radius: 6px; padding: 15px; background: #f8f9fa;"&gt;
                            &lt;div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;"&gt;
                                &lt;h3 style="font-weight: 600; color: #2c3e50; font-size: 16px; margin: 0;"&gt;ðŸ“„ Raw Configuration File&lt;/h3&gt;
                                &lt;button onclick="toggleConfigFullscreen()" style="background: #3498db; color: white; border: none; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 12px; font-weight: 600;"&gt;
                                    â›¶ Fullscreen
                                &lt;/button&gt;
                            &lt;/div&gt;
                            &lt;p style="color: #7f8c8d; margin: 15px 0 10px 0; font-size: 13px;"&gt;
                                Configuration file as it was on disk at the time of the run.
                            &lt;/p&gt;
                            &lt;div id="rawConfigContainer" style="position: relative; overflow-x: auto;"&gt;
                                &lt;pre class="line-numbers" style="background: #2c3e50; border-radius: 4px; margin: 0;"&gt;&lt;code id="rawConfigContent" class="language-toml" style="font-size: 12px;"&gt;{{.RawConfigContent}}&lt;/code&gt;&lt;/pre&gt;
                            &lt;/div&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;
                    &lt;link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" /&gt;
                    &lt;link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css" rel="stylesheet" /&gt;
                    &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"&gt;&lt;/script&gt;
                    &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-toml.min.js"&gt;&lt;/script&gt;
                    &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"&gt;&lt;/script&gt;
                    &lt;script&gt;
                    (function() {
                        // Trigger Prism highlighting
                        Prism.highlightAll();
                    })();
                    
                    function toggleConfigFullscreen() {
                        const elem = document.getElementById('rawConfigContainer');
                        if (!document.fullscreenElement) {
                            elem.requestFullscreen().catch(err =&gt; {
                                alert('Error attempting to enable fullscreen: ' + err.message);
                            });
                        } else {
                            document.exitFullscreen();
                        }
                    }
                    &lt;/script&gt;
                    &lt;style&gt;
                    /* Override Prism theme colors */
                    .line-numbers .line-numbers-rows {
                        border-right-color: #34495e !important;
                    }
                    .line-numbers-rows &gt; span:before {
                        color: #7f8c8d !important;
                    }
                    /* Wrap indicator for continuation lines */
                    .line-numbers .line-numbers-rows &gt; span {
                        position: relative;
                    }
                    #rawConfigContainer:fullscreen {
                        background: #2c3e50;
                        padding: 20px;
                        overflow: auto;
                    }
                    #rawConfigContainer:fullscreen pre {
                        font-size: 14px !important;
                        max-width: 100%;
                        height: 100%;
                    }
                    #rawConfigContainer:fullscreen code {
                        font-size: 14px !important;
                    }
                    &lt;/style&gt;
                    {{end}}
                &lt;/div&gt;
            &lt;/details&gt;
        &lt;/div&gt;
        {{end}}
        
        {{if .Phases}}
        &lt;div class="section phase-flow-container" id="phaseFlow"&gt;
            &lt;div class="phase-flow-header"&gt;
                &lt;h2&gt;ðŸ”„ Pipeline Flow&lt;/h2&gt;
                &lt;div style="display: flex; gap: 15px; align-items: center;"&gt;
                    &lt;div class="slider-container"&gt;
                        &lt;span class="slider-label"&gt;Density:&lt;/span&gt;
                        &lt;input type="range" min="1" max="4" value="4" class="column-slider" id="columnSlider" oninput="updateColumns()"&gt;
                    &lt;/div&gt;
                    &lt;button class="fullscreen-btn" onclick="toggleFullscreen()"&gt;â›¶ Fullscreen&lt;/button&gt;
                &lt;/div&gt;
            &lt;/div&gt;
            
            &lt;div class="phase-flow-scroll"&gt;
                &lt;div class="phase-flow"&gt;
                    {{range $phaseIndex, $phase := .Phases}}
                    {{if $phaseIndex}}&lt;div class="phase-arrow"&gt;â†’&lt;/div&gt;{{end}}
                    
                    &lt;div class="phase-container"&gt;
                        &lt;div class="phase-header"&gt;
                            &lt;div class="phase-header-top"&gt;
                                &lt;h3&gt;{{phaseEmoji $phase.ID}} {{$phase.Name}}&lt;/h3&gt;
                                &lt;div class="phase-status"&gt;
                                    {{if eq $phase.Status "PASS"}}
                                    &lt;span class="phase-status-icon success"&gt;âœ“&lt;/span&gt;
                                    {{else}}
                                    &lt;span class="phase-status-icon fail"&gt;âœ—&lt;/span&gt;
                                    {{end}}
                                &lt;/div&gt;
                            &lt;/div&gt;
                            {{if $phase.Desc}}
                            &lt;div class="phase-desc" title="{{$phase.Desc}}"&gt;{{truncate $phase.Desc 50}}&lt;/div&gt;
                            {{end}}
                            &lt;div class="phase-meta"&gt;
                                &lt;span&gt;{{$phase.TaskCount}} tasks in parallel&lt;/span&gt;
                                &lt;span&gt;&lt;strong&gt;{{formatDuration $phase.TotalMs}}&lt;/strong&gt;&lt;/span&gt;
                            &lt;/div&gt;
                        &lt;/div&gt;
                        &lt;div class="phase-tasks compact"&gt;
                            {{range $phase.Tasks}}
                            &lt;div class="phase-task-card" data-task-id="{{.ID}}" onclick="scrollToTask('{{.ID}}')"&gt;
                                &lt;div class="phase-task-card-header"&gt;
                                    {{if eq (string .Status) "PASS"}}
                                    &lt;span class="phase-task-icon success"&gt;âœ“&lt;/span&gt;
                                    {{else if eq (string .Status) "FAIL"}}
                                    &lt;span class="phase-task-icon fail"&gt;âœ—&lt;/span&gt;
                                    {{else}}
                                    &lt;span class="phase-task-icon skip"&gt;âŠ˜&lt;/span&gt;
                                    {{end}}
                                    &lt;span class="phase-task-name" title="{{.Name}}{{if .Metrics}}{{if eq .Metrics.SummaryFormat "junit"}} ðŸ§ª{{else if eq .Metrics.SummaryFormat "sarif"}} ðŸ”’{{else if eq .Metrics.SummaryFormat "artifact"}} ðŸ“¦{{end}}{{end}}"&gt;{{truncate .Name 25}}{{if .Metrics}}{{if eq .Metrics.SummaryFormat "junit"}} ðŸ§ª{{else if eq .Metrics.SummaryFormat "sarif"}} ðŸ”’{{else if eq .Metrics.SummaryFormat "artifact"}} ðŸ“¦{{end}}{{end}}&lt;/span&gt;
                                    &lt;span class="phase-task-duration"&gt;{{formatDuration .DurationMs}}&lt;/span&gt;
                                &lt;/div&gt;
                                {{if .Desc}}
                                &lt;div class="phase-task-desc" title="{{.Desc}}"&gt;{{truncate .Desc 80}}&lt;/div&gt;
                                {{else}}
                                &lt;div class="phase-task-desc"&gt;{{.ID}}&lt;/div&gt;
                                {{end}}
                                {{if .Type}}
                                &lt;span class="phase-task-type"&gt;{{.Type}}&lt;/span&gt;
                                {{end}}
                            &lt;/div&gt;
                            {{end}}
                        &lt;/div&gt;
                    &lt;/div&gt;
                    {{end}}
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        {{end}}
        
        &lt;div class="section"&gt;
            &lt;h2&gt;Tasks ({{len .TasksWithLogs}})&lt;/h2&gt;
            {{range .TasksWithLogs}}
            &lt;div class="task-card"&gt;
                &lt;div class="task-header"&gt;
                    &lt;div&gt;
                        &lt;span class="task-title"&gt;{{.Name}}&lt;/span&gt;
                        &lt;span class="task-id"&gt;({{.ID}})&lt;/span&gt;
                    &lt;/div&gt;
                    &lt;span class="badge badge-{{.Status | string | statusClass}}"&gt;
                        {{.Status | string | statusSymbol}} {{.Status}}
                    &lt;/span&gt;
                &lt;/div&gt;
                
                &lt;div class="task-details"&gt;
                    &lt;div class="detail-item"&gt;
                        &lt;div class="detail-label"&gt;Type&lt;/div&gt;
                        &lt;div class="detail-value"&gt;{{.Type}}&lt;/div&gt;
                    &lt;/div&gt;
                    &lt;div class="detail-item"&gt;
                        &lt;div class="detail-label"&gt;Duration&lt;/div&gt;
                        &lt;div class="detail-value"&gt;{{formatDuration .DurationMs}}&lt;/div&gt;
                    &lt;/div&gt;
                    {{if .ExitCode}}
                    &lt;div class="detail-item"&gt;
                        &lt;div class="detail-label"&gt;Exit Code&lt;/div&gt;
                        &lt;div class="detail-value"&gt;
                            {{$exitCode := deref .ExitCode}}
                            {{if eq $exitCode 0}}
                            &lt;span class="exit-code-success"&gt;0&lt;/span&gt;
                            {{else}}
                            &lt;span class="exit-code-error"&gt;{{$exitCode}}&lt;/span&gt;
                            {{end}}
                        &lt;/div&gt;
                    &lt;/div&gt;
                    {{end}}
                    {{if .AutoFixed}}
                    &lt;div class="detail-item"&gt;
                        &lt;div class="detail-label"&gt;Auto-Fixed&lt;/div&gt;
                        &lt;div class="detail-value"&gt;
                            &lt;span class="badge" style="background: #d4edda; color: #155724;"&gt;ðŸ”§ Yes&lt;/span&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;
                    {{if .InitialExitCode}}
                    &lt;div class="detail-item"&gt;
                        &lt;div class="detail-label"&gt;Initial Exit Code&lt;/div&gt;
                        &lt;div class="detail-value"&gt;
                            &lt;span class="exit-code-error"&gt;{{deref .InitialExitCode}}&lt;/span&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;
                    {{end}}
                    &lt;div class="detail-item"&gt;
                        &lt;div class="detail-label"&gt;Fix Duration&lt;/div&gt;
                        &lt;div class="detail-value"&gt;{{formatDuration .FixDurationMs}}&lt;/div&gt;
                    &lt;/div&gt;
                    &lt;div class="detail-item"&gt;
                        &lt;div class="detail-label"&gt;Recheck Duration&lt;/div&gt;
                        &lt;div class="detail-value"&gt;{{formatDuration .RecheckDurationMs}}&lt;/div&gt;
                    &lt;/div&gt;
                    {{end}}
                    &lt;div class="detail-item"&gt;
                        &lt;div class="detail-label"&gt;Start Time ({{$.Timezone}})&lt;/div&gt;
                        &lt;div class="detail-value"&gt;{{formatTime .StartTime}}&lt;/div&gt;
                    &lt;/div&gt;
                    &lt;div class="detail-item"&gt;
                        &lt;div class="detail-label"&gt;End Time ({{$.Timezone}})&lt;/div&gt;
                        &lt;div class="detail-value"&gt;{{formatTime .EndTime}}&lt;/div&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
                
                &lt;div class="detail-item" style="margin-top: 15px;"&gt;
                    &lt;div class="detail-label"&gt;Command&lt;/div&gt;
                    &lt;div class="detail-value mono"&gt;{{.Command}}&lt;/div&gt;
                &lt;/div&gt;
                
                {{if .FixCommand}}
                &lt;div class="detail-item" style="margin-top: 10px;"&gt;
                    &lt;div class="detail-label"&gt;Fix Command&lt;/div&gt;
                    &lt;div class="detail-value mono"&gt;{{.FixCommand}}&lt;/div&gt;
                &lt;/div&gt;
                {{end}}
                
                {{if .Metrics}}
                &lt;div class="metrics-box"&gt;
                    {{if eq .Metrics.SummaryFormat "artifact"}}
                    &lt;div class="metrics-title"&gt;ðŸ“¦ Build Artifact&lt;/div&gt;
                    &lt;div class="metrics-grid"&gt;
                        &lt;div class="detail-item"&gt;
                            &lt;div class="detail-label"&gt;File Path&lt;/div&gt;
                            &lt;div class="detail-value mono" style="font-size: 11px;"&gt;{{index .Metrics.Data "path"}}&lt;/div&gt;
                        &lt;/div&gt;
                        &lt;div class="detail-item"&gt;
                            &lt;div class="detail-label"&gt;File Size&lt;/div&gt;
                            &lt;div class="detail-value" style="font-weight: bold;"&gt;{{index .Metrics.Data "size"}} bytes&lt;/div&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;
                    {{else if eq .Metrics.SummaryFormat "sarif"}}
                    &lt;div class="metrics-title"&gt;ðŸ”’ Security Scan Results (SARIF)&lt;/div&gt;
                    &lt;div class="metrics-grid"&gt;
                        &lt;div class="detail-item"&gt;
                            &lt;div class="detail-label"&gt;Total Issues&lt;/div&gt;
                            &lt;div class="detail-value" style="font-size: 18px; font-weight: bold; color: {{if gt (index .Metrics.Data "total") 0}}#e74c3c{{else}}#27ae60{{end}};"&gt;{{index .Metrics.Data "total"}}&lt;/div&gt;
                        &lt;/div&gt;
                        &lt;div class="detail-item"&gt;
                            &lt;div class="detail-label"&gt;Errors&lt;/div&gt;
                            &lt;div class="detail-value" style="color: {{if gt (index .Metrics.Data "errors") 0}}#e74c3c{{else}}#95a5a6{{end}}; font-weight: bold;"&gt;{{index .Metrics.Data "errors"}}&lt;/div&gt;
                        &lt;/div&gt;
                        &lt;div class="detail-item"&gt;
                            &lt;div class="detail-label"&gt;Warnings&lt;/div&gt;
                            &lt;div class="detail-value" style="color: {{if gt (index .Metrics.Data "warnings") 0}}#f39c12{{else}}#95a5a6{{end}}; font-weight: bold;"&gt;{{index .Metrics.Data "warnings"}}&lt;/div&gt;
                        &lt;/div&gt;
                        &lt;div class="detail-item"&gt;
                            &lt;div class="detail-label"&gt;Notes&lt;/div&gt;
                            &lt;div class="detail-value" style="color: #3498db;"&gt;{{index .Metrics.Data "notes"}}&lt;/div&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;
                    {{$findings := index .Metrics.Data "findings"}}
                    {{if $findings}}
                    &lt;details style="margin-top: 15px;" {{if gt (index .Metrics.Data "total") 0}}open{{end}}&gt;
                        &lt;summary style="cursor: pointer; color: #3498db; font-weight: 600; user-select: none;"&gt;
                            ðŸ” View Security Findings
                        &lt;/summary&gt;
                        &lt;div style="margin-top: 10px; padding: 10px; background: white; border-radius: 4px; font-size: 13px;"&gt;
                            {{$rules := index .Metrics.Data "rules"}}
                            {{if $rules}}
                            &lt;div style="margin-bottom: 15px; padding-bottom: 15px; border-bottom: 1px solid #dee2e6;"&gt;
                                &lt;strong style="display: block; margin-bottom: 10px;"&gt;Issues by Rule:&lt;/strong&gt;
                                &lt;div style="display: flex; flex-wrap: wrap; gap: 8px;"&gt;
                                    {{range $rules}}
                                    &lt;span style="padding: 4px 8px; background: #f8f9fa; border-radius: 3px; font-size: 11px; border-left: 3px solid #e74c3c;"&gt;
                                        &lt;strong&gt;{{.id}}&lt;/strong&gt;: {{.count}} issue{{if gt .count 1}}s{{end}}
                                        {{if .severity}}&lt;span style="color: #95a5a6; margin-left: 4px;"&gt;(severity: {{.severity}})&lt;/span&gt;{{end}}
                                    &lt;/span&gt;
                                    {{end}}
                                &lt;/div&gt;
                            &lt;/div&gt;
                            {{end}}
                            &lt;div style="max-height: 500px; overflow-y: auto;"&gt;
                                {{range $findings}}
                                &lt;div style="padding: 10px; margin-bottom: 8px; background: #f8f9fa; border-left: 4px solid {{if eq .level "error"}}#e74c3c{{else if eq .level "warning"}}#f39c12{{else}}#3498db{{end}}; border-radius: 3px; font-size: 12px;"&gt;
                                    &lt;div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 6px;"&gt;
                                        &lt;div style="flex: 1;"&gt;
                                            &lt;span style="font-weight: 600; color: #2c3e50;"&gt;{{.ruleId}}&lt;/span&gt;
                                            {{if .ruleName}}
                                            &lt;span style="color: #7f8c8d; font-size: 11px; margin-left: 5px;"&gt;({{.ruleName}})&lt;/span&gt;
                                            {{end}}
                                        &lt;/div&gt;
                                        &lt;span style="color: {{if eq .level "error"}}#e74c3c{{else if eq .level "warning"}}#f39c12{{else}}#3498db{{end}}; font-weight: bold; font-size: 11px; white-space: nowrap; margin-left: 10px;"&gt;
                                            {{if eq .level "error"}}âŒ{{else if eq .level "warning"}}âš ï¸{{else}}â„¹ï¸{{end}} {{.level}}
                                        &lt;/span&gt;
                                    &lt;/div&gt;
                                    &lt;div style="color: #2c3e50; margin-bottom: 4px;"&gt;{{.message}}&lt;/div&gt;
                                    &lt;div style="color: #7f8c8d; font-size: 11px; font-family: 'Monaco', 'Menlo', monospace;"&gt;
                                        ðŸ“„ {{.file}}:{{.line}}{{if .column}}:{{.column}}{{end}}
                                    &lt;/div&gt;
                                    {{if .shortDesc}}
                                    &lt;div style="color: #7f8c8d; font-size: 11px; margin-top: 4px; font-style: italic;"&gt;{{.shortDesc}}&lt;/div&gt;
                                    {{end}}
                                    {{if .severity}}
                                    &lt;div style="margin-top: 4px;"&gt;
                                        &lt;span style="background: #e74c3c; color: white; padding: 2px 6px; border-radius: 3px; font-size: 10px; font-weight: bold;"&gt;
                                            CVSS: {{.severity}}
                                        &lt;/span&gt;
                                    &lt;/div&gt;
                                    {{end}}
                                    {{if .tags}}
                                    &lt;div style="margin-top: 6px; display: flex; flex-wrap: wrap; gap: 4px;"&gt;
                                        {{range .tags}}
                                        &lt;span style="background: #ecf0f1; color: #7f8c8d; padding: 2px 6px; border-radius: 3px; font-size: 10px;"&gt;{{.}}&lt;/span&gt;
                                        {{end}}
                                    &lt;/div&gt;
                                    {{end}}
                                    {{if .dataFlow}}
                                    &lt;details style="margin-top: 8px;"&gt;
                                        &lt;summary style="cursor: pointer; color: #3498db; font-size: 11px; user-select: none;"&gt;
                                            ðŸ”„ Data Flow ({{len .dataFlow}} steps)
                                        &lt;/summary&gt;
                                        &lt;div style="margin-top: 6px; padding-left: 10px; border-left: 2px solid #dee2e6;"&gt;
                                            {{range $index, $step := .dataFlow}}
                                            &lt;div style="margin: 4px 0; font-size: 11px; color: #7f8c8d;"&gt;
                                                {{add $index 1}}. {{$step.file}}:{{$step.line}}{{if $step.column}}:{{$step.column}}{{end}}
                                                {{if $step.message}}&lt;span style="color: #95a5a6;"&gt; - {{$step.message}}&lt;/span&gt;{{end}}
                                            &lt;/div&gt;
                                            {{end}}
                                        &lt;/div&gt;
                                    &lt;/details&gt;
                                    {{end}}
                                &lt;/div&gt;
                                {{end}}
                            &lt;/div&gt;
                        &lt;/div&gt;
                    &lt;/details&gt;
                    {{end}}
                    {{else if eq .Metrics.SummaryFormat "junit"}}
                    &lt;div class="metrics-title"&gt;ðŸ§ª Test Results (JUnit)&lt;/div&gt;
                    &lt;div class="metrics-grid"&gt;
                        &lt;div class="detail-item"&gt;
                            &lt;div class="detail-label"&gt;Total Tests&lt;/div&gt;
                            &lt;div class="detail-value" style="font-size: 18px; font-weight: bold;"&gt;{{index .Metrics.Data "tests"}}&lt;/div&gt;
                        &lt;/div&gt;
                        &lt;div class="detail-item"&gt;
                            &lt;div class="detail-label"&gt;Passed&lt;/div&gt;
                            {{$total := index .Metrics.Data "tests"}}
                            {{$failures := index .Metrics.Data "failures"}}
                            {{$errors := index .Metrics.Data "errors"}}
                            {{$skipped := index .Metrics.Data "skipped"}}
                            {{$passed := sub (sub (sub $total $failures) $errors) $skipped}}
                            &lt;div class="detail-value" style="color: #27ae60; font-weight: bold;"&gt;{{$passed}} âœ“&lt;/div&gt;
                        &lt;/div&gt;
                        &lt;div class="detail-item"&gt;
                            &lt;div class="detail-label"&gt;Failed&lt;/div&gt;
                            &lt;div class="detail-value" style="color: {{if gt (index .Metrics.Data "failures") 0.0}}#e74c3c{{else}}#95a5a6{{end}}; font-weight: bold;"&gt;{{index .Metrics.Data "failures"}}&lt;/div&gt;
                        &lt;/div&gt;
                        &lt;div class="detail-item"&gt;
                            &lt;div class="detail-label"&gt;Errors&lt;/div&gt;
                            &lt;div class="detail-value" style="color: {{if gt (index .Metrics.Data "errors") 0.0}}#e74c3c{{else}}#95a5a6{{end}}; font-weight: bold;"&gt;{{index .Metrics.Data "errors"}}&lt;/div&gt;
                        &lt;/div&gt;
                        &lt;div class="detail-item"&gt;
                            &lt;div class="detail-label"&gt;Skipped&lt;/div&gt;
                            &lt;div class="detail-value" style="color: #f39c12;"&gt;{{index .Metrics.Data "skipped"}}&lt;/div&gt;
                        &lt;/div&gt;
                        &lt;div class="detail-item"&gt;
                            &lt;div class="detail-label"&gt;Duration&lt;/div&gt;
                            &lt;div class="detail-value"&gt;{{printf "%.2f" (index .Metrics.Data "time")}}s&lt;/div&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;
                    &lt;details style="margin-top: 15px;" {{if or (gt $failures 0.0) (gt $errors 0.0)}}open{{end}}&gt;
                        &lt;summary style="cursor: pointer; color: #3498db; font-weight: 600; user-select: none;"&gt;
                            ðŸ“‹ View Detailed Breakdown
                        &lt;/summary&gt;
                        &lt;div style="margin-top: 10px; padding: 10px; background: white; border-radius: 4px; font-size: 13px;"&gt;
                            &lt;div style="margin-bottom: 8px;"&gt;
                                &lt;strong&gt;Pass Rate:&lt;/strong&gt; 
                                {{$passRate := mul (div (sub (sub (sub $total $failures) $errors) $skipped) $total) 100.0}}
                                &lt;span style="color: {{if ge $passRate 80.0}}#27ae60{{else if ge $passRate 50.0}}#f39c12{{else}}#e74c3c{{end}}; font-weight: bold;"&gt;
                                    {{printf "%.1f" $passRate}}%
                                &lt;/span&gt;
                            &lt;/div&gt;
                            &lt;div style="margin-bottom: 8px;"&gt;
                                &lt;strong&gt;Status Distribution:&lt;/strong&gt;
                                &lt;div style="display: flex; gap: 10px; margin-top: 5px;"&gt;
                                    &lt;span style="color: #27ae60;"&gt;âœ“ Passed: {{$passed}}&lt;/span&gt;
                                    &lt;span style="color: #e74c3c;"&gt;âœ— Failed: {{$failures}}&lt;/span&gt;
                                    &lt;span style="color: #e74c3c;"&gt;âš  Errors: {{$errors}}&lt;/span&gt;
                                    &lt;span style="color: #f39c12;"&gt;âŠ˜ Skipped: {{$skipped}}&lt;/span&gt;
                                &lt;/div&gt;
                            &lt;/div&gt;
                            &lt;div style="margin-bottom: 15px;"&gt;
                                &lt;strong&gt;Average Test Duration:&lt;/strong&gt; 
                                {{$avgDuration := div (index .Metrics.Data "time") $total}}
                                {{printf "%.3f" $avgDuration}}s per test
                            &lt;/div&gt;
                            {{$testcases := index .Metrics.Data "testcases"}}
                            {{if $testcases}}
                            &lt;div style="border-top: 1px solid #dee2e6; padding-top: 15px;"&gt;
                                &lt;strong style="display: block; margin-bottom: 10px;"&gt;Individual Test Cases:&lt;/strong&gt;
                                &lt;div style="max-height: 400px; overflow-y: auto;"&gt;
                                    {{range $testcases}}
                                    &lt;div style="padding: 8px; margin-bottom: 6px; background: #f8f9fa; border-left: 3px solid {{if eq .status "passed"}}#27ae60{{else if eq .status "failed"}}#e74c3c{{else if eq .status "error"}}#e74c3c{{else}}#f39c12{{end}}; border-radius: 3px; font-size: 12px;"&gt;
                                        &lt;div style="display: flex; justify-content: space-between; align-items: start;"&gt;
                                            &lt;div style="flex: 1;"&gt;
                                                &lt;span style="font-weight: 600; color: #2c3e50;"&gt;{{.name}}&lt;/span&gt;
                                                {{if .classname}}
                                                &lt;span style="color: #7f8c8d; font-size: 11px; margin-left: 5px;"&gt;({{.classname}})&lt;/span&gt;
                                                {{end}}
                                                {{if .message}}
                                                &lt;div style="color: #e74c3c; margin-top: 4px; font-size: 11px;"&gt;{{.message}}&lt;/div&gt;
                                                {{end}}
                                            &lt;/div&gt;
                                            &lt;div style="display: flex; align-items: center; gap: 8px; margin-left: 10px;"&gt;
                                                &lt;span style="color: {{if eq .status "passed"}}#27ae60{{else if eq .status "failed"}}#e74c3c{{else if eq .status "error"}}#e74c3c{{else}}#f39c12{{end}}; font-weight: bold; white-space: nowrap;"&gt;
                                                    {{if eq .status "passed"}}âœ“{{else if eq .status "failed"}}âœ—{{else if eq .status "error"}}âš {{else}}âŠ˜{{end}} {{.status}}
                                                &lt;/span&gt;
                                                &lt;span style="color: #95a5a6; font-size: 11px; white-space: nowrap;"&gt;{{printf "%.3f" .time}}s&lt;/span&gt;
                                            &lt;/div&gt;
                                        &lt;/div&gt;
                                    &lt;/div&gt;
                                    {{end}}
                                &lt;/div&gt;
                            &lt;/div&gt;
                            {{end}}
                        &lt;/div&gt;
                    &lt;/details&gt;
                    {{else}}
                    &lt;div class="metrics-title"&gt;ðŸ“Š Metrics ({{.Metrics.SummaryFormat}})&lt;/div&gt;
                    &lt;div class="metrics-grid"&gt;
                        {{range $key, $value := .Metrics.Data}}
                        &lt;div class="detail-item"&gt;
                            &lt;div class="detail-label"&gt;{{$key}}&lt;/div&gt;
                            &lt;div class="detail-value"&gt;{{$value}}&lt;/div&gt;
                        &lt;/div&gt;
                        {{end}}
                    &lt;/div&gt;
                    {{end}}
                &lt;/div&gt;
                {{end}}
                
                {{if .LogPath}}
                &lt;div class="detail-item" style="margin-top: 15px;"&gt;
                    &lt;div class="detail-label"&gt;Output (last 10 lines)&lt;/div&gt;
                    &lt;pre style="background: #2c3e50; color: #ecf0f1; padding: 15px; border-radius: 4px; overflow-x: auto; font-size: 12px; line-height: 1.5;"&gt;{{range .LogPreview}}{{.}}
{{end}}&lt;/pre&gt;
                    &lt;div style="display: flex; gap: 15px; margin-top: 10px;"&gt;
                        &lt;a href="logs/{{.ID}}.log" class="log-link"&gt;ðŸ“„ View raw log&lt;/a&gt;
                        &lt;a href="ide.html?file=logs/{{.ID}}.log" class="log-link"&gt;ðŸ–¥ï¸ View in web IDE&lt;/a&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
                {{end}}
            &lt;/div&gt;
            {{end}}
        &lt;/div&gt;
    &lt;/div&gt;
    
    &lt;script&gt;
        function updateColumns() {
            const slider = document.getElementById('columnSlider');
            const phaseTasks = document.querySelectorAll('.phase-tasks');
            
            const maxCols = parseInt(slider.value);
            
            // Update each phase based on its task count
            phaseTasks.forEach(tasks =&gt; {
                const taskCount = tasks.querySelectorAll('.phase-task-card').length;
                
                // Calculate actual columns needed
                // Use min(maxCols, ceil(taskCount / 5)) to determine columns
                const neededCols = Math.min(maxCols, Math.ceil(taskCount / 5));
                
                // Calculate rows per column (distribute evenly)
                const rowsPerCol = Math.ceil(taskCount / neededCols);
                
                // Set grid properties
                const colWidth = 280;
                const gap = 8;
                const padding = 12;
                
                // Width = padding-left + (colWidth * cols) + (gap * (cols - 1)) + padding-right
                // Simplifies to: (colWidth * cols) + (gap * (cols - 1)) + (padding * 2)
                const gridContentWidth = (colWidth * neededCols) + (gap * (neededCols - 1));
                const totalWidth = gridContentWidth + (padding * 2);
                
                tasks.style.gridTemplateColumns = 'repeat(' + neededCols + ', ' + colWidth + 'px)';
                tasks.style.gridTemplateRows = 'repeat(' + rowsPerCol + ', auto)';
                tasks.style.width = totalWidth + 'px';
                tasks.style.gap = gap + 'px';
                tasks.style.padding = padding + 'px';
            });
        }
        
        // Initialize on page load
        document.addEventListener('DOMContentLoaded', updateColumns);
        
        function toggleFullscreen() {
            const container = document.getElementById('phaseFlow');
            const fullscreenBtns = container.querySelectorAll('.fullscreen-btn');
            
            container.classList.toggle('fullscreen');
            
            // Find the fullscreen button (not the compact button)
            fullscreenBtns.forEach(btn =&gt; {
                if (btn.id !== 'compactBtn') {
                    if (container.classList.contains('fullscreen')) {
                        btn.textContent = 'âœ• Exit Fullscreen';
                    } else {
                        btn.textContent = 'â›¶ Fullscreen';
                    }
                }
            });
        }
        
        function scrollToTask(taskId) {
            // Exit fullscreen if active
            const container = document.getElementById('phaseFlow');
            const wasFullscreen = container &amp;&amp; container.classList.contains('fullscreen');
            
            if (wasFullscreen) {
                container.classList.remove('fullscreen');
                // Update the fullscreen button (not the slider)
                const fullscreenBtns = container.querySelectorAll('.fullscreen-btn');
                fullscreenBtns.forEach(btn =&gt; {
                    if (btn.id !== 'compactBtn') {
                        btn.textContent = 'â›¶ Fullscreen';
                    }
                });
            }
            
            // Function to find and scroll to task
            const doScroll = () =&gt; {
                const taskCards = document.querySelectorAll('.task-card');
                for (const card of taskCards) {
                    const titleEl = card.querySelector('.task-id');
                    if (titleEl &amp;&amp; titleEl.textContent.includes(taskId)) {
                        card.scrollIntoView({ behavior: 'smooth', block: 'start' });
                        // Highlight the card briefly
                        card.style.boxShadow = '0 0 0 3px #3498db';
                        setTimeout(() =&gt; {
                            card.style.boxShadow = '';
                        }, 2000);
                        break;
                    }
                }
            };
            
            // If we exited fullscreen, wait for DOM to reflow before scrolling
            if (wasFullscreen) {
                setTimeout(doScroll, 100);
            } else {
                doScroll();
            }
        }
        
        // Mascot keyboard toggle (h = hide, s = show)
        (function() {
            const mascot = document.querySelector('.mascot');
            
            document.addEventListener('keydown', function(e) {
                // Ignore if user is typing in an input field
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                    return;
                }
                
                if (e.key === 'h' || e.key === 'H') {
                    mascot.classList.add('hidden');
                } else if (e.key === 's' || e.key === 'S') {
                    mascot.classList.remove('hidden');
                }
            });
        })();
        
        // Mascot eye tracking
        (function() {
            const pupils = document.querySelectorAll('.mascot-pupil');
            const eyes = document.querySelectorAll('.mascot-eye');
            
            // Movement bounds for 200px mascot (scaled from 777px original, accounting for aspect ratio)
            const leftMaxDistanceX = 1.14;
            const leftMaxDistanceY = 4.55;
            const rightMaxDistanceX = 2.84;
            const rightMaxDistanceY = 4.55;
            
            document.addEventListener('mousemove', function(e) {
                pupils.forEach(function(pupil, index) {
                    const eye = eyes[index];
                    const eyeRect = eye.getBoundingClientRect();
                    
                    // Get eye center position
                    const eyeCenterX = eyeRect.left + eyeRect.width / 2;
                    const eyeCenterY = eyeRect.top + eyeRect.height / 2;
                    
                    // Calculate angle to mouse
                    const angleRad = Math.atan2(e.clientY - eyeCenterY, e.clientX - eyeCenterX);
                    
                    // Get max distance for this eye
                    const maxDistanceX = index === 0 ? leftMaxDistanceX : rightMaxDistanceX;
                    const maxDistanceY = index === 0 ? leftMaxDistanceY : rightMaxDistanceY;
                    
                    // Calculate pupil position
                    let pupilX = Math.cos(angleRad) * maxDistanceX;
                    let pupilY = Math.sin(angleRad) * maxDistanceY;
                    
                    // Constrain to ellipse
                    const normalizedX = pupilX / maxDistanceX;
                    const normalizedY = pupilY / maxDistanceY;
                    const distanceFromCenter = Math.sqrt(normalizedX * normalizedX + normalizedY * normalizedY);
                    
                    if (distanceFromCenter &gt; 1) {
                        pupilX = (normalizedX / distanceFromCenter) * maxDistanceX;
                        pupilY = (normalizedY / distanceFromCenter) * maxDistanceY;
                    }
                    
                    // Apply transform
                    pupil.style.transform = 'translate(' + pupilX + 'px, ' + pupilY + 'px)';
                });
            });
        })();
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
`
</pre>
		
		<pre class="file" id="file7" style="display: none">package dashboard

import (
        "encoding/json"
        "html/template"
        "os"
        "path/filepath"

        "github.com/acarl005/stripansi"
)

// FileInfo represents a file in the IDE file tree
type FileInfo struct {
        Name    string `json:"name"`
        Path    string `json:"path"`
        Size    int64  `json:"size"`
        Content string `json:"content"`
}

// writeIDEViewer generates the IDE viewer HTML page for a run
func writeIDEViewer(path, runID, runDir string) error <span class="cov6" title="6">{
        // Collect files list
        files := collectFiles(runDir)

        // Convert to JSON string
        filesJSON, err := json.Marshal(files)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov6" title="6">type IDEData struct {
                RunID     string
                FilesJSON template.JS
        }

        data := IDEData{
                RunID:     runID,
                FilesJSON: template.JS(filesJSON),
        }

        tmpl, err := template.New("ide").Parse(ideTemplate)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov6" title="6">f, err := os.Create(path)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>
        <span class="cov6" title="5">defer f.Close()

        return tmpl.Execute(f, data)</span>
}

// collectFiles gathers all files from the run directory
func collectFiles(runDir string) []FileInfo <span class="cov8" title="12">{
        var files []FileInfo

        // Add pipeline.log if exists
        pipelineLog := filepath.Join(runDir, "pipeline.log")
        if info, err := os.Stat(pipelineLog); err == nil </span><span class="cov6" title="5">{
                content, _ := os.ReadFile(pipelineLog)
                files = append(files, FileInfo{
                        Name:    "pipeline.log",
                        Path:    "pipeline.log",
                        Size:    info.Size(),
                        Content: stripansi.Strip(string(content)),
                })
        }</span>

        // Add config.toml if exists
        <span class="cov8" title="12">configFile := filepath.Join(runDir, "config.toml")
        if info, err := os.Stat(configFile); err == nil </span><span class="cov3" title="2">{
                content, _ := os.ReadFile(configFile)
                files = append(files, FileInfo{
                        Name:    "config.toml",
                        Path:    "config.toml",
                        Size:    info.Size(),
                        Content: stripansi.Strip(string(content)),
                })
        }</span>

        // Add run.json if exists
        <span class="cov8" title="12">runJSON := filepath.Join(runDir, "run.json")
        if info, err := os.Stat(runJSON); err == nil </span><span class="cov6" title="5">{
                content, _ := os.ReadFile(runJSON)
                files = append(files, FileInfo{
                        Name:    "run.json",
                        Path:    "run.json",
                        Size:    info.Size(),
                        Content: string(content), // JSON doesn't need ANSI stripping
                })
        }</span>

        // Add all log files
        <span class="cov8" title="12">logsDir := filepath.Join(runDir, "logs")
        if entries, err := os.ReadDir(logsDir); err == nil </span><span class="cov3" title="2">{
                for _, entry := range entries </span><span class="cov4" title="3">{
                        if !entry.IsDir() </span><span class="cov4" title="3">{
                                info, _ := entry.Info()
                                logPath := filepath.Join(logsDir, entry.Name())
                                content, _ := os.ReadFile(logPath)
                                files = append(files, FileInfo{
                                        Name:    entry.Name(),
                                        Path:    "logs/" + entry.Name(),
                                        Size:    info.Size(),
                                        Content: stripansi.Strip(string(content)),
                                })
                        }</span>
                }
        }

        // Add all artifact files (recursively walk subdirectories)
        <span class="cov8" title="12">artifactsDir := filepath.Join(runDir, "artifacts")
        filepath.Walk(artifactsDir, func(path string, info os.FileInfo, err error) error </span><span class="cov10" title="18">{
                if err != nil || info.IsDir() </span><span class="cov9" title="14">{
                        return nil
                }</span>
                // Get relative path from artifacts directory
                <span class="cov5" title="4">relPath, _ := filepath.Rel(artifactsDir, path)
                content, _ := os.ReadFile(path)
                files = append(files, FileInfo{
                        Name:    filepath.Base(path),
                        Path:    "artifacts/" + relPath,
                        Size:    info.Size(),
                        Content: stripansi.Strip(string(content)),
                })
                return nil</span>
        })

        <span class="cov8" title="12">return files</span>
}

const ideTemplate = `&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;DevPipe IDE - {{.RunID}}&lt;/title&gt;
    &lt;style&gt;
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            height: 100vh;
            overflow: hidden;
            background: #1e1e1e;
            color: #d4d4d4;
        }
        .header {
            background: #2d2d30;
            padding: 10px 20px;
            border-bottom: 1px solid #3e3e42;
            display: flex;
            align-items: center;
            gap: 20px;
        }
        .back-btn {
            background: #0e639c;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            text-decoration: none;
            font-size: 14px;
        }
        .back-btn:hover {
            background: #1177bb;
        }
        .title {
            font-size: 14px;
            color: #cccccc;
        }
        .container {
            display: flex;
            height: calc(100vh - 45px);
        }
        .sidebar {
            width: 250px;
            background: #252526;
            border-right: 1px solid #3e3e42;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }
        .sidebar-header {
            padding: 10px 15px;
            font-size: 11px;
            text-transform: uppercase;
            color: #888;
            font-weight: 600;
        }
        .search-box {
            padding: 10px 15px;
            border-bottom: 1px solid #3e3e42;
        }
        .search-input {
            width: 100%;
            background: #3c3c3c;
            border: 1px solid #3e3e42;
            color: #cccccc;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 13px;
        }
        .search-input:focus {
            outline: none;
            border-color: #007acc;
        }
        .search-results {
            padding: 10px 15px;
            font-size: 12px;
            color: #888;
        }
        .search-result-item {
            padding: 6px 10px;
            margin: 4px 0;
            background: #2d2d30;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
        }
        .search-result-item:hover {
            background: #3e3e42;
        }
        .search-result-file {
            color: #4ec9b0;
            font-weight: 500;
        }
        .search-result-line {
            color: #888;
            margin-left: 5px;
        }
        .search-result-preview {
            color: #d4d4d4;
            margin-top: 3px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .search-match {
            background: #515c6a;
            color: #f9f9f9;
        }
        .file-tree {
            list-style: none;
        }
        .file-item, .folder-item {
            padding: 4px 15px;
            cursor: pointer;
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 6px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .file-item:hover, .folder-item:hover {
            background: #2a2d2e;
        }
        .file-item.active {
            background: #094771;
        }
        .folder-item {
            font-weight: 500;
        }
        .folder-children {
            padding-left: 20px;
        }
        .folder-icon {
            font-size: 12px;
        }
        .file-icon {
            font-size: 12px;
        }
        .editor-container {
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        .editor-tabs {
            background: #2d2d30;
            border-bottom: 1px solid #3e3e42;
            padding: 0 10px;
            display: flex;
            align-items: center;
            min-height: 35px;
        }
        .editor-tab {
            padding: 8px 12px;
            font-size: 13px;
            color: #969696;
            background: transparent;
            border: none;
            cursor: pointer;
        }
        .editor-tab.active {
            color: #ffffff;
            background: #1e1e1e;
        }
        #editor {
            flex: 1;
        }
        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: #888;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class="header"&gt;
        &lt;a href="report.html" class="back-btn"&gt;â† Back to Dashboard&lt;/a&gt;
        &lt;span class="title"&gt;DevPipe IDE - Run {{.RunID}}&lt;/span&gt;
    &lt;/div&gt;
    
    &lt;div class="container"&gt;
        &lt;div class="sidebar"&gt;
            &lt;div class="search-box"&gt;
                &lt;input type="text" class="search-input" id="searchInput" placeholder="ðŸ” Search in files..."&gt;
            &lt;/div&gt;
            &lt;div id="searchResults" class="search-results" style="display: none;"&gt;&lt;/div&gt;
            &lt;div id="fileTreeContainer"&gt;
                &lt;div class="sidebar-header"&gt;Files&lt;/div&gt;
                &lt;ul class="file-tree" id="fileTree"&gt;
                    &lt;li class="loading"&gt;Loading files...&lt;/li&gt;
                &lt;/ul&gt;
            &lt;/div&gt;
        &lt;/div&gt;
        
        &lt;div class="editor-container"&gt;
            &lt;div class="editor-tabs" id="editorTabs"&gt;
                &lt;span style="color: #888; font-size: 13px;"&gt;No file open&lt;/span&gt;
            &lt;/div&gt;
            &lt;div id="editor"&gt;&lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;

    &lt;script src="https://cdn.jsdelivr.net/npm/monaco-editor@0.45.0/min/vs/loader.js"&gt;&lt;/script&gt;
    &lt;script&gt;
        let editor;
        let currentFile = null;
        let files = {{.FilesJSON}};  // Embedded file contents
        
        require.config({ paths: { vs: 'https://cdn.jsdelivr.net/npm/monaco-editor@0.45.0/min/vs' }});
        
        require(['vs/editor/editor.main'], function() {
            // Initialize Monaco Editor
            editor = monaco.editor.create(document.getElementById('editor'), {
                value: '',
                theme: 'vs-dark',
                readOnly: true,
                automaticLayout: true,
                minimap: { enabled: true },
                fontSize: 13,
                lineNumbers: 'on',
                wordWrap: 'off',
                scrollBeyondLastLine: false,
            });
            
            // Load embedded file tree
            renderFileTree(files);
            
            // Check URL for initial file to open
            const params = new URLSearchParams(window.location.search);
            const fileToOpen = params.get('file');
            if (fileToOpen) {
                setTimeout(() =&gt; openFile(fileToOpen), 500);
            }
            
            // Setup search
            setupSearch();
        });
        
        
        function renderFileTree(files) {
            const tree = document.getElementById('fileTree');
            tree.innerHTML = '';
            
            // Group files by directory
            const structure = {
                'root': [],
                'logs': [],
                'artifacts': []
            };
            
            files.forEach(file =&gt; {
                if (file.path.startsWith('logs/')) {
                    structure.logs.push(file);
                } else if (file.path.startsWith('artifacts/')) {
                    structure.artifacts.push(file);
                } else {
                    structure.root.push(file);
                }
            });
            
            // Render root files
            structure.root.forEach(file =&gt; {
                tree.appendChild(createFileItem(file));
            });
            
            // Render logs folder
            if (structure.logs.length &gt; 0) {
                const logsFolder = createFolderItem('ðŸ“ logs', structure.logs);
                tree.appendChild(logsFolder);
            }
            
            // Render artifacts folder
            if (structure.artifacts.length &gt; 0) {
                const artifactsFolder = createFolderItem('ðŸ“¦ artifacts', structure.artifacts);
                tree.appendChild(artifactsFolder);
            }
        }
        
        function createFileItem(file) {
            const li = document.createElement('li');
            li.className = 'file-item';
            li.innerHTML = getFileIcon(file.path) + ' ' + file.name;
            li.onclick = () =&gt; openFile(file.path);
            li.dataset.path = file.path;
            return li;
        }
        
        function createFolderItem(label, files) {
            const container = document.createElement('div');
            
            const folderHeader = document.createElement('li');
            folderHeader.className = 'folder-item';
            folderHeader.innerHTML = label;
            
            const children = document.createElement('ul');
            children.className = 'folder-children';
            children.style.listStyle = 'none';
            files.forEach(file =&gt; {
                children.appendChild(createFileItem(file));
            });
            
            folderHeader.onclick = (e) =&gt; {
                e.stopPropagation();
                const isHidden = children.style.display === 'none';
                children.style.display = isHidden ? 'block' : 'none';
                // Update folder icon
                folderHeader.innerHTML = (isHidden ? 'ðŸ“‚ ' : 'ðŸ“ ') + label.split(' ').slice(1).join(' ');
            };
            
            const wrapper = document.createElement('li');
            wrapper.style.listStyle = 'none';
            wrapper.appendChild(folderHeader);
            wrapper.appendChild(children);
            
            return wrapper;
        }
        
        function getFileIcon(path) {
            if (path.endsWith('.log')) return 'ðŸ“„';
            if (path.endsWith('.toml')) return 'âš™ï¸';
            if (path.endsWith('.xml')) return 'ðŸ“‹';
            if (path.endsWith('.json')) return 'ðŸ“Š';
            return 'ðŸ“„';
        }
        
        function getLanguage(path) {
            if (path.endsWith('.log')) return 'plaintext';
            if (path.endsWith('.toml')) return 'ini';
            if (path.endsWith('.xml')) return 'xml';
            if (path.endsWith('.json')) return 'json';
            if (path.endsWith('.sh')) return 'shell';
            if (path.endsWith('.go')) return 'go';
            return 'plaintext';
        }
        
        function openFile(path) {
            try {
                // Find file in embedded files array
                const file = files.find(f =&gt; f.path === path);
                if (!file) {
                    throw new Error('File not found: ' + path);
                }
                
                // Update editor
                const language = getLanguage(path);
                monaco.editor.setModelLanguage(editor.getModel(), language);
                editor.setValue(file.content);
                
                // Update active file in tree
                document.querySelectorAll('.file-item').forEach(item =&gt; {
                    item.classList.remove('active');
                    if (item.dataset.path === path) {
                        item.classList.add('active');
                    }
                });
                
                // Update tab
                const tabs = document.getElementById('editorTabs');
                tabs.innerHTML = '&lt;div class="editor-tab active"&gt;' + getFileIcon(path) + ' ' + path.split('/').pop() + '&lt;/div&gt;';
                
                currentFile = path;
            } catch (error) {
                console.error('Error opening file:', error);
                editor.setValue('âŒ Error loading file: ' + path + '\n\n' + error.message);
            }
        }
        
        function setupSearch() {
            const searchInput = document.getElementById('searchInput');
            const searchResults = document.getElementById('searchResults');
            const fileTreeContainer = document.getElementById('fileTreeContainer');
            
            let searchTimeout;
            searchInput.addEventListener('input', (e) =&gt; {
                clearTimeout(searchTimeout);
                const query = e.target.value.trim();
                
                if (query.length &lt; 2) {
                    searchResults.style.display = 'none';
                    fileTreeContainer.style.display = 'block';
                    return;
                }
                
                searchTimeout = setTimeout(() =&gt; {
                    performSearch(query);
                }, 300);
            });
        }
        
        function performSearch(query) {
            const searchResults = document.getElementById('searchResults');
            const fileTreeContainer = document.getElementById('fileTreeContainer');
            const results = [];
            
            // Search through all files
            files.forEach(file =&gt; {
                const lines = file.content.split('\n');
                lines.forEach((line, lineNum) =&gt; {
                    if (line.toLowerCase().includes(query.toLowerCase())) {
                        results.push({
                            file: file,
                            lineNum: lineNum + 1,
                            line: line.trim()
                        });
                    }
                });
            });
            
            // Display results
            if (results.length === 0) {
                searchResults.innerHTML = '&lt;div style="padding: 10px;"&gt;No results found&lt;/div&gt;';
            } else {
                const maxResults = 50;
                const displayResults = results.slice(0, maxResults);
                
                searchResults.innerHTML = 
                    '&lt;div style="padding: 10px; border-bottom: 1px solid #3e3e42;"&gt;' +
                    results.length + ' result' + (results.length !== 1 ? 's' : '') +
                    (results.length &gt; maxResults ? ' (showing first ' + maxResults + ')' : '') +
                    '&lt;/div&gt;';
                
                displayResults.forEach(result =&gt; {
                    const item = document.createElement('div');
                    item.className = 'search-result-item';
                    
                    const highlighted = result.line.replace(
                        new RegExp(query, 'gi'),
                        match =&gt; '&lt;span class="search-match"&gt;' + match + '&lt;/span&gt;'
                    );
                    
                    item.innerHTML = 
                        '&lt;div&gt;&lt;span class="search-result-file"&gt;' + result.file.name + '&lt;/span&gt;' +
                        '&lt;span class="search-result-line"&gt;:' + result.lineNum + '&lt;/span&gt;&lt;/div&gt;' +
                        '&lt;div class="search-result-preview"&gt;' + highlighted + '&lt;/div&gt;';
                    
                    item.onclick = () =&gt; {
                        openFile(result.file.path);
                        // Jump to line after a short delay
                        setTimeout(() =&gt; {
                            editor.revealLineInCenter(result.lineNum);
                            editor.setPosition({ lineNumber: result.lineNum, column: 1 });
                        }, 100);
                    };
                    
                    searchResults.appendChild(item);
                });
            }
            
            searchResults.style.display = 'block';
            fileTreeContainer.style.display = 'none';
        }
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
`
</pre>
		
		<pre class="file" id="file8" style="display: none">package dashboard

import (
        "github.com/drew/devpipe/internal/config"
        "github.com/drew/devpipe/internal/model"
)

// PhaseGroup represents a phase with its tasks
type PhaseGroup struct {
        ID        string
        Name      string
        Desc      string
        Tasks     []TaskWithDesc
        Status    string // "PASS" or "FAIL"
        TotalMs   int64
        TaskCount int
}

// TaskWithDesc is an alias for TaskResult (desc is now in TaskResult)
type TaskWithDesc = model.TaskResult

// ParsePhasesFromConfig groups tasks by their Phase field from execution
func ParsePhasesFromConfig(configPath string, tasks []model.TaskResult) ([]PhaseGroup, error) <span class="cov8" title="17">{
        // Load config to get phase descriptions and IDs
        _, _, phaseInfoMap, _, err := config.LoadConfig(configPath)
        phaseDescMap := make(map[string]string)
        phaseIDMap := make(map[string]string)
        if err == nil </span><span class="cov1" title="1">{
                // Build maps: phase name -&gt; description and phase name -&gt; ID
                for _, phaseInfo := range phaseInfoMap </span><span class="cov0" title="0">{
                        phaseDescMap[phaseInfo.Name] = phaseInfo.Desc
                        phaseIDMap[phaseInfo.Name] = phaseInfo.ID
                }</span>
        }

        // Group tasks by phase in execution order
        <span class="cov8" title="17">phaseMap := make(map[string]*PhaseGroup)
        phaseOrder := []string{}

        for _, task := range tasks </span><span class="cov10" title="26">{
                phaseName := task.Phase
                if phaseName == "" </span><span class="cov7" title="12">{
                        phaseName = "Tasks"
                }</span>

                // Create phase if it doesn't exist
                <span class="cov10" title="26">if _, exists := phaseMap[phaseName]; !exists </span><span class="cov9" title="19">{
                        phaseMap[phaseName] = &amp;PhaseGroup{
                                ID:     phaseIDMap[phaseName],
                                Name:   phaseName,
                                Desc:   phaseDescMap[phaseName],
                                Tasks:  []model.TaskResult{},
                                Status: "PASS",
                        }
                        phaseOrder = append(phaseOrder, phaseName)
                }</span>

                // Add task to phase
                <span class="cov10" title="26">phase := phaseMap[phaseName]
                phase.Tasks = append(phase.Tasks, task)
                phase.TotalMs += task.DurationMs
                phase.TaskCount++
                if task.Status == model.StatusFail </span><span class="cov2" title="2">{
                        phase.Status = "FAIL"
                }</span>
        }

        // Build final phase list in order
        <span class="cov8" title="17">var phases []PhaseGroup
        for _, phaseName := range phaseOrder </span><span class="cov9" title="19">{
                phases = append(phases, *phaseMap[phaseName])
        }</span>

        <span class="cov8" title="17">return phases, nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// Package git provides git repository integration for detecting changed files.
package git

import (
        "bytes"
        "fmt"
        "os"
        "os/exec"
        "strings"
)

// GitInfo holds git metadata for a run
type GitInfo struct {
        InGitRepo    bool     `json:"inGitRepo"`
        RepoRoot     string   `json:"repoRoot"`
        Mode         string   `json:"mode"` // "staged", "staged_unstaged", "ref"
        Ref          string   `json:"ref"`  // reference used for comparison
        ChangedFiles []string `json:"changedFiles"`
}

// DetectRepoRoot detects the git repository root
// Returns the root path and whether we're in a git repo
func DetectRepoRoot() (string, bool) <span class="cov5" title="15">{
        cmd := exec.Command("git", "rev-parse", "--show-toplevel")
        var buf bytes.Buffer
        cmd.Stdout = &amp;buf
        cmd.Stderr = &amp;bytes.Buffer{}

        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                // Not a git repo, use cwd
                cwd, err2 := os.Getwd()
                if err2 != nil </span><span class="cov0" title="0">{
                        return ".", false
                }</span>
                <span class="cov0" title="0">return cwd, false</span>
        }

        <span class="cov5" title="15">root := strings.TrimSpace(buf.String())
        if root == "" </span><span class="cov0" title="0">{
                cwd, err := os.Getwd()
                if err != nil </span><span class="cov0" title="0">{
                        return ".", false
                }</span>
                <span class="cov0" title="0">return cwd, false</span>
        }

        <span class="cov5" title="15">return root, true</span>
}

// DetectChangedFiles detects changed files based on the specified mode
func DetectChangedFiles(repoRoot string, inGitRepo bool, mode string, ref string, verbose bool) GitInfo <span class="cov6" title="27">{
        info := GitInfo{
                InGitRepo:    inGitRepo,
                RepoRoot:     repoRoot,
                Mode:         mode,
                Ref:          ref,
                ChangedFiles: []string{},
        }

        if !inGitRepo </span><span class="cov3" title="6">{
                return info
        }</span>

        <span class="cov5" title="21">var cmd *exec.Cmd

        switch mode </span>{
        case "staged":<span class="cov3" title="5">
                // Only staged files
                cmd = exec.Command("git", "diff", "--cached", "--name-only")</span>

        case "staged_unstaged":<span class="cov2" title="2">
                // Staged + unstaged files (compare against HEAD)
                cmd = exec.Command("git", "diff", "--name-only", "HEAD")</span>

        case "ref":<span class="cov4" title="9">
                // Compare against specific ref
                cmd = exec.Command("git", "diff", "--name-only", ref)</span>

        default:<span class="cov3" title="5">
                // Default to staged_unstaged
                cmd = exec.Command("git", "diff", "--name-only", "HEAD")
                info.Mode = "staged_unstaged"</span>
        }

        <span class="cov5" title="21">cmd.Dir = repoRoot
        var out bytes.Buffer
        cmd.Stdout = &amp;out
        cmd.Stderr = &amp;bytes.Buffer{}

        if err := cmd.Run(); err != nil </span><span class="cov3" title="4">{
                if verbose </span><span class="cov1" title="1">{
                        fmt.Fprintf(os.Stderr, "WARNING: git diff failed: %v\n", err)
                }</span>
                <span class="cov3" title="4">return info</span>
        }

        <span class="cov5" title="17">output := strings.TrimSpace(out.String())
        if output == "" </span><span class="cov2" title="3">{
                info.ChangedFiles = []string{}
                return info
        }</span>

        <span class="cov5" title="14">lines := strings.Split(output, "\n")
        var files []string
        for _, l := range lines </span><span class="cov10" title="362">{
                if strings.TrimSpace(l) != "" </span><span class="cov10" title="362">{
                        files = append(files, l)
                }</span>
        }

        <span class="cov5" title="14">info.ChangedFiles = files
        return info</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// Package metrics provides parsing and aggregation of test and build metrics.
package metrics

import (
        "fmt"

        "github.com/drew/devpipe/internal/model"
        "github.com/joshdk/go-junit"
)

// ParseJUnitXML parses a JUnit XML file and returns metrics
// Uses github.com/joshdk/go-junit for robust parsing of all JUnit XML variants
// Supports: single &lt;testsuite&gt;, &lt;testsuites&gt;, multiple root elements, etc.
func ParseJUnitXML(path string) (*model.TaskMetrics, error) <span class="cov8" title="9">{
        // Ingest JUnit XML file using battle-tested library
        suites, err := junit.IngestFile(path)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        // Validate that we got at least one test suite
        // If the file is plain text or invalid XML that the parser silently accepts,
        // we'll get an empty suite list - this should be an error
        <span class="cov7" title="8">if len(suites) == 0 </span><span class="cov3" title="2">{
                return nil, fmt.Errorf("no test suites found - file may not be valid JUnit XML")
        }</span>

        // Aggregate metrics across all suites
        <span class="cov6" title="6">var totalTests, totalFailures, totalErrors, totalSkipped int
        var totalTime float64
        var testCases []map[string]interface{}

        for _, suite := range suites </span><span class="cov7" title="7">{
                totalTests += len(suite.Tests)
                for _, test := range suite.Tests </span><span class="cov10" title="16">{
                        // Collect test case details
                        testCase := map[string]interface{}{
                                "name":      test.Name,
                                "classname": test.Classname,
                                "time":      test.Duration.Seconds(),
                                "status":    string(test.Status),
                        }

                        // Add error/failure message if present
                        if test.Error != nil </span><span class="cov4" title="3">{
                                testCase["message"] = test.Error.Error()
                        }</span>

                        <span class="cov10" title="16">testCases = append(testCases, testCase)

                        switch test.Status </span>{
                        case junit.StatusFailed:<span class="cov3" title="2">
                                totalFailures++</span>
                        case junit.StatusError:<span class="cov1" title="1">
                                totalErrors++</span>
                        case junit.StatusSkipped:<span class="cov1" title="1">
                                totalSkipped++</span>
                        }
                        <span class="cov10" title="16">totalTime += test.Duration.Seconds()</span>
                }
        }

        <span class="cov6" title="6">return &amp;model.TaskMetrics{
                Kind:          "test",
                SummaryFormat: "junit",
                Data: map[string]interface{}{
                        "tests":     totalTests,
                        "failures":  totalFailures,
                        "errors":    totalErrors,
                        "skipped":   totalSkipped,
                        "time":      totalTime,
                        "testcases": testCases,
                },
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package metrics

import (
        "fmt"

        "github.com/drew/devpipe/internal/model"
        "github.com/drew/devpipe/internal/sarif"
)

// ParseSARIF parses a SARIF file and returns metrics
// SARIF (Static Analysis Results Interchange Format) is used by security scanners like CodeQL, gosec, etc.
func ParseSARIF(path string) (*model.TaskMetrics, error) <span class="cov10" title="11">{
        // Parse SARIF file
        doc, err := sarif.Parse(path)
        if err != nil </span><span class="cov3" title="2">{
                return nil, fmt.Errorf("failed to parse SARIF: %w", err)
        }</span>

        // Extract findings
        <span class="cov9" title="9">findings := doc.GetFindings()

        // Count by severity level
        var errors, warnings, notes int
        for _, f := range findings </span><span class="cov10" title="11">{
                switch f.Level </span>{
                case "error":<span class="cov3" title="2">
                        errors++</span>
                case "warning":<span class="cov8" title="7">
                        warnings++</span>
                case "note":<span class="cov1" title="1">
                        notes++</span>
                default:<span class="cov1" title="1">
                        warnings++</span> // Default to warning
                }
        }

        // Group findings by rule ID for summary
        <span class="cov9" title="9">ruleCount := make(map[string]int)
        ruleSeverity := make(map[string]string)
        for _, f := range findings </span><span class="cov10" title="11">{
                ruleCount[f.RuleID]++
                if _, exists := ruleSeverity[f.RuleID]; !exists </span><span class="cov9" title="10">{
                        ruleSeverity[f.RuleID] = f.SecuritySeverity
                }</span>
        }

        // Convert findings to serializable format
        <span class="cov9" title="9">var findingsData []map[string]interface{}
        for _, f := range findings </span><span class="cov10" title="11">{
                finding := map[string]interface{}{
                        "ruleId":   f.RuleID,
                        "ruleName": f.RuleName,
                        "file":     f.File,
                        "line":     f.Line,
                        "column":   f.Column,
                        "message":  f.Message,
                        "level":    f.Level,
                }

                // Add optional fields if present
                if f.ShortDesc != "" </span><span class="cov1" title="1">{
                        finding["shortDesc"] = f.ShortDesc
                }</span>
                <span class="cov10" title="11">if f.SecuritySeverity != "" </span><span class="cov6" title="4">{
                        finding["severity"] = f.SecuritySeverity
                }</span>
                <span class="cov10" title="11">if len(f.Tags) &gt; 0 </span><span class="cov1" title="1">{
                        finding["tags"] = f.Tags
                }</span>
                <span class="cov10" title="11">if f.Precision != "" </span><span class="cov1" title="1">{
                        finding["precision"] = f.Precision
                }</span>
                <span class="cov10" title="11">if f.SourceLocation != "" </span><span class="cov1" title="1">{
                        finding["source"] = f.SourceLocation
                }</span>
                <span class="cov10" title="11">if len(f.DataFlowSteps) &gt; 0 </span><span class="cov1" title="1">{
                        var steps []map[string]interface{}
                        for _, step := range f.DataFlowSteps </span><span class="cov3" title="2">{
                                steps = append(steps, map[string]interface{}{
                                        "file":    step.File,
                                        "line":    step.Line,
                                        "column":  step.Column,
                                        "message": step.Message,
                                })
                        }</span>
                        <span class="cov1" title="1">finding["dataFlow"] = steps</span>
                }

                <span class="cov10" title="11">findingsData = append(findingsData, finding)</span>
        }

        // Build rule summary
        <span class="cov9" title="9">var rules []map[string]interface{}
        for ruleID, count := range ruleCount </span><span class="cov9" title="10">{
                rule := map[string]interface{}{
                        "id":    ruleID,
                        "count": count,
                }
                if severity, ok := ruleSeverity[ruleID]; ok &amp;&amp; severity != "" </span><span class="cov5" title="3">{
                        rule["severity"] = severity
                }</span>
                <span class="cov9" title="10">rules = append(rules, rule)</span>
        }

        <span class="cov9" title="9">return &amp;model.TaskMetrics{
                Kind:          "security",
                SummaryFormat: "sarif",
                Data: map[string]interface{}{
                        "total":    len(findings),
                        "errors":   errors,
                        "warnings": warnings,
                        "notes":    notes,
                        "findings": findingsData,
                        "rules":    rules,
                },
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package sarif

import (
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
        "sort"
        "strings"
)

// SARIF represents the top-level SARIF document structure
type SARIF struct {
        Version string `json:"version"`
        Runs    []Run  `json:"runs"`
}

// Run represents a single analysis run
type Run struct {
        Tool    Tool     `json:"tool"`
        Results []Result `json:"results"`
}

// Tool represents the analysis tool information
type Tool struct {
        Driver Driver `json:"driver"`
}

// Driver represents the tool driver information
type Driver struct {
        Name           string `json:"name"`
        Version        string `json:"version"`
        InformationURI string `json:"informationUri"`
        Rules          []Rule `json:"rules"`
}

// Rule represents a rule definition
type Rule struct {
        ID               string          `json:"id"`
        Name             string          `json:"name"`
        ShortDescription MessageString   `json:"shortDescription"`
        FullDescription  MessageString   `json:"fullDescription"`
        Help             MessageString   `json:"help"`
        Properties       *RuleProperties `json:"properties,omitempty"`
}

// RuleProperties contains additional rule metadata
type RuleProperties struct {
        Tags             []string `json:"tags,omitempty"`
        Precision        string   `json:"precision,omitempty"`
        SecuritySeverity string   `json:"security-severity,omitempty"`
}

// Result represents a single finding
type Result struct {
        RuleID           string            `json:"ruleId"`
        RuleIndex        int               `json:"ruleIndex"`
        Message          Message           `json:"message"`
        Locations        []Location        `json:"locations"`
        Level            string            `json:"level,omitempty"`
        CodeFlows        []CodeFlow        `json:"codeFlows,omitempty"`
        RelatedLocations []RelatedLocation `json:"relatedLocations,omitempty"`
}

// Message represents a result message
type Message struct {
        Text string `json:"text"`
}

// MessageString represents a message with text
type MessageString struct {
        Text string `json:"text"`
}

// Location represents a location in source code
type Location struct {
        PhysicalLocation PhysicalLocation `json:"physicalLocation"`
        Message          *Message         `json:"message,omitempty"`
}

// RelatedLocation represents a related location
type RelatedLocation struct {
        ID               int              `json:"id,omitempty"`
        PhysicalLocation PhysicalLocation `json:"physicalLocation"`
        Message          Message          `json:"message"`
}

// CodeFlow represents a data flow path
type CodeFlow struct {
        ThreadFlows []ThreadFlow `json:"threadFlows"`
}

// ThreadFlow represents a thread of execution
type ThreadFlow struct {
        Locations []ThreadFlowLocation `json:"locations"`
}

// ThreadFlowLocation represents a location in a code flow
type ThreadFlowLocation struct {
        Location Location `json:"location"`
}

// PhysicalLocation represents a physical location in a file
type PhysicalLocation struct {
        ArtifactLocation ArtifactLocation `json:"artifactLocation"`
        Region           Region           `json:"region"`
}

// ArtifactLocation represents a file location
type ArtifactLocation struct {
        URI   string `json:"uri"`
        Index int    `json:"index,omitempty"`
}

// Region represents a region in a file
type Region struct {
        StartLine   int `json:"startLine"`
        StartColumn int `json:"startColumn,omitempty"`
        EndLine     int `json:"endLine,omitempty"`
        EndColumn   int `json:"endColumn,omitempty"`
}

// Finding represents a simplified view of a SARIF result
type Finding struct {
        RuleID           string
        RuleName         string
        File             string
        Line             int
        Column           int
        EndLine          int
        EndColumn        int
        Message          string
        Level            string
        ShortDesc        string
        FullDesc         string
        HelpText         string
        Tags             []string
        Precision        string
        SecuritySeverity string
        DataFlowSteps    []DataFlowStep
        SourceLocation   string
}

// DataFlowStep represents a step in the data flow
type DataFlowStep struct {
        File    string
        Line    int
        Column  int
        Message string
}

// Parse reads and parses a SARIF file
func Parse(filename string) (*SARIF, error) <span class="cov10" title="12">{
        data, err := os.ReadFile(filename)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to read file: %w", err)
        }</span>

        <span class="cov9" title="11">var sarif SARIF
        if err := json.Unmarshal(data, &amp;sarif); err != nil </span><span class="cov3" title="2">{
                return nil, fmt.Errorf("failed to parse SARIF: %w", err)
        }</span>

        <span class="cov8" title="9">return &amp;sarif, nil</span>
}

// GetFindings extracts all findings from a SARIF document
func (s *SARIF) GetFindings() []Finding <span class="cov8" title="7">{
        var findings []Finding

        for _, run := range s.Runs </span><span class="cov8" title="8">{
                // Build a map of rule IDs to rule metadata
                ruleMap := make(map[string]*Rule)
                for i := range run.Tool.Driver.Rules </span><span class="cov6" title="4">{
                        rule := &amp;run.Tool.Driver.Rules[i]
                        ruleMap[rule.ID] = rule
                }</span>

                <span class="cov8" title="8">for _, result := range run.Results </span><span class="cov10" title="12">{
                        if len(result.Locations) == 0 </span><span class="cov1" title="1">{
                                continue</span>
                        }

                        <span class="cov9" title="11">loc := result.Locations[0].PhysicalLocation

                        // Get rule metadata
                        rule := ruleMap[result.RuleID]
                        ruleName := result.RuleID
                        var shortDesc, fullDesc, helpText string
                        var tags []string
                        var precision, securitySeverity string

                        if rule != nil </span><span class="cov6" title="4">{
                                if rule.Name != "" </span><span class="cov6" title="4">{
                                        ruleName = rule.Name
                                }</span>
                                <span class="cov6" title="4">shortDesc = rule.ShortDescription.Text
                                fullDesc = rule.FullDescription.Text
                                helpText = rule.Help.Text

                                if rule.Properties != nil </span><span class="cov4" title="3">{
                                        tags = rule.Properties.Tags
                                        precision = rule.Properties.Precision
                                        securitySeverity = rule.Properties.SecuritySeverity
                                }</span>
                        }

                        <span class="cov9" title="11">level := result.Level
                        if level == "" </span><span class="cov6" title="4">{
                                level = "warning"
                        }</span>

                        // Extract data flow steps
                        <span class="cov9" title="11">var dataFlowSteps []DataFlowStep
                        if len(result.CodeFlows) &gt; 0 &amp;&amp; len(result.CodeFlows[0].ThreadFlows) &gt; 0 </span><span class="cov1" title="1">{
                                for _, tfLoc := range result.CodeFlows[0].ThreadFlows[0].Locations </span><span class="cov3" title="2">{
                                        msg := ""
                                        if tfLoc.Location.Message != nil </span><span class="cov3" title="2">{
                                                msg = tfLoc.Location.Message.Text
                                        }</span>
                                        <span class="cov3" title="2">dataFlowSteps = append(dataFlowSteps, DataFlowStep{
                                                File:    tfLoc.Location.PhysicalLocation.ArtifactLocation.URI,
                                                Line:    tfLoc.Location.PhysicalLocation.Region.StartLine,
                                                Column:  tfLoc.Location.PhysicalLocation.Region.StartColumn,
                                                Message: msg,
                                        })</span>
                                }
                        }

                        // Extract source location from related locations
                        <span class="cov9" title="11">var sourceLocation string
                        if len(result.RelatedLocations) &gt; 0 </span><span class="cov1" title="1">{
                                relLoc := result.RelatedLocations[0]
                                sourceLocation = fmt.Sprintf("%s:%d:%d - %s",
                                        relLoc.PhysicalLocation.ArtifactLocation.URI,
                                        relLoc.PhysicalLocation.Region.StartLine,
                                        relLoc.PhysicalLocation.Region.StartColumn,
                                        relLoc.Message.Text)
                        }</span>

                        <span class="cov9" title="11">findings = append(findings, Finding{
                                RuleID:           result.RuleID,
                                RuleName:         ruleName,
                                File:             loc.ArtifactLocation.URI,
                                Line:             loc.Region.StartLine,
                                Column:           loc.Region.StartColumn,
                                EndLine:          loc.Region.EndLine,
                                EndColumn:        loc.Region.EndColumn,
                                Message:          result.Message.Text,
                                Level:            level,
                                ShortDesc:        shortDesc,
                                FullDesc:         fullDesc,
                                HelpText:         helpText,
                                Tags:             tags,
                                Precision:        precision,
                                SecuritySeverity: securitySeverity,
                                DataFlowSteps:    dataFlowSteps,
                                SourceLocation:   sourceLocation,
                        })</span>
                }
        }

        // Sort findings by file, then line
        <span class="cov8" title="7">sort.Slice(findings, func(i, j int) bool </span><span class="cov7" title="6">{
                if findings[i].File != findings[j].File </span><span class="cov6" title="5">{
                        return findings[i].File &lt; findings[j].File
                }</span>
                <span class="cov1" title="1">return findings[i].Line &lt; findings[j].Line</span>
        })

        <span class="cov8" title="7">return findings</span>
}

// PrintFindings prints findings in a human-readable format
func PrintFindings(findings []Finding, verbose bool) <span class="cov3" title="2">{
        if len(findings) == 0 </span><span class="cov0" title="0">{
                fmt.Println("âœ… No security issues found!")
                return
        }</span>

        <span class="cov3" title="2">fmt.Printf("âš ï¸  Found %d security issue(s):\n\n", len(findings))

        for i, f := range findings </span><span class="cov4" title="3">{
                if i &gt; 0 </span><span class="cov1" title="1">{
                        fmt.Println()
                }</span>

                // Color code by level
                <span class="cov4" title="3">levelIcon := "âš ï¸ "
                switch strings.ToLower(f.Level) </span>{
                case "error":<span class="cov3" title="2">
                        levelIcon = "âŒ"</span>
                case "warning":<span class="cov1" title="1">
                        levelIcon = "âš ï¸ "</span>
                case "note":<span class="cov0" title="0">
                        levelIcon = "â„¹ï¸ "</span>
                }

                // Basic info (always shown)
                <span class="cov4" title="3">fmt.Printf("%s Rule:    %s\n", levelIcon, f.RuleID)

                // Location with column info if available
                if f.Column &gt; 0 </span><span class="cov1" title="1">{
                        if f.EndLine &gt; 0 &amp;&amp; f.EndColumn &gt; 0 </span><span class="cov0" title="0">{
                                fmt.Printf("   File:    %s:%d:%d-%d:%d\n", f.File, f.Line, f.Column, f.EndLine, f.EndColumn)
                        }</span> else<span class="cov1" title="1"> {
                                fmt.Printf("   File:    %s:%d:%d\n", f.File, f.Line, f.Column)
                        }</span>
                } else<span class="cov3" title="2"> {
                        fmt.Printf("   File:    %s:%d\n", f.File, f.Line)
                }</span>

                <span class="cov4" title="3">fmt.Printf("   Message: %s\n", f.Message)

                // Verbose mode - show additional details
                if verbose </span><span class="cov1" title="1">{
                        if f.RuleName != "" &amp;&amp; f.RuleName != f.RuleID </span><span class="cov1" title="1">{
                                fmt.Printf("   Name:    %s\n", f.RuleName)
                        }</span>

                        <span class="cov1" title="1">if f.Level != "" </span><span class="cov1" title="1">{
                                fmt.Printf("   Level:   %s\n", f.Level)
                        }</span>

                        <span class="cov1" title="1">if f.ShortDesc != "" </span><span class="cov1" title="1">{
                                fmt.Printf("   Info:    %s\n", f.ShortDesc)
                        }</span>

                        <span class="cov1" title="1">if f.Precision != "" </span><span class="cov0" title="0">{
                                fmt.Printf("   Precision: %s\n", f.Precision)
                        }</span>

                        <span class="cov1" title="1">if f.SecuritySeverity != "" </span><span class="cov1" title="1">{
                                fmt.Printf("   Severity:  %s\n", f.SecuritySeverity)
                        }</span>

                        <span class="cov1" title="1">if len(f.Tags) &gt; 0 </span><span class="cov1" title="1">{
                                fmt.Printf("   Tags:    %s\n", strings.Join(f.Tags, ", "))
                        }</span>

                        <span class="cov1" title="1">if f.FullDesc != "" &amp;&amp; f.FullDesc != f.ShortDesc </span><span class="cov1" title="1">{
                                fmt.Printf("   Details: %s\n", f.FullDesc)
                        }</span>

                        <span class="cov1" title="1">if f.HelpText != "" </span><span class="cov1" title="1">{
                                // Truncate help text if too long
                                help := f.HelpText
                                if len(help) &gt; 200 </span><span class="cov0" title="0">{
                                        help = help[:197] + "..."
                                }</span>
                                <span class="cov1" title="1">fmt.Printf("   Help:    %s\n", help)</span>
                        }

                        // Show source location (where tainted data originates)
                        <span class="cov1" title="1">if f.SourceLocation != "" </span><span class="cov0" title="0">{
                                fmt.Printf("   Source:  %s\n", f.SourceLocation)
                        }</span>

                        // Show data flow path
                        <span class="cov1" title="1">if len(f.DataFlowSteps) &gt; 0 </span><span class="cov0" title="0">{
                                fmt.Printf("   Data Flow Path (%d steps):\n", len(f.DataFlowSteps))
                                for i, step := range f.DataFlowSteps </span><span class="cov0" title="0">{
                                        stepNum := i + 1
                                        if step.Column &gt; 0 </span><span class="cov0" title="0">{
                                                fmt.Printf("     %d. %s:%d:%d", stepNum, step.File, step.Line, step.Column)
                                        }</span> else<span class="cov0" title="0"> {
                                                fmt.Printf("     %d. %s:%d", stepNum, step.File, step.Line)
                                        }</span>
                                        <span class="cov0" title="0">if step.Message != "" </span><span class="cov0" title="0">{
                                                fmt.Printf(" - %s", step.Message)
                                        }</span>
                                        <span class="cov0" title="0">fmt.Println()</span>
                                }
                        }
                }
        }
}

// PrintSummary prints a summary of findings grouped by rule
func PrintSummary(findings []Finding) <span class="cov1" title="1">{
        if len(findings) == 0 </span><span class="cov0" title="0">{
                fmt.Println("âœ… No security issues found!")
                return
        }</span>

        // Group by rule ID
        <span class="cov1" title="1">ruleCount := make(map[string]int)
        for _, f := range findings </span><span class="cov6" title="4">{
                ruleCount[f.RuleID]++
        }</span>

        // Sort rules by count (descending)
        <span class="cov1" title="1">type ruleStats struct {
                id    string
                count int
        }
        var stats []ruleStats
        for id, count := range ruleCount </span><span class="cov4" title="3">{
                stats = append(stats, ruleStats{id, count})
        }</span>
        <span class="cov1" title="1">sort.Slice(stats, func(i, j int) bool </span><span class="cov3" title="2">{
                if stats[i].count != stats[j].count </span><span class="cov1" title="1">{
                        return stats[i].count &gt; stats[j].count
                }</span>
                <span class="cov1" title="1">return stats[i].id &lt; stats[j].id</span>
        })

        <span class="cov1" title="1">fmt.Printf("ðŸ“Š Security Issues Summary (%d total):\n\n", len(findings))
        for _, s := range stats </span><span class="cov4" title="3">{
                fmt.Printf("  %3d  %s\n", s.count, s.id)
        }</span>
}

// FindSARIFFiles finds all SARIF files in a directory
func FindSARIFFiles(dir string) ([]string, error) <span class="cov4" title="3">{
        var files []string

        err := filepath.Walk(dir, func(path string, info os.FileInfo, err error) error </span><span class="cov8" title="7">{
                if err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>
                <span class="cov7" title="6">if !info.IsDir() &amp;&amp; strings.HasSuffix(strings.ToLower(path), ".sarif") </span><span class="cov3" title="2">{
                        files = append(files, path)
                }</span>
                <span class="cov7" title="6">return nil</span>
        })

        <span class="cov4" title="3">return files, err</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">// Package ui provides terminal UI components for rendering pipeline progress.
package ui

import (
        "fmt"
        "strings"
        "sync"
        "time"
)

// AnimatedTaskTracker tracks live progress of tasks
type AnimatedTaskTracker struct {
        tasks        []TaskProgress
        mu           sync.RWMutex
        done         chan struct{}
        renderer     *Renderer
        headerLines  int
        firstRender  bool
        logLines     []string
        maxLogLines  int
        verboseLines []string // Verbose output lines
        maxVerbose   int      // Max verbose lines to show (5)
        termHeight   int
        animLines    int
        refreshMs    int
        groupBy      string // "type" or "phase"
        maxIDWidth   int    // Calculated once at init for consistent alignment
}

// NewAnimatedTaskTracker creates a new animated task tracker
func NewAnimatedTaskTracker(renderer *Renderer, tasks []TaskProgress, headerLines int, refreshMs int, groupBy string) *AnimatedTaskTracker <span class="cov8" title="33">{
        termHeight := GetTerminalHeight()

        // Calculate animation lines more accurately
        var animLines int
        if renderer.mode == UIModeFull </span><span class="cov0" title="0">{
                // Full mode: overall progress (2 lines) + grouped tasks
                animLines = 2 // Overall progress + blank

                // Count lines per group
                groups := make(map[string]int)
                for _, task := range tasks </span><span class="cov0" title="0">{
                        groups[task.Type]++
                }</span>

                // Each group: header (1) + tasks (N) + footer (1) + blank (1)
                <span class="cov0" title="0">for _, count := range groups </span><span class="cov0" title="0">{
                        animLines += 3 + count // header + stages + footer + blank
                }</span>
        } else<span class="cov8" title="33"> {
                // Basic mode: progress bar + blank + tasks + blank
                animLines = 2 + len(tasks) + 1
        }</span>

        // Reserve space for logs (rest of terminal minus header, animation, log header, and summary)
        // animLines + 1 (for "â”€â”€â”€ Output â”€â”€â”€") + maxLogLines + 6 (summary)
        <span class="cov8" title="33">maxLogLines := termHeight - headerLines - animLines - 1 - 6 // 1 for log header, 6 for summary
        if maxLogLines &lt; 3 </span><span class="cov0" title="0">{
                maxLogLines = 3
        }</span>

        // Validate refreshMs (20ms to 2000ms allowed)
        <span class="cov8" title="33">if refreshMs &lt; 20 || refreshMs &gt; 2000 </span><span class="cov2" title="2">{
                refreshMs = 500 // Default to 500ms if invalid
        }</span>

        // Validate groupBy
        <span class="cov8" title="33">if groupBy != "type" &amp;&amp; groupBy != "phase" </span><span class="cov1" title="1">{
                groupBy = "type" // Default to type if invalid
        }</span>

        // Calculate max task ID width once for consistent alignment
        // Cap at 45 to prevent very long task names from breaking layout
        <span class="cov8" title="33">maxIDWidth := 12
        for _, task := range tasks </span><span class="cov9" title="67">{
                taskLen := len(task.ID)
                if taskLen &gt; 45 </span><span class="cov1" title="1">{
                        taskLen = 45
                }</span>
                <span class="cov9" title="67">if taskLen &gt; maxIDWidth </span><span class="cov1" title="1">{
                        maxIDWidth = taskLen
                }</span>
        }

        <span class="cov8" title="33">return &amp;AnimatedTaskTracker{
                tasks:        tasks,
                done:         make(chan struct{}),
                renderer:     renderer,
                headerLines:  headerLines,
                firstRender:  true,
                logLines:     []string{},
                maxLogLines:  maxLogLines,
                verboseLines: []string{},
                maxVerbose:   5, // Fixed 5 lines for verbose output
                termHeight:   termHeight,
                animLines:    animLines,
                refreshMs:    refreshMs,
                groupBy:      groupBy,
                maxIDWidth:   maxIDWidth,
        }</span>
}

// Start begins the animation loop
func (a *AnimatedTaskTracker) Start() error <span class="cov2" title="2">{
        // Test if terminal supports animation
        if err := a.testRender(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("animation not supported: %w", err)
        }</span>

        // Start animation loop (it will do the initial render)
        <span class="cov2" title="2">go a.animationLoop()

        // Give the animation loop a moment to start and do initial render
        time.Sleep(50 * time.Millisecond)

        return nil</span>
}

// Stop stops the animation loop
func (a *AnimatedTaskTracker) Stop() <span class="cov2" title="2">{
        // Always restore cursor, even if something goes wrong
        defer fmt.Print("\033[?25h") // Show cursor again

        close(a.done)

        fmt.Println() // Add newline after animation
}</span>

// testRender tests if terminal supports ANSI escape codes
func (a *AnimatedTaskTracker) testRender() error <span class="cov4" title="7">{
        defer func() </span><span class="cov4" title="7">{
                if r := recover(); r != nil </span>{<span class="cov0" title="0">
                        // Rendering panicked
                }</span>
        }()

        // Try basic ANSI sequences
        <span class="cov4" title="7">fmt.Print("\033[s") // Save cursor position
        fmt.Print("\033[u") // Restore cursor position

        return nil</span>
}

// UpdateTask updates a task's progress
func (a *AnimatedTaskTracker) UpdateTask(id string, status string, elapsed float64) <span class="cov3" title="3">{
        a.mu.Lock()
        defer a.mu.Unlock()

        for i := range a.tasks </span><span class="cov4" title="6">{
                if a.tasks[i].ID == id </span><span class="cov3" title="3">{
                        a.tasks[i].Status = status
                        a.tasks[i].ElapsedSeconds = elapsed
                        break</span>
                }
        }
}

// AddLogLine adds a log line to the display
func (a *AnimatedTaskTracker) AddLogLine(line string) <span class="cov7" title="27">{
        a.mu.Lock()
        defer a.mu.Unlock()

        a.logLines = append(a.logLines, line)

        // Keep only the last maxLogLines
        if len(a.logLines) &gt; a.maxLogLines </span><span class="cov5" title="10">{
                a.logLines = a.logLines[len(a.logLines)-a.maxLogLines:]
        }</span>
}

// AddVerboseLine adds a verbose log line to the display
func (a *AnimatedTaskTracker) AddVerboseLine(line string) <span class="cov6" title="12">{
        a.mu.Lock()
        defer a.mu.Unlock()

        a.verboseLines = append(a.verboseLines, line)

        // Keep only the last maxVerbose lines (5)
        if len(a.verboseLines) &gt; a.maxVerbose </span><span class="cov4" title="5">{
                a.verboseLines = a.verboseLines[len(a.verboseLines)-a.maxVerbose:]
        }</span>
}

// animationLoop continuously updates the display
func (a *AnimatedTaskTracker) animationLoop() <span class="cov2" title="2">{
        // Do initial render immediately
        a.render()

        // Use configured refresh rate
        ticker := time.NewTicker(time.Duration(a.refreshMs) * time.Millisecond)
        defer ticker.Stop()

        // Do another render after a short delay to catch fast tasks
        time.Sleep(100 * time.Millisecond)
        a.render()

        for </span><span class="cov2" title="2">{
                select </span>{
                case &lt;-a.done:<span class="cov1" title="1">
                        return</span>
                case &lt;-ticker.C:<span class="cov1" title="1">
                        a.render()</span>
                }
        }
}

// render draws the current state
func (a *AnimatedTaskTracker) render() <span class="cov5" title="9">{
        a.mu.RLock()
        defer a.mu.RUnlock()

        if a.firstRender </span><span class="cov4" title="7">{
                // First render: hide cursor and print normally
                fmt.Print("\033[?25l") // Hide cursor
                a.firstRender = false
                if a.renderer.mode == UIModeFull </span><span class="cov0" title="0">{
                        a.renderFullMode()
                }</span> else<span class="cov4" title="7"> {
                        a.renderBasicMode()
                }</span>
        } else<span class="cov2" title="2"> {
                // Subsequent renders: move to top, clear animation area, redraw

                // Move cursor to start of animation area and clear all lines
                linesToMove := a.calculateLines()

                // Move cursor up to start of animation area
                if linesToMove &gt; 0 </span><span class="cov2" title="2">{
                        fmt.Printf("\033[%dA", linesToMove)
                }</span>

                // Move to beginning of line and clear everything below
                <span class="cov2" title="2">fmt.Print("\r")     // Move to start of line
                fmt.Print("\033[J") // Clear from cursor to end of screen

                // Render animation
                if a.renderer.mode == UIModeFull </span><span class="cov0" title="0">{
                        a.renderFullMode()
                }</span> else<span class="cov2" title="2"> {
                        a.renderBasicMode()
                }</span>
        }
}

// calculateLines calculates how many lines we need to clear
// This should return a FIXED number based on maxLogLines, not actual log count
func (a *AnimatedTaskTracker) calculateLines() int <span class="cov4" title="7">{
        if a.renderer.mode == UIModeFull </span><span class="cov0" title="0">{
                // Full mode: overall progress + grouped stages + log box (fixed size)
                lines := 2 // Overall progress bar + blank line

                // Group tasks using the same logic as rendering
                groups := make(map[string][]TaskProgress)
                for _, task := range a.tasks </span><span class="cov0" title="0">{
                        var groupKey string
                        if a.groupBy == "phase" </span><span class="cov0" title="0">{
                                // Use the phase name if available, otherwise fall back to "Phase N"
                                if task.PhaseName != "" </span><span class="cov0" title="0">{
                                        groupKey = task.PhaseName
                                }</span> else<span class="cov0" title="0"> {
                                        groupKey = fmt.Sprintf("Phase %d", task.Phase)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                groupKey = task.Type
                        }</span>
                        <span class="cov0" title="0">groups[groupKey] = append(groups[groupKey], task)</span>
                }

                <span class="cov0" title="0">for _, taskList := range groups </span><span class="cov0" title="0">{
                        lines += 2 + len(taskList) + 1 // Header + tasks + footer + blank
                }</span>

                // Add FIXED log box lines (always reserve maxLogLines)
                <span class="cov0" title="0">lines += 1 + a.maxLogLines // "â”€â”€â”€ Output â”€â”€â”€" + max log lines

                return lines</span>
        } else<span class="cov4" title="7"> {
                // Basic mode: progress bar + blank + tasks + blank + log header + FIXED log lines
                return 2 + len(a.tasks) + 1 + 1 + a.maxLogLines
        }</span>
}

// renderBasicMode renders the basic animated mode
func (a *AnimatedTaskTracker) renderBasicMode() <span class="cov5" title="10">{
        // Calculate overall progress
        overallProgress := CalculateOverallProgress(a.tasks)

        // Render progress bar
        barWidth := 40
        if a.renderer.width &gt; 80 </span><span class="cov1" title="1">{
                barWidth = 60
        }</span>

        <span class="cov5" title="10">completed := 0
        for _, task := range a.tasks </span><span class="cov7" title="20">{
                if task.Status == "PASS" || task.Status == "FAIL" || task.Status == "SKIPPED" </span><span class="cov4" title="7">{
                        completed++
                }</span>
        }

        <span class="cov5" title="10">bar := a.renderer.colors.ProgressBar(int(overallProgress), 100, barWidth)
        fmt.Printf("%s (%d/%d tasks)\n\n", bar, completed, len(a.tasks))

        // Render task list
        for _, task := range a.tasks </span><span class="cov7" title="20">{
                symbol := a.renderer.colors.StatusSymbol(task.Status)

                // Truncate task ID if needed (max 45 chars)
                taskID := task.ID
                if len(taskID) &gt; 45 </span><span class="cov1" title="1">{
                        taskID = taskID[:42] + "..."
                }</span>

                <span class="cov7" title="20">switch task.Status </span>{
                case "PASS", "FAIL", "SKIPPED":<span class="cov4" title="7">
                        statusText := a.renderer.colors.StatusColor(task.Status, task.Status)
                        fmt.Printf("%s %-*s %s\n", symbol, a.maxIDWidth, taskID, statusText)</span>
                case "RUNNING":<span class="cov4" title="6">
                        progress := CalculateTaskProgress(task.ElapsedSeconds, task.EstimatedSeconds)
                        progressText := fmt.Sprintf("%.0f%%", progress)
                        fmt.Printf("%s %-*s %s %s\n", symbol, a.maxIDWidth, taskID,
                                a.renderer.colors.Blue("running..."),
                                a.renderer.colors.Gray(progressText))</span>
                case "PENDING":<span class="cov4" title="7">
                        fmt.Printf("%s %-*s %s\n", symbol, a.maxIDWidth, taskID, a.renderer.colors.Gray("pending"))</span>
                }
        }

        // Render log box (fixed size)
        <span class="cov5" title="10">fmt.Println()
        fmt.Println(a.renderer.colors.Bold("â”€â”€â”€ Output â”€â”€â”€"))

        // Render log lines (pad with empty lines to maintain fixed size)
        for i := 0; i &lt; a.maxLogLines; i++ </span><span class="cov10" title="86">{
                if i &lt; len(a.logLines) </span><span class="cov6" title="12">{
                        fmt.Println(a.logLines[i])
                }</span> else<span class="cov9" title="74"> {
                        fmt.Println() // Empty line to maintain fixed height
                }</span>
        }
}

// renderFullMode renders the full animated mode with grouped stages
func (a *AnimatedTaskTracker) renderFullMode() <span class="cov3" title="4">{
        // Calculate overall progress
        overallProgress := CalculateOverallProgress(a.tasks)

        // Render overall progress bar
        barWidth := 40
        if a.renderer.width &gt; 60 </span><span class="cov3" title="4">{
                barWidth = 60
        }</span>

        <span class="cov3" title="4">bar := a.renderer.colors.ProgressBar(int(overallProgress), 100, barWidth)
        fmt.Printf("Overall: %s\n\n", bar)

        // Group tasks by type or phase
        groups := make(map[string][]TaskProgress)
        groupOrder := []string{}
        seen := make(map[string]bool)

        for _, task := range a.tasks </span><span class="cov5" title="9">{
                var groupKey string
                if a.groupBy == "phase" </span><span class="cov2" title="2">{
                        // Use the phase name if available, otherwise fall back to "Phase N"
                        if task.PhaseName != "" </span><span class="cov0" title="0">{
                                groupKey = task.PhaseName
                        }</span> else<span class="cov2" title="2"> {
                                groupKey = fmt.Sprintf("Phase %d", task.Phase)
                        }</span>
                } else<span class="cov4" title="7"> {
                        groupKey = task.Type
                }</span>

                <span class="cov5" title="9">if !seen[groupKey] </span><span class="cov4" title="7">{
                        groupOrder = append(groupOrder, groupKey)
                        seen[groupKey] = true
                }</span>
                <span class="cov5" title="9">groups[groupKey] = append(groups[groupKey], task)</span>
        }

        // Render each group
        <span class="cov3" title="4">for _, groupName := range groupOrder </span><span class="cov4" title="7">{
                taskList := groups[groupName]

                // Group header
                // Capitalize first letter of group name
                capitalizedName := strings.ToUpper(groupName[:1]) + groupName[1:]
                headerText := fmt.Sprintf("â”€ %s ", capitalizedName)
                padding := strings.Repeat("â”€", a.renderer.width-len(headerText)-2)
                fmt.Printf("â”Œ%s%sâ”\n", headerText, padding)

                // Tasks in group
                for _, task := range taskList </span><span class="cov5" title="9">{
                        symbol := a.renderer.colors.StatusSymbol(task.Status)

                        // Truncate task ID if needed (max 45 chars)
                        taskID := task.ID
                        if len(taskID) &gt; 45 </span><span class="cov0" title="0">{
                                taskID = taskID[:42] + "..."
                        }</span>

                        // Build the content line
                        <span class="cov5" title="9">var content string
                        switch task.Status </span>{
                        case "PASS":<span class="cov2" title="2">
                                duration := FormatDuration(int64(task.ElapsedSeconds * 1000))
                                content = fmt.Sprintf("%s %-*s %s", symbol, a.maxIDWidth, taskID,
                                        a.renderer.colors.Green(duration))</span>
                        case "FAIL":<span class="cov1" title="1">
                                duration := FormatDuration(int64(task.ElapsedSeconds * 1000))
                                content = fmt.Sprintf("%s %-*s %s", symbol, a.maxIDWidth, taskID,
                                        a.renderer.colors.Red(duration))</span>
                        case "SKIPPED":<span class="cov1" title="1">
                                content = fmt.Sprintf("%s %-*s %s", symbol, a.maxIDWidth, taskID,
                                        a.renderer.colors.Yellow("skipped"))</span>
                        case "RUNNING":<span class="cov3" title="4">
                                progress := CalculateTaskProgress(task.ElapsedSeconds, task.EstimatedSeconds)
                                elapsed := FormatDuration(int64(task.ElapsedSeconds * 1000))
                                estimated := FormatDuration(int64(task.EstimatedSeconds * 1000))
                                if task.IsEstimateGuess </span><span class="cov1" title="1">{
                                        estimated = estimated + "?"
                                }</span>

                                // Mini progress bar
                                <span class="cov3" title="4">miniBarWidth := 12
                                miniBar := a.renderer.colors.ProgressBar(int(progress), 100, miniBarWidth)

                                content = fmt.Sprintf("%s %-*s %s / %s   %s", symbol, a.maxIDWidth, taskID,
                                        elapsed, estimated, miniBar)</span>
                        case "PENDING":<span class="cov1" title="1">
                                content = fmt.Sprintf("%s %-*s %s", symbol, a.maxIDWidth, taskID,
                                        a.renderer.colors.Gray("pending"))</span>
                        }

                        // Print with consistent width
                        <span class="cov5" title="9">fmt.Printf("â”‚ %s\n", content)</span>
                }

                // Group footer
                <span class="cov4" title="7">fmt.Printf("â””%sâ”˜\n\n", strings.Repeat("â”€", a.renderer.width-2))</span>
        }

        // Render log box (fixed size)
        <span class="cov3" title="4">fmt.Println(a.renderer.colors.Bold("â”€â”€â”€ Output â”€â”€â”€"))

        // Render log lines (pad with empty lines to maintain fixed size)
        for i := 0; i &lt; a.maxLogLines; i++ </span><span class="cov8" title="35">{
                if i &lt; len(a.logLines) </span><span class="cov0" title="0">{
                        fmt.Println(a.logLines[i])
                }</span> else<span class="cov8" title="35"> {
                        fmt.Println() // Empty line to maintain fixed height
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package ui

import "fmt"

// ANSI color codes
const (
        ColorReset  = "\033[0m"
        ColorRed    = "\033[31m"
        ColorGreen  = "\033[32m"
        ColorYellow = "\033[33m"
        ColorBlue   = "\033[94m" // Bright blue - more readable on dark backgrounds
        ColorCyan   = "\033[36m"
        ColorGray   = "\033[90m"
        ColorBold   = "\033[1m"
)

// ColorFunc wraps text with color codes if colors are enabled
type ColorFunc func(string) string

// Colors holds all color functions
type Colors struct {
        enabled bool
}

// NewColors creates a new Colors instance
func NewColors(enabled bool) *Colors <span class="cov6" title="81">{
        return &amp;Colors{enabled: enabled}
}</span>

// Red returns red colored text
func (c *Colors) Red(s string) string <span class="cov5" title="21">{
        if !c.enabled </span><span class="cov4" title="19">{
                return s
        }</span>
        <span class="cov1" title="2">return ColorRed + s + ColorReset</span>
}

// Green returns green colored text
func (c *Colors) Green(s string) string <span class="cov6" title="46">{
        if !c.enabled </span><span class="cov5" title="39">{
                return s
        }</span>
        <span class="cov3" title="7">return ColorGreen + s + ColorReset</span>
}

// Yellow returns yellow colored text
func (c *Colors) Yellow(s string) string <span class="cov5" title="20">{
        if !c.enabled </span><span class="cov4" title="19">{
                return s
        }</span>
        <span class="cov1" title="1">return ColorYellow + s + ColorReset</span>
}

// Blue returns blue colored text
func (c *Colors) Blue(s string) string <span class="cov5" title="27">{
        if !c.enabled </span><span class="cov5" title="24">{
                return s
        }</span>
        <span class="cov2" title="3">return ColorBlue + s + ColorReset</span>
}

// Gray returns gray colored text
func (c *Colors) Gray(s string) string <span class="cov5" title="35">{
        if !c.enabled </span><span class="cov5" title="32">{
                return s
        }</span>
        <span class="cov2" title="3">return fmt.Sprintf("\033[90m%s\033[0m", s)</span>
}

// Cyan returns cyan colored text
func (c *Colors) Cyan(s string) string <span class="cov2" title="4">{
        if !c.enabled </span><span class="cov2" title="3">{
                return s
        }</span>
        <span class="cov1" title="1">return fmt.Sprintf("\033[36m%s\033[0m", s)</span>
}

// Bold returns bold text
func (c *Colors) Bold(s string) string <span class="cov5" title="24">{
        if !c.enabled </span><span class="cov5" title="23">{
                return s
        }</span>
        <span class="cov1" title="1">return ColorBold + s + ColorReset</span>
}

// StatusColor returns colored text based on status
func (c *Colors) StatusColor(status string, text string) string <span class="cov5" title="27">{
        switch status </span>{
        case "PASS":<span class="cov4" title="14">
                return c.Green(text)</span>
        case "FAIL":<span class="cov3" title="6">
                return c.Red(text)</span>
        case "SKIPPED":<span class="cov2" title="4">
                return c.Yellow(text)</span>
        case "RUNNING":<span class="cov1" title="1">
                return c.Blue(text)</span>
        case "PENDING":<span class="cov1" title="1">
                return c.Gray(text)</span>
        default:<span class="cov1" title="1">
                return text</span>
        }
}

// StatusSymbol returns a colored symbol for the status
func (c *Colors) StatusSymbol(status string) string <span class="cov6" title="50">{
        switch status </span>{
        case "PASS":<span class="cov4" title="14">
                return c.Green("âœ“")</span>
        case "FAIL":<span class="cov3" title="7">
                return c.Red("âœ—")</span>
        case "SKIPPED":<span class="cov3" title="8">
                return c.Yellow("âŠ˜")</span>
        case "RUNNING":<span class="cov4" title="11">
                return c.Blue("âš™")</span>
        case "PENDING":<span class="cov3" title="9">
                return c.Gray("â‹¯")</span>
        default:<span class="cov1" title="1">
                return " "</span>
        }
}

// ProgressBar creates a simple progress bar
func (c *Colors) ProgressBar(current, total, width int) string <span class="cov5" title="27">{
        if total == 0 </span><span class="cov1" title="1">{
                return ""
        }</span>

        <span class="cov5" title="26">percent := float64(current) / float64(total)
        filled := int(percent * float64(width))

        if filled &gt; width </span><span class="cov1" title="1">{
                filled = width
        }</span>

        <span class="cov5" title="26">bar := ""
        for i := 0; i &lt; width; i++ </span><span class="cov10" title="788">{
                if i &lt; filled </span><span class="cov8" title="295">{
                        bar += "â–ˆ"
                }</span> else<span class="cov9" title="493"> {
                        bar += "â–‘"
                }</span>
        }

        <span class="cov5" title="26">percentText := fmt.Sprintf(" %3.0f%%", percent*100)

        if c.enabled </span><span class="cov3" title="7">{
                if percent &gt;= 1.0 </span><span class="cov2" title="3">{
                        return c.Green(bar) + c.Green(percentText)
                }</span> else<span class="cov2" title="4"> if percent &gt;= 0.5 </span><span class="cov1" title="2">{
                        return c.Blue(bar) + percentText
                }</span> else<span class="cov1" title="2"> {
                        return c.Gray(bar) + percentText
                }</span>
        }

        <span class="cov4" title="19">return bar + percentText</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package ui

import (
        "time"
)

// TaskProgress represents the progress of a single task
type TaskProgress struct {
        ID               string
        Name             string
        Type             string // Type of task (quality, correctness, release)
        Phase            int    // Phase number (1, 2, 3, etc.)
        PhaseName        string // Display name for the phase
        Status           string
        EstimatedSeconds int
        IsEstimateGuess  bool // True if estimate is a default guess
        ElapsedSeconds   float64
        StartTime        time.Time
}

// CalculateTaskProgress returns the progress percentage for a task (0-100)
func CalculateTaskProgress(elapsed float64, estimated int) float64 <span class="cov8" title="29">{
        if estimated == 0 </span><span class="cov5" title="7">{
                return 0
        }</span>

        <span class="cov8" title="22">progress := (elapsed / float64(estimated)) * 100
        if progress &gt; 100 </span><span class="cov2" title="2">{
                return 100
        }</span>
        <span class="cov8" title="20">return progress</span>
}

// CalculateOverallProgress calculates overall pipeline progress based on task completion
func CalculateOverallProgress(tasks []TaskProgress) float64 <span class="cov8" title="22">{
        if len(tasks) == 0 </span><span class="cov1" title="1">{
                return 0
        }</span>

        <span class="cov8" title="21">completed := 0
        running := 0
        total := len(tasks)

        for _, task := range tasks </span><span class="cov10" title="45">{
                switch task.Status </span>{
                case "PASS", "FAIL", "SKIPPED":<span class="cov7" title="19">
                        // Task complete - counts as 1.0
                        completed++</span>
                case "RUNNING":<span class="cov7" title="13">
                        // Task in progress - counts as partial based on elapsed vs estimated
                        taskProgress := CalculateTaskProgress(task.ElapsedSeconds, task.EstimatedSeconds)
                        running += int(taskProgress)</span>
                case "PENDING":<span class="cov6" title="12"></span>
                        // Not started yet - counts as 0
                }
        }

        // Calculate percentage: (completed tasks + running progress) / total tasks
        <span class="cov8" title="21">totalProgress := float64(completed*100+running) / float64(total)

        if totalProgress &gt; 100 </span><span class="cov0" title="0">{
                return 100
        }</span>

        <span class="cov8" title="21">return totalProgress</span>
}

// FormatDuration formats a duration in milliseconds to a human-readable string
func FormatDuration(ms int64) string <span class="cov9" title="30">{
        if ms &lt; 1000 </span><span class="cov6" title="9">{
                return "0s"
        }</span>

        <span class="cov8" title="21">seconds := ms / 1000

        if seconds &lt; 60 </span><span class="cov6" title="12">{
                return formatSeconds(seconds)
        }</span>

        <span class="cov6" title="9">minutes := seconds / 60
        remainingSeconds := seconds % 60

        if minutes &lt; 60 </span><span class="cov4" title="4">{
                if remainingSeconds == 0 </span><span class="cov2" title="2">{
                        return formatMinutes(minutes)
                }</span>
                <span class="cov2" title="2">return formatMinutes(minutes) + " " + formatSeconds(remainingSeconds)</span>
        }

        <span class="cov4" title="5">hours := minutes / 60
        remainingMinutes := minutes % 60

        if remainingMinutes == 0 </span><span class="cov2" title="2">{
                return formatHours(hours)
        }</span>
        <span class="cov3" title="3">return formatHours(hours) + " " + formatMinutes(remainingMinutes)</span>
}

func formatSeconds(s int64) string <span class="cov7" title="14">{
        if s == 1 </span><span class="cov3" title="3">{
                return "1s"
        }</span>
        <span class="cov6" title="11">return formatInt(s) + "s"</span>
}

func formatMinutes(m int64) string <span class="cov5" title="7">{
        if m == 1 </span><span class="cov4" title="4">{
                return "1m"
        }</span>
        <span class="cov3" title="3">return formatInt(m) + "m"</span>
}

func formatHours(h int64) string <span class="cov4" title="5">{
        if h == 1 </span><span class="cov3" title="3">{
                return "1h"
        }</span>
        <span class="cov2" title="2">return formatInt(h) + "h"</span>
}

func formatInt(n int64) string <span class="cov8" title="24">{
        if n &lt; 10 </span><span class="cov7" title="13">{
                return string(rune('0' + n))
        }</span>
        <span class="cov6" title="11">return string(rune('0'+n/10)) + string(rune('0'+n%10))</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package ui

import (
        "fmt"
        "os"
        "strings"
)

// UIMode represents the UI rendering mode
type UIMode string

// UI mode constants
const (
        UIModeBasic UIMode = "basic"
        UIModeFull  UIMode = "full"
)

// Renderer handles UI rendering
type Renderer struct {
        mode        UIMode
        colors      *Colors
        width       int
        isTTY       bool
        animated    bool
        tracker     *AnimatedTaskTracker // Reference to tracker for verbose output
        pipelineLog *os.File             // Log file for verbose output
}

// NewRenderer creates a new UI renderer
func NewRenderer(mode UIMode, enableColors bool, animated bool) *Renderer <span class="cov10" title="70">{
        isTTY := IsTTY(uintptr(1)) // stdout
        width := GetTerminalWidth()

        // Force basic mode if not a TTY
        if !isTTY &amp;&amp; mode != UIModeBasic </span><span class="cov7" title="24">{
                mode = UIModeBasic
        }</span>

        // Disable colors if not a TTY or explicitly disabled
        <span class="cov10" title="70">if !isTTY </span><span class="cov10" title="70">{
                enableColors = false
        }</span>

        // Disable animation if not a TTY
        <span class="cov10" title="70">if !isTTY </span><span class="cov10" title="70">{
                animated = false
        }</span>

        <span class="cov10" title="70">return &amp;Renderer{
                mode:     mode,
                colors:   NewColors(enableColors),
                width:    width,
                isTTY:    isTTY,
                animated: animated,
        }</span>
}

// IsAnimated returns true if animated mode is enabled
func (r *Renderer) IsAnimated() bool <span class="cov2" title="2">{
        return r.animated
}</span>

// RenderHeader renders the pipeline header
func (r *Renderer) RenderHeader(runID, repoRoot string, gitMode string, changedFiles int) <span class="cov4" title="6">{
        switch r.mode </span>{
        case UIModeFull:<span class="cov1" title="1">
                r.renderFullHeader(runID, repoRoot, gitMode, changedFiles)</span>
        default:<span class="cov4" title="5">
                r.renderBasicHeader(runID, repoRoot, gitMode, changedFiles)</span>
        }
}

func (r *Renderer) renderFullHeader(runID, repoRoot string, gitMode string, changedFiles int) <span class="cov1" title="1">{
        line := strings.Repeat("â•", r.width-2)
        fmt.Printf("â•”%sâ•—\n", line)
        fmt.Printf("â•‘ %s%-*s%sâ•‘\n",
                r.colors.Bold("devpipe run "+runID),
                r.width-len("devpipe run "+runID)-3,
                "",
                "")
        fmt.Printf("â•‘ Repo: %-*sâ•‘\n", r.width-9, repoRoot)
        if gitMode != "" </span><span class="cov0" title="0">{
                info := fmt.Sprintf("Git: %s | Files: %d", gitMode, changedFiles)
                fmt.Printf("â•‘ %-*sâ•‘\n", r.width-3, info)
        }</span>
        <span class="cov1" title="1">fmt.Printf("â•š%sâ•\n", line)
        fmt.Println()</span>
}

func (r *Renderer) renderBasicHeader(runID, repoRoot string, gitMode string, changedFiles int) <span class="cov4" title="5">{
        fmt.Printf("devpipe run %s\n", runID)
        fmt.Printf("Repo root: %s\n", repoRoot)
        if gitMode != "" </span><span class="cov3" title="4">{
                fmt.Printf("Git mode: %s\n", gitMode)
                fmt.Printf("Changed files: %d\n", changedFiles)
        }</span>
        <span class="cov4" title="5">fmt.Println()</span> // Blank line after header
}

// truncateTaskID truncates a task ID to maxLen, adding "..." if needed
func truncateTaskID(id string, maxLen int) string <span class="cov7" title="22">{
        if len(id) &lt;= maxLen </span><span class="cov7" title="19">{
                return id
        }</span>
        <span class="cov3" title="3">return id[:maxLen-3] + "..."</span>
}

// RenderTaskStart renders when a task starts
func (r *Renderer) RenderTaskStart(id, command string, verbose bool) <span class="cov3" title="3">{
        // In animated mode, don't print anything yet
        if r.animated </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov3" title="3">taskID := truncateTaskID(id, 15)
        if verbose </span><span class="cov1" title="1">{
                fmt.Printf("[%-15s] %s    %s\n", taskID, r.colors.Blue("RUN"), command)
        }</span> else<span class="cov2" title="2"> {
                fmt.Printf("[%-15s] %s\n", taskID, r.colors.Blue("RUN"))
        }</span>
}

// RenderTaskComplete renders when a task completes
func (r *Renderer) RenderTaskComplete(id, status string, exitCode *int, durationMs int64, verbose bool) <span class="cov3" title="3">{
        // In animated mode, don't print anything (animation handles it)
        if r.animated </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov3" title="3">taskID := truncateTaskID(id, 15)
        symbol := r.colors.StatusSymbol(status)
        statusText := r.colors.StatusColor(status, status)

        if verbose &amp;&amp; exitCode != nil </span><span class="cov1" title="1">{
                fmt.Printf("[%-15s] %s %s (exit %d, %dms)\n", taskID, symbol, statusText, *exitCode, durationMs)
        }</span> else<span class="cov2" title="2"> {
                fmt.Printf("[%-15s] %s %s (%dms)\n", taskID, symbol, statusText, durationMs)
        }</span>
        <span class="cov3" title="3">fmt.Println()</span> // Blank line after task
}

// RenderTaskSkipped renders when a task is skipped
func (r *Renderer) RenderTaskSkipped(id, reason string, verbose bool) <span class="cov3" title="3">{
        // In animated mode, don't print anything (animation handles it)
        if r.animated </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov3" title="3">taskID := truncateTaskID(id, 15)
        symbol := r.colors.StatusSymbol("SKIPPED")
        if verbose </span><span class="cov1" title="1">{
                fmt.Printf("[%-15s] %s %s (%s)\n", taskID, symbol, r.colors.Yellow("SKIPPED"), reason)
        }</span> else<span class="cov2" title="2"> {
                fmt.Printf("[%-15s] %s %s\n", taskID, symbol, r.colors.Yellow("SKIPPED"))
        }</span>
        <span class="cov3" title="3">fmt.Println()</span> // Blank line after skipped task
}

// RenderSummary renders the final summary
func (r *Renderer) RenderSummary(results []TaskSummary, anyFailed bool, totalMs int64) <span class="cov4" title="6">{
        // Add blank line before summary if animated (animation already on screen)
        if r.animated </span><span class="cov0" title="0">{
                fmt.Println()
        }</span>

        // Calculate max task ID width (same logic as animated view)
        <span class="cov4" title="6">maxIDWidth := 12
        for _, result := range results </span><span class="cov5" title="9">{
                taskLen := len(result.ID)
                if taskLen &gt; 45 </span><span class="cov1" title="1">{
                        taskLen = 45
                }</span>
                <span class="cov5" title="9">if taskLen &gt; maxIDWidth </span><span class="cov1" title="1">{
                        maxIDWidth = taskLen
                }</span>
        }

        <span class="cov4" title="6">fmt.Println(r.colors.Bold("Summary:"))

        for _, result := range results </span><span class="cov5" title="9">{
                symbol := r.colors.StatusSymbol(result.Status)
                statusText := r.colors.StatusColor(result.Status, fmt.Sprintf("%-10s", result.Status))
                seconds := float64(result.DurationMs) / 1000.0
                durationText := fmt.Sprintf("%.2fs (%dms)", seconds, result.DurationMs)

                annotation := ""
                if result.AutoFixed </span><span class="cov1" title="1">{
                        annotation = " " + r.colors.Gray("[auto-fixed]")
                }</span>

                <span class="cov5" title="9">taskID := truncateTaskID(result.ID, 45)
                fmt.Printf("  %s %-*s %s %s%s\n", symbol, maxIDWidth, taskID, statusText, durationText, annotation)</span>
        }

        // Show total pipeline duration
        <span class="cov4" title="6">fmt.Println()
        totalSeconds := float64(totalMs) / 1000.0
        fmt.Printf("Total: %.2fs (%dms)\n", totalSeconds, totalMs)

        fmt.Println()
        if anyFailed </span><span class="cov1" title="1">{
                fmt.Println(r.colors.Red("devpipe: one or more tasks failed"))
        }</span> else<span class="cov4" title="5"> {
                fmt.Println(r.colors.Green("devpipe: all tasks passed or were skipped"))
        }</span>
        <span class="cov4" title="6">fmt.Println()</span> // Blank line at very end
}

// TaskSummary represents a task result for the summary
type TaskSummary struct {
        ID         string
        Status     string
        DurationMs int64
        AutoFixed  bool
}

// RenderProgress renders a progress bar (for full mode)
func (r *Renderer) RenderProgress(current, total int) <span class="cov3" title="4">{
        if r.mode == UIModeBasic </span><span class="cov3" title="4">{
                return
        }</span>

        <span class="cov0" title="0">barWidth := 40
        if r.width &gt; 80 </span><span class="cov0" title="0">{
                barWidth = 60
        }</span>

        <span class="cov0" title="0">bar := r.colors.ProgressBar(current, total, barWidth)
        fmt.Printf("\n%s (%d/%d stages)\n\n", bar, current, total)</span>
}

// CreateAnimatedTracker creates an animated task tracker
func (r *Renderer) CreateAnimatedTracker(tasks []TaskProgress, headerLines int, refreshMs int, groupBy string) *AnimatedTaskTracker <span class="cov2" title="2">{
        if !r.animated </span><span class="cov2" title="2">{
                return nil
        }</span>
        <span class="cov0" title="0">return NewAnimatedTaskTracker(r, tasks, headerLines, refreshMs, groupBy)</span>
}

// Blue returns the string formatted in blue color
func (r *Renderer) Blue(s string) string <span class="cov1" title="1">{
        return r.colors.Blue(s)
}</span>

// Green returns the string formatted in green color
func (r *Renderer) Green(s string) string <span class="cov2" title="2">{
        return r.colors.Green(s)
}</span>

// Red returns the string formatted in red color
func (r *Renderer) Red(s string) string <span class="cov2" title="2">{
        return r.colors.Red(s)
}</span>

// Yellow returns the string formatted in yellow color
func (r *Renderer) Yellow(s string) string <span class="cov1" title="1">{
        return r.colors.Yellow(s)
}</span>

// Cyan returns the string formatted in cyan color
func (r *Renderer) Cyan(s string) string <span class="cov1" title="1">{
        return r.colors.Cyan(s)
}</span>

// Gray returns the string formatted in gray color
func (r *Renderer) Gray(s string) string <span class="cov2" title="2">{
        return r.colors.Gray(s)
}</span>

// StatusColor returns the appropriate color for a given status string
func (r *Renderer) StatusColor(status string) string <span class="cov2" title="2">{
        return r.colors.StatusColor(status, status)
}</span>

// SetTracker sets the animated tracker reference
func (r *Renderer) SetTracker(tracker *AnimatedTaskTracker) <span class="cov2" title="2">{
        r.tracker = tracker
}</span>

// SetPipelineLog sets the pipeline log file for verbose output
func (r *Renderer) SetPipelineLog(log *os.File) <span class="cov2" title="2">{
        r.pipelineLog = log
}</span>

// Verbose outputs a verbose message with [verbose] prefix
// Always writes to pipeline.log if available
// Only displays on screen if verbose flag is enabled
func (r *Renderer) Verbose(verbose bool, format string, args ...interface{}) <span class="cov3" title="4">{
        msg := fmt.Sprintf(format, args...)

        // Always write to pipeline.log (without color codes)
        if r.pipelineLog != nil </span><span class="cov1" title="1">{
                plainLine := fmt.Sprintf("[%-15s] %s\n", "verbose", msg)
                r.pipelineLog.WriteString(plainLine)
        }</span>

        // Only output to console/tracker if verbose flag is enabled
        <span class="cov3" title="4">if verbose </span><span class="cov3" title="3">{
                // Pad "verbose" to 15 chars BEFORE applying color, so alignment works
                paddedVerbose := fmt.Sprintf("%-15s", "verbose")
                line := fmt.Sprintf("[%s] %s", r.colors.Gray(paddedVerbose), msg)

                if r.tracker != nil </span><span class="cov1" title="1">{
                        r.tracker.AddLogLine(line)
                }</span> else<span class="cov2" title="2"> {
                        fmt.Println(line)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package ui

import (
        "golang.org/x/term"
        "os"
)

// IsTTY checks if the given file descriptor is a terminal
func IsTTY(fd uintptr) bool <span class="cov10" title="76">{
        return term.IsTerminal(int(fd))
}</span>

// GetTerminalWidth returns the terminal width, or 80 if not a TTY
func GetTerminalWidth() int <span class="cov9" title="72">{
        width, _, err := term.GetSize(int(os.Stdout.Fd()))
        if err != nil || width &lt; 40 </span><span class="cov9" title="72">{
                return 80
        }</span>
        <span class="cov0" title="0">return width</span>
}

// GetTerminalHeight returns the terminal height, or 24 if not a TTY
func GetTerminalHeight() int <span class="cov8" title="36">{
        _, height, err := term.GetSize(int(os.Stdout.Fd()))
        if err != nil || height &lt; 10 </span><span class="cov8" title="36">{
                return 24
        }</span>
        <span class="cov0" title="0">return height</span>
}

// IsColorEnabled returns true if color output should be enabled
func IsColorEnabled() bool <span class="cov3" title="4">{
        // Check NO_COLOR environment variable
        if os.Getenv("NO_COLOR") != "" </span><span class="cov1" title="1">{
                return false
        }</span>

        // Check if stdout is a TTY
        <span class="cov3" title="3">return IsTTY(os.Stdout.Fd())</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">// Copyright 2025 Andrew Khoury
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// devpipe - Fast, local pipeline runner

// Package main implements the devpipe CLI tool for running local development pipelines.
package main

import (
        "bytes"
        "encoding/json"
        "errors"
        "flag"
        "fmt"
        "os"
        "os/exec"
        "path/filepath"
        "runtime"
        "strings"
        "sync"
        "time"

        "github.com/drew/devpipe/internal/config"
        "github.com/drew/devpipe/internal/dashboard"
        "github.com/drew/devpipe/internal/git"
        "github.com/drew/devpipe/internal/metrics"
        "github.com/drew/devpipe/internal/model"
        "github.com/drew/devpipe/internal/sarif"
        "github.com/drew/devpipe/internal/ui"
        "golang.org/x/sync/errgroup"
)

// Version information (set via ldflags during build)
var (
        version   = "dev"
        commit    = "none"
        buildDate = "unknown"
)

// sliceFlag allows repeating --skip
type sliceFlag []string

func (s *sliceFlag) String() string <span class="cov1" title="1">{
        return fmt.Sprintf("%v", *s)
}</span>

func (s *sliceFlag) Set(val string) error <span class="cov2" title="2">{
        *s = append(*s, val)
        return nil
}</span>

func main() <span class="cov0" title="0">{
        // Check for subcommands first
        if len(os.Args) &gt; 1 </span><span class="cov0" title="0">{
                switch os.Args[1] </span>{
                case "list":<span class="cov0" title="0">
                        listCmd()
                        return</span>
                case "validate":<span class="cov0" title="0">
                        validateCmd()
                        return</span>
                case "generate-reports":<span class="cov0" title="0">
                        generateReportsCmd()
                        return</span>
                case "sarif":<span class="cov0" title="0">
                        sarifCmd()
                        return</span>
                case "version", "--version", "-v":<span class="cov0" title="0">
                        fmt.Printf("devpipe version %s\n", version)
                        return</span>
                case "help", "--help", "-h":<span class="cov0" title="0">
                        printHelp()
                        return</span>
                }
        }

        // CLI flags
        <span class="cov0" title="0">var (
                flagConfig    string
                flagSince     string
                flagOnly      string
                flagUI        string
                flagFixType   string
                flagNoColor   bool
                flagDashboard bool
                flagFailFast  bool
                flagDryRun    bool
                flagVerbose   bool
                flagFast      bool
                flagSkipVals  sliceFlag
        )

        flag.StringVar(&amp;flagConfig, "config", "", "Path to config file (default: config.toml)")
        flag.StringVar(&amp;flagSince, "since", "", "Git ref to compare against (overrides config)")
        flag.StringVar(&amp;flagOnly, "only", "", "Run only specific task(s) by id (comma-separated)")
        flag.StringVar(&amp;flagUI, "ui", "basic", "UI mode: basic, full")
        flag.StringVar(&amp;flagFixType, "fix-type", "", "Fix type: auto, helper, none (overrides config)")
        flag.BoolVar(&amp;flagDashboard, "dashboard", false, "Show dashboard with live progress")
        flag.BoolVar(&amp;flagNoColor, "no-color", false, "Disable colored output")
        flag.Var(&amp;flagSkipVals, "skip", "Skip a task by id (can be specified multiple times)")
        flag.BoolVar(&amp;flagFailFast, "fail-fast", false, "Stop on first task failure")
        flag.BoolVar(&amp;flagDryRun, "dry-run", false, "Do not execute commands, simulate only")
        flag.BoolVar(&amp;flagVerbose, "verbose", false, "Verbose logging")
        flag.BoolVar(&amp;flagFast, "fast", false, "Skip long running tasks")
        flag.Parse()

        // Load configuration first to get UI mode
        cfg, configTaskOrder, phaseNames, taskToPhase, err := config.LoadConfig(flagConfig)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "ERROR: %v\n", err)
                os.Exit(1)
        }</span>

        // Merge with defaults
        <span class="cov0" title="0">mergedCfg := config.MergeWithDefaults(cfg)

        // Validate configuration before running
        result, err := config.ValidateConfig(&amp;mergedCfg)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "ERROR: Failed to validate config: %v\n", err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">if !result.Valid </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "ERROR: Configuration validation failed:\n")
                for _, e := range result.Errors </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "  - %s: %s\n", e.Field, e.Message)
                }</span>
                <span class="cov0" title="0">os.Exit(1)</span>
        }
        <span class="cov0" title="0">if len(result.Warnings) &gt; 0 &amp;&amp; flagVerbose </span><span class="cov0" title="0">{
                for _, w := range result.Warnings </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "WARNING: %s: %s\n", w.Field, w.Message)
                }</span>
        }

        // Parse UI mode (CLI flag overrides config)
        <span class="cov0" title="0">uiModeStr := flagUI
        if flagUI == "basic" &amp;&amp; cfg != nil &amp;&amp; mergedCfg.Defaults.UIMode != "" </span><span class="cov0" title="0">{
                // Use config value if CLI flag is default
                uiModeStr = mergedCfg.Defaults.UIMode
        }</span>

        <span class="cov0" title="0">var uiMode ui.UIMode
        switch uiModeStr </span>{
        case "basic":<span class="cov0" title="0">
                uiMode = ui.UIModeBasic</span>
        case "full":<span class="cov0" title="0">
                uiMode = ui.UIModeFull</span>
        default:<span class="cov0" title="0">
                uiMode = ui.UIModeBasic</span>
        }

        // Create renderer
        <span class="cov0" title="0">enableColors := !flagNoColor &amp;&amp; ui.IsColorEnabled()
        // Determine if we should use dashboard (animated tracker)
        useAnimated := flagDashboard &amp;&amp; ui.IsTTY(uintptr(1))
        renderer := ui.NewRenderer(uiMode, enableColors, useAnimated)

        // Determine repo root
        repoRoot, inGitRepo := git.DetectRepoRoot()
        if !inGitRepo &amp;&amp; flagVerbose </span><span class="cov0" title="0">{
                fmt.Println("WARNING: not in a git repo, using current directory as repo root")
        }</span>

        // Auto-generate config.toml if it doesn't exist and no custom config specified
        <span class="cov0" title="0">if cfg == nil &amp;&amp; flagConfig == "" </span><span class="cov0" title="0">{
                defaultConfigPath := "config.toml"

                // Prompt user to create config
                fmt.Printf("No config.toml found. Create one with example tasks? (y/n): ")
                var response string
                fmt.Scanln(&amp;response)

                if response == "y" || response == "Y" || response == "yes" || response == "Yes" </span><span class="cov0" title="0">{
                        if err := config.GenerateDefaultConfig(defaultConfigPath, repoRoot); err != nil </span><span class="cov0" title="0">{
                                fmt.Fprintf(os.Stderr, "ERROR: Could not generate config.toml: %v\n", err)
                                os.Exit(1)
                        }</span>
                        <span class="cov0" title="0">fmt.Printf("âœ“ Created config.toml - edit it to customize your tasks\n")
                        fmt.Printf("  Full reference: https://github.com/drewkhoury/devpipe/blob/main/config.example.toml\n\n")

                        // Reload config after generating
                        cfg, configTaskOrder, phaseNames, taskToPhase, _ = config.LoadConfig(defaultConfigPath)
                        mergedCfg = config.MergeWithDefaults(cfg)</span>
                } else<span class="cov0" title="0"> {
                        fmt.Fprintf(os.Stderr, "ERROR: No config.toml found. Create one or specify with --config flag\n")
                        os.Exit(1)
                }</span>
        }

        // Determine which tasks to use
        <span class="cov0" title="0">var tasks map[string]config.TaskConfig
        var taskOrder []string

        if cfg == nil || len(cfg.Tasks) == 0 </span><span class="cov0" title="0">{
                // No config file or no tasks defined, use built-in
                if flagVerbose </span><span class="cov0" title="0">{
                        fmt.Println("No config file found, using built-in tasks")
                }</span>
                <span class="cov0" title="0">tasks = config.BuiltInTasks(repoRoot)
                taskOrder = config.GetTaskOrder()</span>
        } else<span class="cov0" title="0"> {
                // Use tasks from config
                tasks = mergedCfg.Tasks
                // Use the order extracted from the config file
                if len(configTaskOrder) &gt; 0 </span><span class="cov0" title="0">{
                        taskOrder = configTaskOrder
                }</span> else<span class="cov0" title="0"> {
                        // Fallback: use built-in order if tasks match, otherwise alphabetical
                        builtInOrder := config.GetTaskOrder()
                        for _, id := range builtInOrder </span><span class="cov0" title="0">{
                                if _, exists := tasks[id]; exists </span><span class="cov0" title="0">{
                                        taskOrder = append(taskOrder, id)
                                }</span>
                        }
                        // Add any additional tasks not in built-in order
                        <span class="cov0" title="0">for id := range tasks </span><span class="cov0" title="0">{
                                found := false
                                for _, existing := range taskOrder </span><span class="cov0" title="0">{
                                        if existing == id </span><span class="cov0" title="0">{
                                                found = true
                                                break</span>
                                        }
                                }
                                <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                                        taskOrder = append(taskOrder, id)
                                }</span>
                        }
                }

                // Filter out "wait*" and "phase-*" pseudo-tasks (they're just phase markers)
                // Keep them in taskOrder for phase detection, but remove from tasks map
                <span class="cov0" title="0">for id := range tasks </span><span class="cov0" title="0">{
                        if id == "wait" || strings.HasPrefix(id, "wait-") || strings.HasPrefix(id, "phase-") </span><span class="cov0" title="0">{
                                delete(tasks, id)
                        }</span>
                }
        }

        // Determine git mode and ref
        <span class="cov0" title="0">gitMode := mergedCfg.Defaults.Git.Mode
        gitRef := mergedCfg.Defaults.Git.Ref

        // CLI --since overrides config
        if flagSince != "" </span><span class="cov0" title="0">{
                gitMode = "ref"
                gitRef = flagSince
        }</span>

        // Get changed files
        <span class="cov0" title="0">gitInfo := git.DetectChangedFiles(repoRoot, inGitRepo, gitMode, gitRef, flagVerbose)

        // Prepare output dir
        outputRoot := filepath.Join(repoRoot, mergedCfg.Defaults.OutputRoot)
        runID := makeRunID()
        runDir := filepath.Join(outputRoot, "runs", runID)
        logDir := filepath.Join(runDir, "logs")

        if err := os.MkdirAll(logDir, 0o755); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "ERROR: failed to create run directories: %v\n", err)
                os.Exit(1)
        }</span>

        // Load historical averages
        <span class="cov0" title="0">historicalAvg := loadHistoricalAverages(outputRoot)

        // Build task list
        var taskDefs []model.TaskDefinition
        for _, id := range taskOrder </span><span class="cov0" title="0">{
                // Check if this is a "wait" or "wait-*" marker
                if id == "wait" || strings.HasPrefix(id, "wait-") </span><span class="cov0" title="0">{
                        // Mark the previous task as a wait point (end of phase)
                        if len(taskDefs) &gt; 0 </span><span class="cov0" title="0">{
                                taskDefs[len(taskDefs)-1].Wait = true
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                <span class="cov0" title="0">taskCfg, ok := tasks[id]
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Resolve with defaults
                <span class="cov0" title="0">resolved := mergedCfg.ResolveTaskConfig(id, taskCfg, repoRoot)

                // Skip if disabled
                if resolved.Enabled != nil &amp;&amp; !*resolved.Enabled </span><span class="cov0" title="0">{
                        renderer.Verbose(flagVerbose, "%s DISABLED in config", id)
                        continue</span>
                }

                // Use historical average if available, otherwise use 10s default
                <span class="cov0" title="0">estimatedSeconds := 10
                isGuess := true

                if avgSeconds, hasHistory := historicalAvg[id]; hasHistory </span><span class="cov0" title="0">{
                        // Always prefer historical average
                        estimatedSeconds = avgSeconds
                        isGuess = false // Historical data, not a guess
                }</span>

                // Get phase name from taskToPhase mapping
                <span class="cov0" title="0">phaseName := ""
                if phaseID, ok := taskToPhase[id]; ok </span><span class="cov0" title="0">{
                        // Look up the phase name using the phase ID
                        for _, phaseInfo := range phaseNames </span><span class="cov0" title="0">{
                                if phaseInfo.ID == phaseID </span><span class="cov0" title="0">{
                                        phaseName = phaseInfo.Name
                                        break</span>
                                }
                        }
                }

                <span class="cov0" title="0">taskDef := model.TaskDefinition{
                        ID:               id,
                        Name:             resolved.Name,
                        Desc:             resolved.Desc,
                        Phase:            phaseName,
                        Type:             resolved.Type,
                        Command:          resolved.Command,
                        Workdir:          resolved.Workdir,
                        EstimatedSeconds: estimatedSeconds,
                        IsEstimateGuess:  isGuess,
                        Wait:             resolved.Wait,
                }

                // Add metrics config if present
                if resolved.MetricsFormat != "" </span><span class="cov0" title="0">{
                        taskDef.MetricsFormat = resolved.MetricsFormat
                        taskDef.MetricsPath = resolved.MetricsPath
                        if flagVerbose &amp;&amp; !useAnimated </span><span class="cov0" title="0">{
                                // Only print before dashboard starts; during dashboard it goes to output
                                fmt.Printf("[%-15s] %s Metrics configured: format=%s, path=%s\n", renderer.Gray("verbose"), id, resolved.MetricsFormat, resolved.MetricsPath)
                        }</span>
                }

                // Add fix config if present
                // Apply CLI flag override if specified
                <span class="cov0" title="0">fixType := resolved.FixType
                if flagFixType != "" </span><span class="cov0" title="0">{
                        fixType = flagFixType
                }</span>
                <span class="cov0" title="0">taskDef.FixType = fixType
                taskDef.FixCommand = resolved.FixCommand

                taskDefs = append(taskDefs, taskDef)</span>
        }

        // Apply CLI filters
        <span class="cov0" title="0">filteredTasks := filterTasks(taskDefs, flagOnly, flagSkipVals, flagFast, mergedCfg.Defaults.FastThreshold, flagVerbose)

        // Run tasks
        var (
                results         []model.TaskResult
                overallExitCode int
                anyFailed       bool
        )

        // Create pipeline.log for verbose output
        pipelineLogPath := filepath.Join(runDir, "pipeline.log")
        pipelineLog, err := os.Create(pipelineLogPath)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "WARNING: cannot create pipeline.log: %v\n", err)
                pipelineLog = nil
        }</span>
        <span class="cov0" title="0">if pipelineLog != nil </span><span class="cov0" title="0">{
                defer pipelineLog.Close()
                // Set pipeline log on renderer so verbose output is captured
                renderer.SetPipelineLog(pipelineLog)
        }</span>

        // Render header
        <span class="cov0" title="0">renderer.RenderHeader(runID, repoRoot, gitMode, len(gitInfo.ChangedFiles))

        // Setup animation if enabled
        var tracker *ui.AnimatedTaskTracker

        // Ensure cursor is restored on exit (in case of panic or early exit)
        defer func() </span><span class="cov0" title="0">{
                if tracker != nil </span><span class="cov0" title="0">{
                        fmt.Print("\033[?25h") // Show cursor
                        fmt.Println()          // Add newline to ensure clean exit
                }</span>
        }()

        // Group tasks into phases based on wait markers
        <span class="cov0" title="0">phases := groupTasksIntoPhases(filteredTasks, phaseNames)

        if renderer.IsAnimated() </span><span class="cov0" title="0">{
                // Build task progress list with phase information
                var taskProgress []ui.TaskProgress
                for phaseIdx, phase := range phases </span><span class="cov0" title="0">{
                        for _, st := range phase.Tasks </span><span class="cov0" title="0">{
                                taskProgress = append(taskProgress, ui.TaskProgress{
                                        ID:               st.ID,
                                        Name:             st.Name,
                                        Type:             st.Type,
                                        Phase:            phaseIdx + 1, // 1-indexed phases
                                        PhaseName:        phase.Name,
                                        Status:           "PENDING",
                                        EstimatedSeconds: st.EstimatedSeconds,
                                        IsEstimateGuess:  st.IsEstimateGuess,
                                        ElapsedSeconds:   0,
                                        StartTime:        time.Time{},
                                })
                        }</span>
                }

                // Calculate header lines
                <span class="cov0" title="0">headerLines := 4 // basic mode: run ID, repo, git mode, changed files
                if renderer.IsAnimated() </span><span class="cov0" title="0">{
                        headerLines = 4
                }</span>

                <span class="cov0" title="0">tracker = renderer.CreateAnimatedTracker(taskProgress, headerLines, mergedCfg.Defaults.AnimationRefreshMs, mergedCfg.Defaults.AnimatedGroupBy)
                if tracker != nil </span><span class="cov0" title="0">{
                        if err := tracker.Start(); err != nil </span><span class="cov0" title="0">{
                                // Animation failed, fall back to non-animated
                                if flagVerbose </span><span class="cov0" title="0">{
                                        fmt.Fprintf(os.Stderr, "WARNING: Animation not supported, using basic mode\n")
                                }</span>
                                <span class="cov0" title="0">tracker = nil</span>
                        } else<span class="cov0" title="0"> {
                                // Set tracker on renderer so verbose output can be routed
                                renderer.SetTracker(tracker)
                        }</span>
                }
        }

        <span class="cov0" title="0">if len(phases) &gt; 1 </span><span class="cov0" title="0">{
                renderer.Verbose(flagVerbose, "Executing %d phases with parallel tasks", len(phases))
        }</span>

        // Track total pipeline duration
        <span class="cov0" title="0">pipelineStart := time.Now()

        // Execute phases sequentially, tasks within each phase in parallel
        var resultsMu sync.Mutex
        var outputMu sync.Mutex // For sequential output display

        for phaseIdx, phase := range phases </span><span class="cov0" title="0">{
                if len(phases) &gt; 1 </span><span class="cov0" title="0">{
                        renderer.Verbose(flagVerbose, "Phase %d/%d (%d tasks)", phaseIdx+1, len(phases), len(phase.Tasks))
                }</span>

                // Use errgroup for parallel execution within phase
                <span class="cov0" title="0">g := new(errgroup.Group)
                g.SetLimit(10) // Max 10 concurrent tasks

                var phaseFailed bool
                var phaseFailMu sync.Mutex

                // For sequential output: each task gets a completion channel from the previous task
                var prevTaskDone chan struct{}

                for _, st := range phase.Tasks </span><span class="cov0" title="0">{
                        // Check if should skip due to --fast
                        longRunning := st.EstimatedSeconds &gt;= mergedCfg.Defaults.FastThreshold
                        if flagFast &amp;&amp; longRunning &amp;&amp; flagOnly == "" </span><span class="cov0" title="0">{
                                reason := fmt.Sprintf("skipped by --fast (est %ds)", st.EstimatedSeconds)

                                // Update tracker if animated
                                if tracker != nil </span><span class="cov0" title="0">{
                                        tracker.UpdateTask(st.ID, "SKIPPED", 0)
                                }</span>

                                <span class="cov0" title="0">renderer.RenderTaskSkipped(st.ID, reason, flagVerbose)
                                resultsMu.Lock()
                                results = append(results, model.TaskResult{
                                        ID:               st.ID,
                                        Name:             st.Name,
                                        Desc:             st.Desc,
                                        Phase:            st.Phase,
                                        Type:             st.Type,
                                        Status:           model.StatusSkipped,
                                        Skipped:          true,
                                        SkipReason:       "skipped by --fast",
                                        Command:          st.Command,
                                        Workdir:          st.Workdir,
                                        LogPath:          "",
                                        EstimatedSeconds: st.EstimatedSeconds,
                                })
                                resultsMu.Unlock()
                                continue</span>
                        }

                        // Capture task for goroutine
                        <span class="cov0" title="0">task := st

                        // Create a done channel for this task
                        taskDone := make(chan struct{})
                        waitForPrev := prevTaskDone
                        prevTaskDone = taskDone // Next task will wait for this one

                        g.Go(func() error </span><span class="cov0" title="0">{
                                res, taskBuffer, _ := runTask(task, runDir, logDir, flagDryRun, flagVerbose, renderer, tracker, &amp;outputMu, waitForPrev, taskDone)

                                // Display buffered output sequentially (always, even in animated mode)
                                if taskBuffer != nil &amp;&amp; taskBuffer.Len() &gt; 0 </span><span class="cov0" title="0">{
                                        outputMu.Lock()
                                        if tracker != nil </span><span class="cov0" title="0">{
                                                // In animated mode, send buffered output to tracker
                                                lines := strings.Split(strings.TrimRight(taskBuffer.String(), "\n"), "\n")
                                                for _, line := range lines </span><span class="cov0" title="0">{
                                                        tracker.AddLogLine(line)
                                                }</span>
                                        } else<span class="cov0" title="0"> {
                                                // In non-animated mode, print directly
                                                fmt.Print(taskBuffer.String())
                                        }</span>
                                        <span class="cov0" title="0">outputMu.Unlock()</span>
                                }

                                <span class="cov0" title="0">resultsMu.Lock()
                                results = append(results, res)
                                resultsMu.Unlock()

                                if res.Status == model.StatusFail </span><span class="cov0" title="0">{
                                        phaseFailMu.Lock()
                                        phaseFailed = true
                                        anyFailed = true
                                        overallExitCode = 1
                                        phaseFailMu.Unlock()

                                        if flagFailFast </span><span class="cov0" title="0">{
                                                if flagVerbose </span><span class="cov0" title="0">{
                                                        fmt.Printf("[%-15s] FAIL, stopping due to --fail-fast\n", task.ID)
                                                }</span>
                                                <span class="cov0" title="0">return fmt.Errorf("task %s failed", task.ID)</span>
                                        }
                                }
                                <span class="cov0" title="0">return nil</span>
                        })
                }

                // Wait for all tasks in this phase to complete
                <span class="cov0" title="0">if err := g.Wait(); err != nil &amp;&amp; flagFailFast </span><span class="cov0" title="0">{
                        // Fail-fast triggered, stop all phases
                        break</span>
                }

                // Auto-fix logic: check for failed tasks that have fixType="auto"
                <span class="cov0" title="0">if !flagDryRun </span><span class="cov0" title="0">{
                        resultsMu.Lock()
                        var tasksToFix []struct {
                                task   model.TaskDefinition
                                result model.TaskResult
                                index  int
                        }

                        // Find failed tasks in this phase that need fixing
                        for i := len(results) - len(phase.Tasks); i &lt; len(results); i++ </span><span class="cov0" title="0">{
                                res := results[i]
                                if res.Status == model.StatusFail </span><span class="cov0" title="0">{
                                        // Find the corresponding task definition
                                        for _, task := range phase.Tasks </span><span class="cov0" title="0">{
                                                if task.ID == res.ID &amp;&amp; task.FixType == "auto" &amp;&amp; task.FixCommand != "" </span><span class="cov0" title="0">{
                                                        tasksToFix = append(tasksToFix, struct {
                                                                task   model.TaskDefinition
                                                                result model.TaskResult
                                                                index  int
                                                        }{task, res, i})
                                                        break</span>
                                                }
                                        }
                                }
                        }
                        <span class="cov0" title="0">resultsMu.Unlock()

                        // Run fixes in parallel (same as original tasks)
                        if len(tasksToFix) &gt; 0 </span><span class="cov0" title="0">{
                                fixGroup := new(errgroup.Group)
                                fixGroup.SetLimit(10)

                                for _, item := range tasksToFix </span><span class="cov0" title="0">{
                                        task := item.task
                                        resultIndex := item.index
                                        originalResult := item.result

                                        fixGroup.Go(func() error </span><span class="cov0" title="0">{
                                                // Open log file to append fix output
                                                logFile, err := os.OpenFile(originalResult.LogPath, os.O_APPEND|os.O_WRONLY, 0644)
                                                if err != nil </span><span class="cov0" title="0">{
                                                        fmt.Fprintf(os.Stderr, "ERROR: cannot open log file %s: %v\n", originalResult.LogPath, err)
                                                        return nil
                                                }</span>
                                                <span class="cov0" title="0">defer logFile.Close()

                                                // Run fix command and time it
                                                fixCmd := exec.Command("sh", "-c", task.FixCommand)
                                                fixCmd.Dir = task.Workdir
                                                fixStart := time.Now()

                                                // Capture output and write to log
                                                fixCmd.Stdout = logFile
                                                fixCmd.Stderr = logFile

                                                // Write separator to log
                                                fmt.Fprintf(logFile, "\n--- Auto-fix: %s ---\n", task.FixCommand)

                                                fixErr := fixCmd.Run()
                                                fixDuration := time.Since(fixStart)

                                                // Show fix message with timing
                                                if tracker != nil </span><span class="cov0" title="0">{
                                                        tracker.UpdateTask(task.ID, "FIXING", 0)
                                                }</span> else<span class="cov0" title="0"> {
                                                        fmt.Printf("[%-15s] ðŸ”§ %s (%dms)\n", task.ID, renderer.Blue("Auto-fixing: "+task.FixCommand), fixDuration.Milliseconds())
                                                }</span>

                                                <span class="cov0" title="0">if fixErr != nil </span><span class="cov0" title="0">{
                                                        // Fix failed
                                                        if tracker != nil </span><span class="cov0" title="0">{
                                                                tracker.UpdateTask(task.ID, "FIX FAILED", 0)
                                                        }</span> else<span class="cov0" title="0"> {
                                                                fmt.Printf("[%-15s] âŒ %s\n", task.ID, renderer.Red("Failed to fix"))
                                                        }</span>
                                                        <span class="cov0" title="0">return nil</span> // Don't stop other fixes
                                                }

                                                // Fix succeeded, re-run original check
                                                <span class="cov0" title="0">if tracker != nil </span><span class="cov0" title="0">{
                                                        tracker.UpdateTask(task.ID, "RE-CHECKING", 0)
                                                }</span> else<span class="cov0" title="0"> {
                                                        fmt.Printf("[%-15s] âœ… %s\n", task.ID, renderer.Green("Fix succeeded, re-checking..."))
                                                }</span>

                                                // Write separator to log
                                                <span class="cov0" title="0">fmt.Fprintf(logFile, "\n--- Re-check: %s ---\n", task.Command)

                                                // Re-run original command
                                                recheckCmd := exec.Command("sh", "-c", task.Command)
                                                recheckCmd.Dir = task.Workdir
                                                recheckCmd.Stdout = logFile
                                                recheckCmd.Stderr = logFile
                                                recheckStart := time.Now()
                                                recheckErr := recheckCmd.Run()
                                                recheckDuration := time.Since(recheckStart)

                                                // Calculate total time: original check + fix + recheck
                                                totalDuration := time.Duration(originalResult.DurationMs)*time.Millisecond + fixDuration + recheckDuration

                                                // Update result
                                                resultsMu.Lock()
                                                if recheckErr == nil </span><span class="cov0" title="0">{
                                                        // Fixed!
                                                        results[resultIndex].Status = model.StatusPass
                                                        exitCode := 0
                                                        results[resultIndex].ExitCode = &amp;exitCode
                                                        results[resultIndex].DurationMs = totalDuration.Milliseconds()
                                                        results[resultIndex].AutoFixed = true
                                                        results[resultIndex].FixCommand = task.FixCommand
                                                        results[resultIndex].InitialExitCode = originalResult.ExitCode
                                                        results[resultIndex].FixDurationMs = fixDuration.Milliseconds()
                                                        results[resultIndex].RecheckDurationMs = recheckDuration.Milliseconds()

                                                        // Update phase failure status
                                                        phaseFailMu.Lock()
                                                        // Recount failures in this phase
                                                        phaseStillFailed := false
                                                        for i := len(results) - len(phase.Tasks); i &lt; len(results); i++ </span><span class="cov0" title="0">{
                                                                if results[i].Status == model.StatusFail </span><span class="cov0" title="0">{
                                                                        phaseStillFailed = true
                                                                        break</span>
                                                                }
                                                        }
                                                        <span class="cov0" title="0">phaseFailed = phaseStillFailed
                                                        if !phaseStillFailed </span><span class="cov0" title="0">{
                                                                anyFailed = false
                                                                overallExitCode = 0
                                                        }</span>
                                                        <span class="cov0" title="0">phaseFailMu.Unlock()

                                                        if tracker != nil </span><span class="cov0" title="0">{
                                                                tracker.UpdateTask(task.ID, "PASS", recheckDuration.Seconds())
                                                        }</span> else<span class="cov0" title="0"> {
                                                                fmt.Printf("[%-15s] âœ… %s (%dms)\n", task.ID, renderer.Green("PASS"), recheckDuration.Milliseconds())
                                                        }</span>
                                                } else<span class="cov0" title="0"> {
                                                        // Still failing after fix
                                                        results[resultIndex].DurationMs = totalDuration.Milliseconds()
                                                        results[resultIndex].FixCommand = task.FixCommand
                                                        results[resultIndex].InitialExitCode = originalResult.ExitCode
                                                        results[resultIndex].FixDurationMs = fixDuration.Milliseconds()
                                                        results[resultIndex].RecheckDurationMs = recheckDuration.Milliseconds()
                                                        if tracker != nil </span><span class="cov0" title="0">{
                                                                tracker.UpdateTask(task.ID, "STILL FAILING", recheckDuration.Seconds())
                                                        }</span> else<span class="cov0" title="0"> {
                                                                fmt.Printf("[%-15s] âŒ %s\n", task.ID, renderer.Red("Still failing after fix"))
                                                        }</span>
                                                }
                                                <span class="cov0" title="0">resultsMu.Unlock()

                                                return nil</span>
                                        })
                                }

                                <span class="cov0" title="0">fixGroup.Wait()</span>
                        }

                        // Show helper messages for failed tasks with fixType="helper"
                        <span class="cov0" title="0">resultsMu.Lock()
                        for i := len(results) - len(phase.Tasks); i &lt; len(results); i++ </span><span class="cov0" title="0">{
                                res := results[i]
                                if res.Status == model.StatusFail </span><span class="cov0" title="0">{
                                        for _, task := range phase.Tasks </span><span class="cov0" title="0">{
                                                if task.ID == res.ID &amp;&amp; task.FixType == "helper" &amp;&amp; task.FixCommand != "" </span><span class="cov0" title="0">{
                                                        if tracker == nil </span><span class="cov0" title="0">{
                                                                fmt.Printf("[%-15s] ðŸ’¡ %s\n", task.ID, renderer.Yellow("To fix run: "+task.FixCommand))
                                                        }</span>
                                                        <span class="cov0" title="0">break</span>
                                                }
                                        }
                                }
                        }
                        <span class="cov0" title="0">resultsMu.Unlock()</span>
                }

                // If phase failed and fail-fast is enabled, stop
                <span class="cov0" title="0">phaseFailMu.Lock()
                shouldStop := phaseFailed &amp;&amp; flagFailFast
                phaseFailMu.Unlock()

                if shouldStop </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        // Calculate total pipeline duration BEFORE the pause
        <span class="cov0" title="0">pipelineDuration := time.Since(pipelineStart)
        totalMs := pipelineDuration.Milliseconds()

        // Stop animation if it was running
        if tracker != nil </span><span class="cov0" title="0">{
                // Do a final render to show completed state
                time.Sleep(100 * time.Millisecond)

                tracker.Stop()

                // Show completion message and wait for user input
                fmt.Print(renderer.Green("âœ“ Done") + " - Press Enter to continue...")

                // Wait for Enter key
                fmt.Scanln()
        }</span>

        // Render summary
        <span class="cov0" title="0">var summaries []ui.TaskSummary
        for _, r := range results </span><span class="cov0" title="0">{
                summaries = append(summaries, ui.TaskSummary{
                        ID:         r.ID,
                        Status:     string(r.Status),
                        DurationMs: r.DurationMs,
                        AutoFixed:  r.AutoFixed,
                })
        }</span>
        <span class="cov0" title="0">renderer.RenderSummary(summaries, anyFailed, totalMs)

        // Show where to find logs and reports
        fmt.Println()
        fmt.Printf("ðŸ“ Run logs:  %s\n", filepath.Join(outputRoot, "runs", runID, "logs"))
        fmt.Printf("ðŸ“Š Dashboard: %s\n", filepath.Join(outputRoot, "report.html"))

        // Build effective config tracking
        effectiveConfig := buildEffectiveConfig(cfg, &amp;mergedCfg, flagSince, flagUI, uiModeStr, gitMode, gitRef, historicalAvg)

        // Determine the actual config path used
        actualConfigPath := flagConfig
        if actualConfigPath == "" </span><span class="cov0" title="0">{
                // Check if default config.toml exists
                if _, err := os.Stat("config.toml"); err == nil </span><span class="cov0" title="0">{
                        actualConfigPath = "config.toml"
                }</span>
        }

        // Write run record and generate dashboard
        <span class="cov0" title="0">runRecord := model.RunRecord{
                RunID:           runID,
                Timestamp:       time.Now().UTC().Format(time.RFC3339),
                RepoRoot:        repoRoot,
                OutputRoot:      outputRoot,
                ConfigPath:      actualConfigPath,
                Command:         buildCommandString(),
                PipelineVersion: version, // Version used to run the pipeline
                Git:             gitInfo,
                Flags: model.RunFlags{
                        Fast:     flagFast,
                        FailFast: flagFailFast,
                        DryRun:   flagDryRun,
                        Verbose:  flagVerbose,
                        Only:     flagOnly,
                        Skip:     flagSkipVals,
                        Config:   flagConfig,
                        Since:    flagSince,
                },
                Tasks:           results,
                EffectiveConfig: effectiveConfig,
        }
        if err := writeRunJSON(runDir, runRecord); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "WARNING: failed to write run record: %v\n", err)
        }</span>

        // Copy config file to run directory
        <span class="cov0" title="0">if err := copyConfigToRun(runDir, flagConfig, &amp;mergedCfg); err != nil </span><span class="cov0" title="0">{
                if flagVerbose </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "WARNING: failed to copy config: %v\n", err)
                }</span>
        }

        // Generate dashboard (only generate report for current run)
        <span class="cov0" title="0">if err := dashboard.GenerateDashboardWithOptions(outputRoot, version, false, runID); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "WARNING: failed to generate dashboard: %v\n", err)
        }</span>

        // Final cursor restoration (belt and suspenders)
        <span class="cov0" title="0">fmt.Print("\033[?25h")

        os.Exit(overallExitCode)</span>
}

// loadHistoricalAverages loads task averages from the dashboard summary
func loadHistoricalAverages(outputRoot string) map[string]int <span class="cov3" title="4">{
        averages := make(map[string]int)

        summaryPath := filepath.Join(outputRoot, "summary.json")
        data, err := os.ReadFile(summaryPath)
        if err != nil </span><span class="cov1" title="1">{
                return averages // No history yet
        }</span>

        <span class="cov3" title="3">var summary struct {
                TaskStats map[string]struct {
                        AvgDuration float64 `json:"avgDuration"`
                } `json:"taskStats"`
        }

        if err := json.Unmarshal(data, &amp;summary); err != nil </span><span class="cov0" title="0">{
                return averages
        }</span>

        // Convert milliseconds to seconds
        <span class="cov3" title="3">for taskID, stats := range summary.TaskStats </span><span class="cov4" title="5">{
                if stats.AvgDuration &gt; 0 </span><span class="cov3" title="4">{
                        avgSeconds := int(stats.AvgDuration / 1000)
                        if avgSeconds &lt; 1 </span><span class="cov1" title="1">{
                                avgSeconds = 1
                        }</span>
                        <span class="cov3" title="4">averages[taskID] = avgSeconds</span>
                }
        }

        <span class="cov3" title="3">return averages</span>
}

func buildCommandString() string <span class="cov1" title="1">{
        // Build command line from os.Args
        cmdLine := ""
        for i, arg := range os.Args </span><span class="cov4" title="7">{
                if i &gt; 0 </span><span class="cov4" title="6">{
                        cmdLine += " "
                }</span>
                // Quote arguments that contain spaces
                <span class="cov4" title="7">if len(arg) &gt; 0 &amp;&amp; (arg[0] == '-' || !containsSpace(arg)) </span><span class="cov4" title="7">{
                        cmdLine += arg
                }</span> else<span class="cov0" title="0"> {
                        cmdLine += `"` + arg + `"`
                }</span>
        }

        <span class="cov1" title="1">return cmdLine</span>
}

func containsSpace(s string) bool <span class="cov4" title="6">{
        for _, c := range s </span><span class="cov10" title="124">{
                if c == ' ' </span><span class="cov2" title="2">{
                        return true
                }</span>
        }
        <span class="cov3" title="4">return false</span>
}

// buildEffectiveConfig creates a detailed breakdown of configuration values and their sources
func buildEffectiveConfig(cfg *config.Config, mergedCfg *config.Config, flagSince, flagUI, uiModeStr, gitMode, gitRef string, _ map[string]int) *model.EffectiveConfig <span class="cov2" title="2">{
        defaults := config.GetDefaults()
        var values []model.ConfigValue

        // Helper to add a config value
        addValue := func(key, value, source, overrode string) </span><span class="cov6" title="16">{
                values = append(values, model.ConfigValue{
                        Key:      key,
                        Value:    value,
                        Source:   source,
                        Overrode: overrode,
                })
        }</span>

        // Output Root
        <span class="cov2" title="2">if cfg != nil &amp;&amp; cfg.Defaults.OutputRoot != "" </span><span class="cov2" title="2">{
                addValue("defaults.outputRoot", mergedCfg.Defaults.OutputRoot, "config-file", "")
        }</span> else<span class="cov0" title="0"> {
                addValue("defaults.outputRoot", mergedCfg.Defaults.OutputRoot, "default", "")
        }</span>

        // Fast Threshold
        <span class="cov2" title="2">if cfg != nil &amp;&amp; cfg.Defaults.FastThreshold != 0 </span><span class="cov2" title="2">{
                addValue("defaults.fastThreshold", fmt.Sprintf("%d", mergedCfg.Defaults.FastThreshold), "config-file", "")
        }</span> else<span class="cov0" title="0"> {
                addValue("defaults.fastThreshold", fmt.Sprintf("%d", mergedCfg.Defaults.FastThreshold), "default", "")
        }</span>

        // UI Mode
        <span class="cov2" title="2">var uiSource, uiOverrode string
        if flagUI != "basic" </span><span class="cov1" title="1">{
                uiSource = "cli-flag"
                if cfg != nil &amp;&amp; cfg.Defaults.UIMode != "" </span><span class="cov1" title="1">{
                        uiOverrode = cfg.Defaults.UIMode
                }</span> else<span class="cov0" title="0"> {
                        uiOverrode = defaults.Defaults.UIMode
                }</span>
        } else<span class="cov1" title="1"> if cfg != nil &amp;&amp; cfg.Defaults.UIMode != "" </span><span class="cov1" title="1">{
                uiSource = "config-file"
        }</span> else<span class="cov0" title="0"> {
                uiSource = "default"
        }</span>
        <span class="cov2" title="2">addValue("defaults.uiMode", uiModeStr, uiSource, uiOverrode)

        // Animation Refresh
        if cfg != nil &amp;&amp; cfg.Defaults.AnimationRefreshMs != 0 </span><span class="cov2" title="2">{
                addValue("defaults.animationRefreshMs", fmt.Sprintf("%d", mergedCfg.Defaults.AnimationRefreshMs), "config-file", "")
        }</span> else<span class="cov0" title="0"> {
                addValue("defaults.animationRefreshMs", fmt.Sprintf("%d", mergedCfg.Defaults.AnimationRefreshMs), "default", "")
        }</span>

        // Git Mode
        <span class="cov2" title="2">var gitModeSource, gitModeOverrode string
        if flagSince != "" </span><span class="cov1" title="1">{
                gitModeSource = "cli-flag"
                if cfg != nil &amp;&amp; cfg.Defaults.Git.Mode != "" </span><span class="cov1" title="1">{
                        gitModeOverrode = cfg.Defaults.Git.Mode
                }</span> else<span class="cov0" title="0"> {
                        gitModeOverrode = defaults.Defaults.Git.Mode
                }</span>
        } else<span class="cov1" title="1"> if cfg != nil &amp;&amp; cfg.Defaults.Git.Mode != "" </span><span class="cov1" title="1">{
                gitModeSource = "config-file"
        }</span> else<span class="cov0" title="0"> {
                gitModeSource = "default"
        }</span>
        <span class="cov2" title="2">addValue("defaults.git.mode", gitMode, gitModeSource, gitModeOverrode)

        // Git Ref
        var gitRefSource, gitRefOverrode string
        if flagSince != "" </span><span class="cov1" title="1">{
                gitRefSource = "cli-flag"
                if cfg != nil &amp;&amp; cfg.Defaults.Git.Ref != "" </span><span class="cov1" title="1">{
                        gitRefOverrode = cfg.Defaults.Git.Ref
                }</span> else<span class="cov0" title="0"> {
                        gitRefOverrode = defaults.Defaults.Git.Ref
                }</span>
        } else<span class="cov1" title="1"> if cfg != nil &amp;&amp; cfg.Defaults.Git.Ref != "" </span><span class="cov1" title="1">{
                gitRefSource = "config-file"
        }</span> else<span class="cov0" title="0"> {
                gitRefSource = "default"
        }</span>
        <span class="cov2" title="2">addValue("defaults.git.ref", gitRef, gitRefSource, gitRefOverrode)

        // Task Defaults
        if cfg != nil &amp;&amp; cfg.TaskDefaults.Enabled != nil </span><span class="cov2" title="2">{
                addValue("task_defaults.enabled", fmt.Sprintf("%t", *mergedCfg.TaskDefaults.Enabled), "config-file", "")
        }</span> else<span class="cov0" title="0"> {
                addValue("task_defaults.enabled", fmt.Sprintf("%t", *mergedCfg.TaskDefaults.Enabled), "default", "")
        }</span>

        <span class="cov2" title="2">if cfg != nil &amp;&amp; cfg.TaskDefaults.Workdir != "" </span><span class="cov2" title="2">{
                addValue("task_defaults.workdir", mergedCfg.TaskDefaults.Workdir, "config-file", "")
        }</span> else<span class="cov0" title="0"> {
                addValue("task_defaults.workdir", mergedCfg.TaskDefaults.Workdir, "default", "")
        }</span>

        <span class="cov2" title="2">return &amp;model.EffectiveConfig{
                Values: values,
        }</span>
}

// Phase represents a group of tasks that can run in parallel
type Phase struct {
        Tasks []model.TaskDefinition
        Name  string // Display name for the phase
}

// groupTasksIntoPhases splits tasks into phases based on wait markers
func groupTasksIntoPhases(tasks []model.TaskDefinition, phaseNames map[string]config.PhaseInfo) []Phase <span class="cov3" title="4">{
        if len(tasks) == 0 </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov3" title="3">var phases []Phase
        currentPhase := Phase{Tasks: []model.TaskDefinition{}}
        phaseNum := 1

        for _, task := range tasks </span><span class="cov5" title="9">{
                currentPhase.Tasks = append(currentPhase.Tasks, task)

                // If this task has wait=true, end the current phase
                if task.Wait </span><span class="cov2" title="2">{
                        // Set phase name from phaseNames map, or default to "Phase N"
                        phaseKey := "wait-" + fmt.Sprintf("%d", phaseNum)
                        if info, ok := phaseNames[phaseKey]; ok &amp;&amp; info.Name != "" </span><span class="cov0" title="0">{
                                currentPhase.Name = info.Name
                        }</span> else<span class="cov2" title="2"> {
                                currentPhase.Name = fmt.Sprintf("Phase %d", phaseNum)
                        }</span>

                        <span class="cov2" title="2">phases = append(phases, currentPhase)
                        currentPhase = Phase{Tasks: []model.TaskDefinition{}}
                        phaseNum++</span>
                }
        }

        // Add remaining tasks as final phase
        <span class="cov3" title="3">if len(currentPhase.Tasks) &gt; 0 </span><span class="cov3" title="3">{
                // Set phase name for the last phase
                phaseKey := "wait-" + fmt.Sprintf("%d", phaseNum)
                if info, ok := phaseNames[phaseKey]; ok &amp;&amp; info.Name != "" </span><span class="cov0" title="0">{
                        currentPhase.Name = info.Name
                }</span> else<span class="cov3" title="3"> {
                        currentPhase.Name = fmt.Sprintf("Phase %d", phaseNum)
                }</span>
                <span class="cov3" title="3">phases = append(phases, currentPhase)</span>
        }

        <span class="cov3" title="3">return phases</span>
}

func filterTasks(tasks []model.TaskDefinition, only string, skip sliceFlag, _ bool, _ int, verbose bool) []model.TaskDefinition <span class="cov4" title="7">{
        skipSet := map[string]struct{}{}
        for _, id := range skip </span><span class="cov2" title="2">{
                skipSet[id] = struct{}{}
        }</span>

        <span class="cov4" title="7">var out []model.TaskDefinition
        if only != "" </span><span class="cov4" title="5">{
                // Parse comma-separated list from --only
                rawIDs := strings.Split(only, ",")
                var requested []string
                seen := make(map[string]struct{})
                for _, raw := range rawIDs </span><span class="cov5" title="10">{
                        id := strings.TrimSpace(raw)
                        if id == "" </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov5" title="10">if _, dup := seen[id]; dup </span><span class="cov1" title="1">{
                                continue</span>
                        }
                        <span class="cov5" title="9">seen[id] = struct{}{}
                        requested = append(requested, id)</span>
                }

                // Index tasks by ID for validation
                <span class="cov4" title="5">taskIndex := make(map[string]model.TaskDefinition, len(tasks))
                for _, s := range tasks </span><span class="cov5" title="13">{
                        taskIndex[s.ID] = s
                }</span>

                // Validate all requested IDs exist
                <span class="cov4" title="5">for _, id := range requested </span><span class="cov5" title="9">{
                        if _, ok := taskIndex[id]; !ok </span><span class="cov1" title="1">{
                                fmt.Fprintf(os.Stderr, "ERROR: --only task id %q not found\n", id)
                                os.Exit(1)
                        }</span>
                }

                // Build a set of requested IDs to filter by, then
                // walk the full task list in pipeline order and
                // keep only requested tasks that are not skipped.
                <span class="cov3" title="4">requestedSet := make(map[string]struct{}, len(requested))
                for _, id := range requested </span><span class="cov4" title="8">{
                        requestedSet[id] = struct{}{}
                }</span>

                <span class="cov3" title="4">for _, s := range tasks </span><span class="cov5" title="12">{
                        if _, want := requestedSet[s.ID]; !want </span><span class="cov3" title="4">{
                                continue</span>
                        }
                        <span class="cov4" title="8">if _, skip := skipSet[s.ID]; skip </span><span class="cov1" title="1">{
                                if verbose </span><span class="cov0" title="0">{
                                        fmt.Printf("[%-15s] SKIP requested by --skip\n", s.ID)
                                }</span>
                                <span class="cov1" title="1">continue</span>
                        }
                        <span class="cov4" title="7">out = append(out, s)</span>
                }

                <span class="cov3" title="4">return out</span>
        }

        <span class="cov2" title="2">for _, s := range tasks </span><span class="cov4" title="6">{
                if _, ok := skipSet[s.ID]; ok </span><span class="cov1" title="1">{
                        if verbose </span><span class="cov0" title="0">{
                                fmt.Printf("[%-15s] SKIP requested by --skip\n", s.ID)
                        }</span>
                        <span class="cov1" title="1">continue</span>
                }
                <span class="cov4" title="5">out = append(out, s)</span>
        }
        <span class="cov2" title="2">return out</span>
}

func makeRunID() string <span class="cov1" title="1">{
        now := time.Now().UTC()
        ts := now.Format("2006-01-02T15-04-05Z")
        // Use PID for uniqueness instead of deprecated rand.Seed
        suffix := os.Getpid() % 1_000_000
        return fmt.Sprintf("%s_%06d", ts, suffix)
}</span>

func runTask(st model.TaskDefinition, runDir, logDir string, dryRun bool, verbose bool, renderer *ui.Renderer, tracker *ui.AnimatedTaskTracker, outputMu *sync.Mutex, waitForPrev chan struct{}, taskDone chan struct{}) (model.TaskResult, *bytes.Buffer, error) <span class="cov1" title="1">{
        res := model.TaskResult{
                ID:               st.ID,
                Name:             st.Name,
                Desc:             st.Desc,
                Phase:            st.Phase,
                Type:             st.Type,
                Status:           model.StatusPending,
                Command:          st.Command,
                Workdir:          st.Workdir,
                LogPath:          "",
                EstimatedSeconds: st.EstimatedSeconds,
        }

        // Create a buffer to capture all output for this task
        var taskOutputBuffer bytes.Buffer

        logPath := filepath.Join(logDir, fmt.Sprintf("%s.log", st.ID))
        res.LogPath = logPath

        if dryRun </span><span class="cov1" title="1">{
                res.Status = model.StatusSkipped
                res.Skipped = true
                res.SkipReason = "dry-run"
                // Don't render anything yet - will be shown when displayed
                return res, &amp;taskOutputBuffer, nil
        }</span>

        // Wait for our turn to display output (non-animated mode only)
        <span class="cov0" title="0">if tracker == nil </span><span class="cov0" title="0">{
                // Wait for previous task to finish (if there is one)
                if waitForPrev != nil </span><span class="cov0" title="0">{
                        &lt;-waitForPrev
                }</span>

                // Now we can stream output
                <span class="cov0" title="0">if verbose </span><span class="cov0" title="0">{
                        fmt.Printf("[%-15s] %s    %s\n", st.ID, renderer.Blue("RUN"), st.Command)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("[%-15s] %s\n", st.ID, renderer.Blue("RUN"))
                }</span>
        } else<span class="cov0" title="0"> {
                // Animated mode: buffer the RUN message with a blank line before it
                renderer.RenderTaskStart(st.ID, st.Command, verbose)
                taskOutputBuffer.WriteString("\n") // Blank line before task
                if verbose </span><span class="cov0" title="0">{
                        taskOutputBuffer.WriteString(fmt.Sprintf("[%-15s] %s    %s\n", st.ID, renderer.Blue("RUN"), st.Command))
                }</span> else<span class="cov0" title="0"> {
                        taskOutputBuffer.WriteString(fmt.Sprintf("[%-15s] %s\n", st.ID, renderer.Blue("RUN")))
                }</span>
        }

        <span class="cov0" title="0">start := time.Now().UTC()
        res.StartTime = start.Format(time.RFC3339)
        res.Status = model.StatusRunning

        // Update tracker if animated
        if tracker != nil </span><span class="cov0" title="0">{
                tracker.UpdateTask(st.ID, "RUNNING", 0)
        }</span>

        <span class="cov0" title="0">logFile, err := os.Create(logPath)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "ERROR: cannot create log file %s: %v\n", logPath, err)
                res.Status = model.StatusFail
                return res, &amp;taskOutputBuffer, err
        }</span>
        <span class="cov0" title="0">defer logFile.Close()

        cmd := exec.Command("sh", "-c", st.Command)
        cmd.Dir = st.Workdir
        cmd.Env = append(os.Environ(), "FORCE_COLOR=1")

        // Setup output handling
        var bufferMu sync.Mutex

        if tracker != nil </span><span class="cov0" title="0">{
                // Animated mode: buffer output for sequential display
                stdoutWriter := &amp;lineWriter{taskID: st.ID, file: logFile, outputBuffer: &amp;taskOutputBuffer, mu: &amp;bufferMu, renderer: renderer}
                stderrWriter := &amp;lineWriter{taskID: st.ID, file: logFile, outputBuffer: &amp;taskOutputBuffer, mu: &amp;bufferMu, renderer: renderer}
                cmd.Stdout = stdoutWriter
                cmd.Stderr = stderrWriter
        }</span> else<span class="cov0" title="0"> {
                // Non-animated mode: stream output directly (we already have the turn)
                stdoutWriter := &amp;lineWriter{taskID: st.ID, file: logFile, console: os.Stdout, renderer: renderer}
                stderrWriter := &amp;lineWriter{taskID: st.ID, file: logFile, console: os.Stderr, renderer: renderer}
                cmd.Stdout = stdoutWriter
                cmd.Stderr = stderrWriter
        }</span>

        // Start ticker to update progress during execution
        <span class="cov0" title="0">var tickerDone chan struct{}
        if tracker != nil </span><span class="cov0" title="0">{
                tickerDone = make(chan struct{})
                go func() </span><span class="cov0" title="0">{
                        ticker := time.NewTicker(100 * time.Millisecond)
                        defer ticker.Stop()
                        startTime := time.Now()

                        for </span><span class="cov0" title="0">{
                                select </span>{
                                case &lt;-tickerDone:<span class="cov0" title="0">
                                        return</span>
                                case &lt;-ticker.C:<span class="cov0" title="0">
                                        elapsed := time.Since(startTime).Seconds()
                                        tracker.UpdateTask(st.ID, "RUNNING", elapsed)</span>
                                }
                        }
                }()
        }

        <span class="cov0" title="0">err = cmd.Run()

        // Stop ticker
        if tickerDone != nil </span><span class="cov0" title="0">{
                close(tickerDone)
        }</span>

        <span class="cov0" title="0">end := time.Now().UTC()
        res.EndTime = end.Format(time.RFC3339)
        res.DurationMs = end.Sub(start).Milliseconds()
        elapsed := end.Sub(start).Seconds()

        exitCode := 0
        if err != nil </span><span class="cov0" title="0">{
                var ee *exec.ExitError
                if errors.As(err, &amp;ee) </span><span class="cov0" title="0">{
                        exitCode = ee.ExitCode()
                }</span> else<span class="cov0" title="0"> {
                        exitCode = 1
                }</span>
                <span class="cov0" title="0">res.Status = model.StatusFail
                res.ExitCode = &amp;exitCode

                // Parse metrics even on failure (especially useful for SARIF/JUnit)
                // This allows us to show what failed in the dashboard
                if st.MetricsFormat != "" &amp;&amp; st.MetricsPath != "" </span><span class="cov0" title="0">{
                        renderer.Verbose(verbose, "%s Task failed, but attempting to parse metrics: format=%s, path=%s", st.ID, st.MetricsFormat, st.MetricsPath)
                        res.Metrics = parseTaskMetrics(st, verbose)
                        if res.Metrics != nil </span><span class="cov0" title="0">{
                                renderer.Verbose(verbose, "%s Metrics parsed successfully despite failure: %+v", st.ID, res.Metrics.Data)
                        }</span>
                }

                // Update tracker with final status
                <span class="cov0" title="0">if tracker != nil </span><span class="cov0" title="0">{
                        tracker.UpdateTask(st.ID, "FAIL", elapsed)
                        renderer.RenderTaskComplete(st.ID, string(res.Status), &amp;exitCode, res.DurationMs, verbose)

                        // Also buffer the failure message for the output section
                        taskOutputBuffer.WriteString(fmt.Sprintf("[%-15s] âœ— %s (%dms)\n", st.ID, renderer.Red("FAIL"), res.DurationMs))
                }</span> else<span class="cov0" title="0"> {
                        // Stream the failure message with color
                        fmt.Printf("[%-15s] âœ— %s (%dms)\n\n", st.ID, renderer.Red("FAIL"), res.DurationMs)

                        // Signal that this task is done streaming
                        close(taskDone)
                }</span>
                <span class="cov0" title="0">return res, &amp;taskOutputBuffer, err</span>
        }

        <span class="cov0" title="0">res.Status = model.StatusPass
        res.ExitCode = &amp;exitCode

        // Parse metrics if configured
        if st.MetricsFormat != "" &amp;&amp; st.MetricsPath != "" </span><span class="cov0" title="0">{
                renderer.Verbose(verbose, "%s Parsing metrics: format=%s, path=%s", st.ID, st.MetricsFormat, st.MetricsPath)
                res.Metrics = parseTaskMetrics(st, verbose)
                if res.Metrics != nil </span><span class="cov0" title="0">{
                        renderer.Verbose(verbose, "%s Metrics parsed successfully: %+v", st.ID, res.Metrics.Data)
                }</span>
                // Metrics parsing failed - this means either:
                // 1. File doesn't exist (will be caught below)
                // 2. Invalid format (error already printed)
                // 3. Parse error (error already printed)
                // We'll fail the task below if file is missing/empty, or here if it's a parse/format error

                // Validate artifact if metrics path specified
                // Handle both absolute and relative paths
                <span class="cov0" title="0">var artifactPath string
                if filepath.IsAbs(st.MetricsPath) </span><span class="cov0" title="0">{
                        artifactPath = st.MetricsPath
                }</span> else<span class="cov0" title="0"> {
                        artifactPath = filepath.Join(st.Workdir, st.MetricsPath)
                }</span>
                <span class="cov0" title="0">if info, err := os.Stat(artifactPath); err != nil || info.Size() == 0 </span><span class="cov0" title="0">{
                        // Artifact missing or empty - fail the task
                        res.Status = model.StatusFail
                        if err != nil </span><span class="cov0" title="0">{
                                // Always show this error (not just in verbose)
                                fmt.Fprintf(os.Stderr, "[%-15s] âŒ ERROR: Metrics file not found: %s\n", st.ID, st.MetricsPath)
                                renderer.Verbose(verbose, "%s Full path: %s", st.ID, artifactPath)
                        }</span> else<span class="cov0" title="0"> {
                                // Always show this error (not just in verbose)
                                fmt.Fprintf(os.Stderr, "[%-15s] âŒ ERROR: Metrics file is empty: %s\n", st.ID, st.MetricsPath)
                                renderer.Verbose(verbose, "%s Full path: %s", st.ID, artifactPath)
                        }</span>
                } else<span class="cov0" title="0"> if res.Metrics == nil </span><span class="cov0" title="0">{
                        // File exists but metrics parsing failed (invalid format or parse error)
                        res.Status = model.StatusFail
                        // Error already printed by parseTaskMetrics
                        renderer.Verbose(verbose, "%s Metrics validation FAILED: file exists but parsing failed", st.ID)
                }</span> else<span class="cov0" title="0"> {
                        // Artifact exists, has size, and metrics parsed successfully
                        res.Metrics.Data["path"] = artifactPath
                        res.Metrics.Data["size"] = info.Size()

                        renderer.Verbose(verbose, "%s Artifact validation PASSED: %s (%d bytes)", st.ID, artifactPath, info.Size())

                        // Copy artifact to run directory for historical preservation
                        artifactsDir := filepath.Join(runDir, "artifacts")
                        if err := os.MkdirAll(artifactsDir, 0755); err != nil </span><span class="cov0" title="0">{
                                renderer.Verbose(verbose, "%s Failed to create artifacts directory: %v", st.ID, err)
                        }</span> else<span class="cov0" title="0"> {
                                // Determine destination path based on whether source is absolute or relative
                                var destPath string
                                if filepath.IsAbs(st.MetricsPath) </span><span class="cov0" title="0">{
                                        // For absolute paths, store under task ID with full path to avoid conflicts
                                        // e.g., /foo/bar/file.xml -&gt; artifacts/&lt;task-id&gt;/foo/bar/file.xml
                                        destPath = filepath.Join(artifactsDir, st.ID, st.MetricsPath)
                                }</span> else<span class="cov0" title="0"> {
                                        // For relative paths, preserve directory structure
                                        destPath = filepath.Join(artifactsDir, st.MetricsPath)
                                }</span>
                                <span class="cov0" title="0">destDir := filepath.Dir(destPath)
                                if err := os.MkdirAll(destDir, 0755); err != nil </span><span class="cov0" title="0">{
                                        renderer.Verbose(verbose, "%s Failed to create artifact subdirectory: %v", st.ID, err)
                                }</span> else<span class="cov0" title="0"> {
                                        // Copy the file
                                        if content, err := os.ReadFile(artifactPath); err != nil </span><span class="cov0" title="0">{
                                                renderer.Verbose(verbose, "%s Failed to read artifact for copying: %v", st.ID, err)
                                        }</span> else<span class="cov0" title="0"> if err := os.WriteFile(destPath, content, 0644); err != nil </span><span class="cov0" title="0">{
                                                renderer.Verbose(verbose, "%s Failed to copy artifact: %v", st.ID, err)
                                        }</span> else<span class="cov0" title="0"> {
                                                renderer.Verbose(verbose, "%s Artifact copied to: %s", st.ID, destPath)
                                        }</span>
                                }
                        }
                }
        } else<span class="cov0" title="0"> {
                renderer.Verbose(verbose, "%s No metrics configured (format=%s, path=%s)", st.ID, st.MetricsFormat, st.MetricsPath)
        }</span>

        // Update tracker with final status
        <span class="cov0" title="0">if tracker != nil </span><span class="cov0" title="0">{
                tracker.UpdateTask(st.ID, string(res.Status), elapsed)
                renderer.RenderTaskComplete(st.ID, string(res.Status), &amp;exitCode, res.DurationMs, verbose)

                // Also buffer the completion message for the output section
                symbol := "â€¢"
                var statusText string

                switch res.Status </span>{
                case model.StatusPass:<span class="cov0" title="0">
                        symbol = "âœ“"
                        statusText = renderer.Green(string(res.Status))</span>
                case model.StatusFail:<span class="cov0" title="0">
                        symbol = "âœ—"
                        statusText = renderer.Red(string(res.Status))</span>
                case model.StatusSkipped:<span class="cov0" title="0">
                        symbol = "âŠ˜"
                        statusText = renderer.Yellow(string(res.Status))</span>
                default:<span class="cov0" title="0">
                        statusText = string(res.Status)</span>
                }

                <span class="cov0" title="0">if verbose &amp;&amp; exitCode != 0 </span><span class="cov0" title="0">{
                        taskOutputBuffer.WriteString(fmt.Sprintf("[%-15s] %s %s (exit %d, %dms)\n", st.ID, symbol, statusText, exitCode, res.DurationMs))
                }</span> else<span class="cov0" title="0"> {
                        taskOutputBuffer.WriteString(fmt.Sprintf("[%-15s] %s %s (%dms)\n", st.ID, symbol, statusText, res.DurationMs))
                }</span>
        } else<span class="cov0" title="0"> {
                // Stream the completion message for non-animated mode with colors
                symbol := "â€¢"
                var statusText string

                switch res.Status </span>{
                case model.StatusPass:<span class="cov0" title="0">
                        symbol = "âœ“"
                        statusText = renderer.Green(string(res.Status))</span>
                case model.StatusFail:<span class="cov0" title="0">
                        symbol = "âœ—"
                        statusText = renderer.Red(string(res.Status))</span>
                case model.StatusSkipped:<span class="cov0" title="0">
                        symbol = "âŠ˜"
                        statusText = renderer.Yellow(string(res.Status))</span>
                default:<span class="cov0" title="0">
                        statusText = string(res.Status)</span>
                }

                <span class="cov0" title="0">if verbose &amp;&amp; exitCode != 0 </span><span class="cov0" title="0">{
                        fmt.Printf("[%-15s] %s %s (exit %d, %dms)\n", st.ID, symbol, statusText, exitCode, res.DurationMs)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("[%-15s] %s %s (%dms)\n", st.ID, symbol, statusText, res.DurationMs)
                }</span>
                <span class="cov0" title="0">fmt.Println() // Blank line after task

                // Signal that this task is done streaming
                close(taskDone)</span>
        }

        <span class="cov0" title="0">return res, &amp;taskOutputBuffer, nil</span>
}

func writeRunJSON(runDir string, record model.RunRecord) error <span class="cov1" title="1">{
        path := filepath.Join(runDir, "run.json")
        data, err := json.MarshalIndent(record, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">return os.WriteFile(path, data, 0o644)</span>
}

// parseTaskMetrics parses metrics for a completed task
func parseTaskMetrics(st model.TaskDefinition, verbose bool) *model.TaskMetrics <span class="cov2" title="2">{
        // Build full path to metrics file (handle both absolute and relative paths)
        var metricsPath string
        if filepath.IsAbs(st.MetricsPath) </span><span class="cov0" title="0">{
                metricsPath = st.MetricsPath
        }</span> else<span class="cov2" title="2"> {
                metricsPath = filepath.Join(st.Workdir, st.MetricsPath)
        }</span>

        // Check if file exists
        <span class="cov2" title="2">if _, err := os.Stat(metricsPath); os.IsNotExist(err) </span><span class="cov1" title="1">{
                if verbose </span><span class="cov1" title="1">{
                        fmt.Fprintf(os.Stderr, "[%-15s] Metrics file not found: %s\n", st.ID, metricsPath)
                }</span>
                <span class="cov1" title="1">return nil</span>
        }

        // Parse based on format
        <span class="cov1" title="1">switch st.MetricsFormat </span>{
        case "junit":<span class="cov1" title="1">
                m, err := metrics.ParseJUnitXML(metricsPath)
                if err != nil </span><span class="cov0" title="0">{
                        // Always show parse failures (not just in verbose mode)
                        fmt.Fprintf(os.Stderr, "[%-15s] âŒ ERROR: Failed to parse JUnit XML: %v\n", st.ID, err)
                        fmt.Fprintf(os.Stderr, "[%-15s]          File: %s\n", st.ID, st.MetricsPath)
                        return nil
                }</span>
                <span class="cov1" title="1">return m</span>
        case "sarif":<span class="cov0" title="0">
                m, err := metrics.ParseSARIF(metricsPath)
                if err != nil </span><span class="cov0" title="0">{
                        // Always show parse failures (not just in verbose mode)
                        fmt.Fprintf(os.Stderr, "[%-15s] âŒ ERROR: Failed to parse SARIF: %v\n", st.ID, err)
                        fmt.Fprintf(os.Stderr, "[%-15s]          File: %s\n", st.ID, st.MetricsPath)
                        return nil
                }</span>
                <span class="cov0" title="0">return m</span>
        case "artifact":<span class="cov0" title="0">
                // For artifact format, just verify file exists and has content (already done above)
                return &amp;model.TaskMetrics{
                        Kind:          "artifact",
                        SummaryFormat: "artifact",
                        Data: map[string]interface{}{
                                "path": metricsPath,
                        },
                }</span>
        default:<span class="cov0" title="0">
                // Unknown format - this is an error
                fmt.Fprintf(os.Stderr, "[%-15s] âŒ ERROR: Unknown metrics format: %s\n", st.ID, st.MetricsFormat)
                fmt.Fprintf(os.Stderr, "[%-15s]          Supported formats: junit, sarif, artifact\n", st.ID)
                return nil</span>
        }
}

// copyConfigToRun copies the config file to the run directory
func copyConfigToRun(runDir, configPath string, mergedCfg *config.Config) error <span class="cov2" title="2">{
        destPath := filepath.Join(runDir, "config.toml")

        // If no config path specified, try default location
        if configPath == "" </span><span class="cov0" title="0">{
                configPath = "config.toml"
        }</span>

        // If config file exists, copy it
        <span class="cov2" title="2">if _, err := os.Stat(configPath); err == nil </span><span class="cov1" title="1">{
                data, err := os.ReadFile(configPath)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov1" title="1">return os.WriteFile(destPath, data, 0644)</span>
        }

        // Otherwise, write the merged config as JSON (built-in + defaults)
        <span class="cov1" title="1">data, err := json.MarshalIndent(mergedCfg, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov1" title="1">return os.WriteFile(filepath.Join(runDir, "config.json"), data, 0644)</span>
}

// lineWriter captures output line by line and sends to tracker
type lineWriter struct {
        tracker      *ui.AnimatedTaskTracker
        taskID       string
        file         *os.File
        buffer       []byte
        outputBuffer *bytes.Buffer // Buffer all output until task completes
        mu           *sync.Mutex   // Protect outputBuffer
        console      *os.File      // For streaming output directly
        renderer     *ui.Renderer  // For colorizing output
}

func (w *lineWriter) Write(p []byte) (n int, err error) <span class="cov0" title="0">{
        // Write to log file (unprefixed)
        w.file.Write(p)

        // Add to buffer and extract complete lines
        w.buffer = append(w.buffer, p...)

        // Process complete lines
        for </span><span class="cov0" title="0">{
                idx := bytes.IndexByte(w.buffer, '\n')
                if idx == -1 </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">line := string(w.buffer[:idx])

                // Prefix line with task ID
                prefixedLine := fmt.Sprintf("[%-15s] %s", w.taskID, line)

                if w.tracker != nil </span><span class="cov0" title="0">{
                        w.tracker.AddLogLine(prefixedLine)
                }</span> else<span class="cov0" title="0"> if w.outputBuffer != nil </span><span class="cov0" title="0">{
                        // Buffer output for sequential display
                        w.mu.Lock()
                        w.outputBuffer.WriteString(prefixedLine)
                        w.outputBuffer.WriteString("\n")
                        w.mu.Unlock()
                }</span> else<span class="cov0" title="0"> if w.console != nil </span><span class="cov0" title="0">{
                        // Stream output directly
                        fmt.Fprintln(w.console, prefixedLine)
                }</span>

                <span class="cov0" title="0">w.buffer = w.buffer[idx+1:]</span>
        }

        <span class="cov0" title="0">return len(p), nil</span>
}

// printVersion prints version information
func printVersion() <span class="cov1" title="1">{
        fmt.Printf("devpipe version %s\n", version)
        fmt.Printf("  commit: %s\n", commit)
        fmt.Printf("  built: %s\n", buildDate)
        fmt.Printf("  go: %s\n", runtime.Version())
        fmt.Printf("  platform: %s/%s\n", runtime.GOOS, runtime.GOARCH)
}</span>

// printHelp prints usage information
func printHelp() <span class="cov1" title="1">{
        fmt.Println("devpipe - Fast, local pipeline runner")
        fmt.Println()
        fmt.Println("USAGE:")
        fmt.Println("  devpipe [flags]              Run the pipeline")
        fmt.Println("  devpipe list [--verbose]     List all tasks")
        fmt.Println("  devpipe validate [files...]  Validate config file(s)")
        fmt.Println("  devpipe generate-reports     Regenerate all reports with latest template")
        fmt.Println("  devpipe sarif [options] ...  View SARIF security scan results")
        fmt.Println("  devpipe version              Show version information")
        fmt.Println("  devpipe help                 Show this help")
        fmt.Println()
        fmt.Println("RUN FLAGS:")
        fmt.Println("  --config &lt;path&gt;       Path to config file (default: config.toml)")
        fmt.Println("  --since &lt;ref&gt;         Git ref to compare against (overrides config)")
        fmt.Println("  --only &lt;task-ids&gt;     Run only specific task(s) by id (comma-separated)")
        fmt.Println("  --skip &lt;task-id&gt;      Skip a task by id (can be specified multiple times)")
        fmt.Println("  --ui &lt;mode&gt;           UI mode: basic, full (default: basic)")
        fmt.Println("  --dashboard           Show dashboard with live progress")
        fmt.Println("  --fail-fast           Stop on first task failure")
        fmt.Println("  --fast                Skip long running tasks")
        fmt.Println("  --dry-run             Do not execute commands, simulate only")
        fmt.Println("  --verbose             Verbose logging")
        fmt.Println("  --no-color            Disable colored output")
        fmt.Println()
        fmt.Println("VALIDATE FLAGS:")
        fmt.Println("  --config &lt;path&gt;       Path to config file to validate (default: config.toml)")
        fmt.Println()
        fmt.Println("EXAMPLES:")
        fmt.Println("  devpipe                                    # Run pipeline with default config")
        fmt.Println("  devpipe --config config/custom.toml        # Run with custom config")
        fmt.Println("  devpipe --fast --fail-fast                 # Skip slow tasks, stop on failure")
        fmt.Println("  devpipe list                               # List all task IDs")
        fmt.Println("  devpipe list --verbose                     # List tasks in table format with details")
        fmt.Println("  devpipe validate                           # Validate default config.toml")
        fmt.Println("  devpipe validate config/*.toml             # Validate all configs in folder")
        fmt.Println("  devpipe generate-reports                   # Regenerate all reports with latest template")
        fmt.Println("  devpipe sarif tmp/codeql/results.sarif     # View CodeQL security scan results")
        fmt.Println("  devpipe sarif -s tmp/codeql/results.sarif  # Show summary of security issues")
        fmt.Println()
}</span>

// validateCmd handles the validate subcommand
func validateCmd() <span class="cov0" title="0">{
        // Parse remaining args
        files := os.Args[2:]
        if len(files) == 0 </span><span class="cov0" title="0">{
                files = []string{"config.toml"}
        }</span>

        <span class="cov0" title="0">hasErrors := false
        for _, file := range files </span><span class="cov0" title="0">{
                fmt.Printf("Validating %s...\n", file)
                _, _, _, _, err := config.LoadConfig(file)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "âŒ ERROR: %v\n", err)
                        hasErrors = true
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("âœ“ Valid\n")
                }</span>
        }

        <span class="cov0" title="0">if hasErrors </span><span class="cov0" title="0">{
                os.Exit(1)
        }</span>
}

// generateReportsCmd handles the generate-reports subcommand
func generateReportsCmd() <span class="cov0" title="0">{
        startTime := time.Now()
        fmt.Println("Regenerating all reports with latest template...")

        // Determine repo root
        repoRoot, _ := git.DetectRepoRoot()

        // Get output root from default config
        cfg, _, _, _, err := config.LoadConfig("")
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "ERROR: failed to load config: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">mergedCfg := config.MergeWithDefaults(cfg)
        outputRoot := filepath.Join(repoRoot, mergedCfg.Defaults.OutputRoot)

        // Count runs before regenerating
        runsDir := filepath.Join(outputRoot, "runs")
        entries, err := os.ReadDir(runsDir)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "ERROR: failed to read runs directory: %v\n", err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">numRuns := len(entries)

        // Regenerate all reports
        if err := dashboard.GenerateDashboardWithOptions(outputRoot, version, true, ""); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "ERROR: failed to regenerate reports: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">duration := time.Since(startTime)
        fmt.Printf("âœ“ Regenerated %d reports in %s\n", numRuns, duration.Round(time.Millisecond))
        fmt.Printf("ðŸ“Š Dashboard: %s\n", filepath.Join(outputRoot, "report.html"))</span>
}

// getTerminalWidth returns the current terminal width, defaulting to 160 if unable to detect
func getTerminalWidth() int <span class="cov1" title="1">{
        // Try to get terminal width using stty
        cmd := exec.Command("stty", "size")
        cmd.Stdin = os.Stdin
        out, err := cmd.Output()
        if err == nil </span><span class="cov0" title="0">{
                var rows, cols int
                if _, err := fmt.Sscanf(string(out), "%d %d", &amp;rows, &amp;cols); err == nil &amp;&amp; cols &gt; 0 </span><span class="cov0" title="0">{
                        return cols
                }</span>
        }

        // Default to 160 columns if we can't detect
        <span class="cov1" title="1">return 160</span>
}

// wrapText wraps text to specified width, breaking on word boundaries
func wrapText(text string, width int) []string <span class="cov3" title="3">{
        if text == "" </span><span class="cov1" title="1">{
                return []string{}
        }</span>

        <span class="cov2" title="2">var lines []string
        words := strings.Fields(text)
        if len(words) == 0 </span><span class="cov0" title="0">{
                return []string{}
        }</span>

        <span class="cov2" title="2">currentLine := words[0]
        for _, word := range words[1:] </span><span class="cov6" title="17">{
                if len(currentLine)+1+len(word) &lt;= width </span><span class="cov6" title="15">{
                        currentLine += " " + word
                }</span> else<span class="cov2" title="2"> {
                        lines = append(lines, currentLine)
                        currentLine = word
                }</span>
        }
        <span class="cov2" title="2">if currentLine != "" </span><span class="cov2" title="2">{
                lines = append(lines, currentLine)
        }</span>

        <span class="cov2" title="2">return lines</span>
}

// truncate truncates a string to the specified length with "..." if needed
func truncate(s string, maxLen int) string <span class="cov3" title="3">{
        if len(s) &lt;= maxLen </span><span class="cov2" title="2">{
                return s
        }</span>
        <span class="cov1" title="1">if maxLen &lt;= 3 </span><span class="cov0" title="0">{
                return s[:maxLen]
        }</span>
        <span class="cov1" title="1">return s[:maxLen-3] + "..."</span>
}

// phaseEmoji returns an emoji for a phase based on its name
func phaseEmoji(phaseName string) string <span class="cov4" title="5">{
        // Normalize to lowercase for matching
        name := strings.ToLower(phaseName)

        // Map phase names/keywords to emojis
        emojiMap := map[string]string{
                "validation":  "ðŸ§ª",  // Test tube for validation/testing
                "test":        "ðŸ§ª",  // Test tube
                "testing":     "ðŸ§ª",  // Test tube
                "build":       "ðŸ“¦",  // Package for build
                "package":     "ðŸ“¦",  // Package
                "compile":     "ðŸ”¨",  // Hammer for compilation
                "deploy":      "ðŸš€",  // Rocket for deployment
                "release":     "ðŸš€",  // Rocket for release
                "lint":        "ðŸ”",  // Magnifying glass for linting
                "security":    "ðŸ”’",  // Lock for security
                "e2e":         "ðŸŽ¯",  // Target for end-to-end tests
                "end-to-end":  "ðŸŽ¯",  // Target
                "integration": "ðŸ”—",  // Link for integration
                "setup":       "âš™ï¸", // Gear for setup
                "cleanup":     "ðŸ§¹",  // Broom for cleanup
                "docs":        "ðŸ“š",  // Books for documentation
                "publish":     "ðŸ“¤",  // Outbox for publishing
        }

        // Check for exact match first
        if emoji, ok := emojiMap[name]; ok </span><span class="cov3" title="4">{
                return emoji
        }</span>

        // Check if any keyword is contained in the phase name
        <span class="cov1" title="1">for keyword, emoji := range emojiMap </span><span class="cov6" title="17">{
                if strings.Contains(name, keyword) </span><span class="cov0" title="0">{
                        return emoji
                }</span>
        }

        // Default emoji
        <span class="cov1" title="1">return "ðŸ“‹"</span> // Clipboard as default
}

// loadTaskAveragesLast25 loads task average durations from last 25 runs
func loadTaskAveragesLast25(outputRoot string) map[string]float64 <span class="cov3" title="3">{
        averages := make(map[string]float64)

        summaryPath := filepath.Join(outputRoot, "summary.json")
        data, err := os.ReadFile(summaryPath)
        if err != nil </span><span class="cov1" title="1">{
                return averages // No history yet
        }</span>

        <span class="cov2" title="2">var summary struct {
                TaskStatsLast25 map[string]struct {
                        AvgDuration float64 `json:"avgDuration"`
                } `json:"taskStatsLast25"`
        }

        if err := json.Unmarshal(data, &amp;summary); err != nil </span><span class="cov0" title="0">{
                return averages
        }</span>

        <span class="cov2" title="2">for taskID, stats := range summary.TaskStatsLast25 </span><span class="cov3" title="4">{
                if stats.AvgDuration &gt; 0 </span><span class="cov3" title="3">{
                        averages[taskID] = stats.AvgDuration
                }</span>
        }

        <span class="cov2" title="2">return averages</span>
}

// listCmd handles the list subcommand
func listCmd() <span class="cov0" title="0">{
        // Parse flags
        fs := flag.NewFlagSet("list", flag.ExitOnError)
        verbose := fs.Bool("verbose", false, "Show detailed table view with phases")
        configPath := fs.String("config", "", "Path to config file (default: config.toml)")
        fs.Parse(os.Args[2:])

        // Load configuration
        cfg, configTaskOrder, phaseNames, taskToPhase, err := config.LoadConfig(*configPath)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "ERROR: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">if cfg == nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "ERROR: No config.toml found. Create one or specify with --config flag\n")
                os.Exit(1)
        }</span>

        // Merge with defaults
        <span class="cov0" title="0">mergedCfg := config.MergeWithDefaults(cfg)

        // Determine repo root
        repoRoot, _ := git.DetectRepoRoot()

        // Load historical averages
        outputRoot := filepath.Join(repoRoot, mergedCfg.Defaults.OutputRoot)
        taskAverages := loadTaskAveragesLast25(outputRoot)

        // Build task list (filter out phase markers)
        var tasks []struct {
                id    string
                task  config.TaskConfig
                phase string
        }

        for _, id := range configTaskOrder </span><span class="cov0" title="0">{
                // Skip wait markers and phase headers
                if id == "wait" || strings.HasPrefix(id, "wait-") || strings.HasPrefix(id, "phase-") </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">taskCfg, ok := mergedCfg.Tasks[id]
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Get phase name
                <span class="cov0" title="0">phaseName := ""
                if phaseID, ok := taskToPhase[id]; ok </span><span class="cov0" title="0">{
                        for _, phaseInfo := range phaseNames </span><span class="cov0" title="0">{
                                if phaseInfo.ID == phaseID </span><span class="cov0" title="0">{
                                        phaseName = phaseInfo.Name
                                        break</span>
                                }
                        }
                }

                <span class="cov0" title="0">tasks = append(tasks, struct {
                        id    string
                        task  config.TaskConfig
                        phase string
                }{id, taskCfg, phaseName})</span>
        }

        <span class="cov0" title="0">if len(tasks) == 0 </span><span class="cov0" title="0">{
                fmt.Println("No tasks found in config")
                return
        }</span>

        // Simple mode: just list task IDs
        <span class="cov0" title="0">if !*verbose </span><span class="cov0" title="0">{
                for _, t := range tasks </span><span class="cov0" title="0">{
                        fmt.Println(t.id)
                }</span>
                <span class="cov0" title="0">return</span>
        }

        // Verbose mode: table view grouped by phase
        <span class="cov0" title="0">fmt.Println("Tasks:")
        fmt.Println()

        // Group tasks by phase
        type phaseGroup struct {
                name  string
                tasks []struct {
                        id   string
                        task config.TaskConfig
                }
        }

        var phases []phaseGroup
        currentPhase := phaseGroup{name: "(no phase)"}

        for _, t := range tasks </span><span class="cov0" title="0">{
                if t.phase != "" &amp;&amp; (len(currentPhase.tasks) == 0 || currentPhase.name != t.phase) </span><span class="cov0" title="0">{
                        // Start new phase
                        if len(currentPhase.tasks) &gt; 0 </span><span class="cov0" title="0">{
                                phases = append(phases, currentPhase)
                        }</span>
                        <span class="cov0" title="0">currentPhase = phaseGroup{name: t.phase}</span>
                }
                <span class="cov0" title="0">currentPhase.tasks = append(currentPhase.tasks, struct {
                        id   string
                        task config.TaskConfig
                }{t.id, t.task})</span>
        }
        <span class="cov0" title="0">if len(currentPhase.tasks) &gt; 0 </span><span class="cov0" title="0">{
                phases = append(phases, currentPhase)
        }</span>

        // Get terminal width
        <span class="cov0" title="0">termWidth := getTerminalWidth()

        // Column widths (fixed for name, desc, type, duration, command)
        nameWidth := 40
        durationWidth := 13 // "âš ï¸  ~2ms" format (emoji takes more space)
        typeWidth := 18
        cmdWidth := 45
        spacing := 10 // 2 spaces between each column (5 gaps)
        descWidth := termWidth - nameWidth - durationWidth - typeWidth - cmdWidth - spacing
        if descWidth &lt; 20 </span><span class="cov0" title="0">{
                descWidth = 20 // Minimum description width
        }</span>

        // Print each phase
        <span class="cov0" title="0">for _, phase := range phases </span><span class="cov0" title="0">{
                // Calculate phase average duration
                var phaseAvgMs float64
                var phaseTaskCount int
                for _, t := range phase.tasks </span><span class="cov0" title="0">{
                        if avg, ok := taskAverages[t.id]; ok </span><span class="cov0" title="0">{
                                phaseAvgMs += avg
                                phaseTaskCount++
                        }</span>
                }

                // Phase header with emoji and duration in a box
                <span class="cov0" title="0">emoji := phaseEmoji(phase.name)
                var phaseText string
                var durationTextPlain string
                if phaseTaskCount &gt; 0 </span><span class="cov0" title="0">{
                        phaseAvgSec := phaseAvgMs / 1000
                        durationTextPlain = fmt.Sprintf(" (~%.1fs)", phaseAvgSec)

                        // Gray color for phase duration (grouping, not individual timing)
                        grayDuration := fmt.Sprintf("\033[90m(~%.1fs)\033[0m", phaseAvgSec)
                        phaseText = fmt.Sprintf("%s %s %s", emoji, phase.name, grayDuration)
                }</span> else<span class="cov0" title="0"> {
                        phaseText = fmt.Sprintf("%s %s", emoji, phase.name)
                }</span>
                // Calculate visual width: emoji (2) + space (1) + name + duration text + padding (2)
                <span class="cov0" title="0">visualWidth := 2 + 1 + len(phase.name) + len(durationTextPlain) + 2

                // Top border
                fmt.Println("â”Œ" + strings.Repeat("â”€", visualWidth) + "â”")
                // Header with bold
                fmt.Printf("â”‚\033[1m %s \033[0mâ”‚\n", phaseText)
                // Bottom border
                fmt.Println("â””" + strings.Repeat("â”€", visualWidth) + "â”˜")
                fmt.Println()

                // Table header (AVG is right-aligned)
                fmt.Printf("%-*s  %-*s  %-*s  %-*s  %*s\n", nameWidth, "NAME", descWidth, "DESCRIPTION", typeWidth, "TYPE", cmdWidth, "COMMAND", durationWidth, "AVG")
                fmt.Printf("%s  %s  %s  %s  %s\n", strings.Repeat("â”€", nameWidth), strings.Repeat("â”€", descWidth), strings.Repeat("â”€", typeWidth), strings.Repeat("â”€", cmdWidth), strings.Repeat("â”€", durationWidth))

                // Tasks
                for _, t := range phase.tasks </span><span class="cov0" title="0">{
                        resolvedTask := mergedCfg.ResolveTaskConfig(t.id, t.task, repoRoot)

                        // Add metrics emoji if present
                        metricsEmoji := ""
                        emojiDisplayWidth := 0
                        if resolvedTask.MetricsFormat != "" </span><span class="cov0" title="0">{
                                switch resolvedTask.MetricsFormat </span>{
                                case "junit":<span class="cov0" title="0">
                                        metricsEmoji = " ðŸ§ª"
                                        emojiDisplayWidth = 3</span> // space + emoji (2 display chars)
                                case "sarif":<span class="cov0" title="0">
                                        metricsEmoji = " ðŸ”’"
                                        emojiDisplayWidth = 3</span>
                                case "artifact":<span class="cov0" title="0">
                                        metricsEmoji = " ðŸ“¦"
                                        emojiDisplayWidth = 3</span>
                                }
                        }

                        // Calculate display widths
                        <span class="cov0" title="0">baseName := resolvedTask.Name
                        idText := t.id
                        // Total display width: name + emoji(if any) + space + id
                        totalDisplayWidth := len(baseName) + emojiDisplayWidth + 1 + len(idText)

                        // Truncate if needed
                        if totalDisplayWidth &gt; nameWidth </span><span class="cov0" title="0">{
                                // Truncate the base name to fit
                                availableForName := nameWidth - emojiDisplayWidth - 1 - len(idText) - 3 // -3 for "..."
                                if availableForName &gt; 0 </span><span class="cov0" title="0">{
                                        baseName = baseName[:availableForName] + "..."
                                        totalDisplayWidth = nameWidth
                                }</span> else<span class="cov0" title="0"> {
                                        // Even the ID is too long, truncate everything
                                        baseName = truncate(baseName+metricsEmoji+" "+idText, nameWidth)
                                        metricsEmoji = ""
                                        idText = ""
                                        totalDisplayWidth = nameWidth
                                }</span>
                        }

                        // Format with colors: name + emoji, then gray ID
                        <span class="cov0" title="0">var nameFormatted string
                        if idText != "" </span><span class="cov0" title="0">{
                                nameFormatted = fmt.Sprintf("%s%s \033[90m%s\033[0m", baseName, metricsEmoji, idText)
                        }</span> else<span class="cov0" title="0"> {
                                nameFormatted = baseName
                        }</span>

                        // Calculate padding needed
                        <span class="cov0" title="0">padding := nameWidth - totalDisplayWidth
                        if padding &lt; 0 </span><span class="cov0" title="0">{
                                padding = 0
                        }</span>

                        // Format type
                        <span class="cov0" title="0">taskType := resolvedTask.Type
                        if taskType == "" </span><span class="cov0" title="0">{
                                taskType = "-"
                        }</span>

                        // Truncate command if too long
                        <span class="cov0" title="0">cmd := resolvedTask.Command
                        if len(cmd) &gt; cmdWidth </span><span class="cov0" title="0">{
                                cmd = cmd[:cmdWidth-3] + "..."
                        }</span>

                        // Truncate description to fit in one line
                        <span class="cov0" title="0">desc := resolvedTask.Desc
                        if len(desc) &gt; descWidth </span><span class="cov0" title="0">{
                                desc = desc[:descWidth-3] + "..."
                        }</span>

                        // Format duration with color coding
                        <span class="cov0" title="0">var durationStr string
                        var visualLen int
                        if avgMs, ok := taskAverages[t.id]; ok &amp;&amp; avgMs &gt; 0 </span><span class="cov0" title="0">{
                                avgSec := avgMs / 1000
                                var timeStr string
                                if avgSec &lt; 1 </span><span class="cov0" title="0">{
                                        // Force 1 decimal place for milliseconds too
                                        timeStr = fmt.Sprintf("~%.1fms", avgMs)
                                }</span> else<span class="cov0" title="0"> if avgSec &lt; 60 </span><span class="cov0" title="0">{
                                        timeStr = fmt.Sprintf("~%.1fs", avgSec)
                                }</span> else<span class="cov0" title="0"> {
                                        minutes := avgSec / 60
                                        timeStr = fmt.Sprintf("~%.1fm", minutes)
                                }</span>

                                // Special case: â‰¤3ms likely means echo/mock, not real timing
                                <span class="cov0" title="0">if avgMs &lt;= 3 </span><span class="cov0" title="0">{
                                        durationStr = fmt.Sprintf("\033[31m[!] %s\033[0m", timeStr) // Red with warning (using [!] instead of emoji)
                                        visualLen = 4 + len(timeStr)                                // [!] (3) + space (1) + time
                                        // Green shades (fast - instant feedback)
                                }</span> else<span class="cov0" title="0"> if avgMs &lt; 100 </span><span class="cov0" title="0">{
                                        durationStr = fmt.Sprintf("\033[38;5;46m%s\033[0m", timeStr) // Bright green
                                        visualLen = len(timeStr)
                                }</span> else<span class="cov0" title="0"> if avgMs &lt; 500 </span><span class="cov0" title="0">{
                                        durationStr = fmt.Sprintf("\033[38;5;40m%s\033[0m", timeStr) // Medium green
                                        visualLen = len(timeStr)
                                }</span> else<span class="cov0" title="0"> if avgSec &lt; 1 </span><span class="cov0" title="0">{
                                        durationStr = fmt.Sprintf("\033[38;5;34m%s\033[0m", timeStr) // Darker green
                                        visualLen = len(timeStr)
                                        // Yellow shades (moderate - acceptable)
                                }</span> else<span class="cov0" title="0"> if avgSec &lt; 5 </span><span class="cov0" title="0">{
                                        durationStr = fmt.Sprintf("\033[38;5;226m%s\033[0m", timeStr) // Bright yellow
                                        visualLen = len(timeStr)
                                }</span> else<span class="cov0" title="0"> if avgSec &lt; 10 </span><span class="cov0" title="0">{
                                        durationStr = fmt.Sprintf("\033[38;5;220m%s\033[0m", timeStr) // Medium yellow
                                        visualLen = len(timeStr)
                                }</span> else<span class="cov0" title="0"> if avgSec &lt; 20 </span><span class="cov0" title="0">{
                                        durationStr = fmt.Sprintf("\033[38;5;214m%s\033[0m", timeStr) // Darker yellow/amber
                                        visualLen = len(timeStr)
                                        // Orange shades (slow - noticeable)
                                }</span> else<span class="cov0" title="0"> if avgSec &lt; 30 </span><span class="cov0" title="0">{
                                        durationStr = fmt.Sprintf("\033[38;5;208m%s\033[0m", timeStr) // Light orange
                                        visualLen = len(timeStr)
                                }</span> else<span class="cov0" title="0"> if avgSec &lt; 45 </span><span class="cov0" title="0">{
                                        durationStr = fmt.Sprintf("\033[38;5;202m%s\033[0m", timeStr) // Medium orange
                                        visualLen = len(timeStr)
                                }</span> else<span class="cov0" title="0"> if avgSec &lt; 60 </span><span class="cov0" title="0">{
                                        durationStr = fmt.Sprintf("\033[38;5;196m%s\033[0m", timeStr) // Dark orange
                                        visualLen = len(timeStr)
                                        // Red shades (very slow - needs attention)
                                }</span> else<span class="cov0" title="0"> if avgSec &lt; 180 </span><span class="cov0" title="0">{ // &lt; 3 min
                                        durationStr = fmt.Sprintf("\033[38;5;160m%s\033[0m", timeStr) // Light red
                                        visualLen = len(timeStr)
                                }</span> else<span class="cov0" title="0"> if avgSec &lt; 600 </span><span class="cov0" title="0">{ // &lt; 10 min
                                        durationStr = fmt.Sprintf("\033[38;5;124m%s\033[0m", timeStr) // Medium red
                                        visualLen = len(timeStr)
                                }</span> else<span class="cov0" title="0"> {
                                        durationStr = fmt.Sprintf("\033[38;5;88m%s\033[0m", timeStr) // Dark red
                                        visualLen = len(timeStr)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                durationStr = "-"
                                visualLen = 1
                        }</span>

                        // Right-align the duration by padding on the left
                        <span class="cov0" title="0">leftPadding := durationWidth - visualLen
                        if leftPadding &lt; 0 </span><span class="cov0" title="0">{
                                leftPadding = 0
                        }</span>

                        // Print row with proper padding (name, desc, type, command, right-aligned avg)
                        <span class="cov0" title="0">fmt.Printf("%s%s  %-*s  %-*s  %-*s  %s%s\n", nameFormatted, strings.Repeat(" ", padding), descWidth, desc, typeWidth, taskType, cmdWidth, cmd, strings.Repeat(" ", leftPadding), durationStr)</span>
                }
                <span class="cov0" title="0">fmt.Println()</span>
        }

        // Calculate total average
        <span class="cov0" title="0">var totalAvgMs float64
        var totalTasksWithAvg int
        for _, t := range tasks </span><span class="cov0" title="0">{
                if avg, ok := taskAverages[t.id]; ok </span><span class="cov0" title="0">{
                        totalAvgMs += avg
                        totalTasksWithAvg++
                }</span>
        }

        <span class="cov0" title="0">if totalTasksWithAvg &gt; 0 </span><span class="cov0" title="0">{
                totalAvgSec := totalAvgMs / 1000
                // Gray color for total (summary, not individual timing)
                fmt.Printf("Total: %d tasks \033[90m(~%.1fs avg)\033[0m\n", len(tasks), totalAvgSec)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("Total: %d tasks\n", len(tasks))
        }</span>
}

// sarifCmd handles the sarif subcommand
func sarifCmd() <span class="cov0" title="0">{
        // Define flags for sarif subcommand
        fs := flag.NewFlagSet("sarif", flag.ExitOnError)
        verbose := fs.Bool("v", false, "Verbose output (show severity, tags, precision, descriptions)")
        summary := fs.Bool("s", false, "Show summary grouped by rule")
        dir := fs.String("d", "", "Directory to search for SARIF files")

        fs.Usage = func() </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Usage: %s sarif [options] &lt;sarif-file&gt; [&lt;sarif-file&gt;...]\n", os.Args[0])
                fmt.Fprintf(os.Stderr, "   or: %s sarif -d &lt;directory&gt;\n\n", os.Args[0])
                fmt.Fprintf(os.Stderr, "View SARIF (Static Analysis Results Interchange Format) files in human-readable format.\n\n")
                fmt.Fprintf(os.Stderr, "Options:\n")
                fs.PrintDefaults()
                fmt.Fprintf(os.Stderr, "\nIf no file is specified, looks for tmp/codeql/results.sarif\n")
                fmt.Fprintf(os.Stderr, "\nExamples:\n")
                fmt.Fprintf(os.Stderr, "  %s sarif tmp/codeql/results.sarif           # Default format\n", os.Args[0])
                fmt.Fprintf(os.Stderr, "  %s sarif -v tmp/codeql/results.sarif        # Verbose with metadata\n", os.Args[0])
                fmt.Fprintf(os.Stderr, "  %s sarif -s tmp/codeql/results.sarif        # Summary by rule\n", os.Args[0])
                fmt.Fprintf(os.Stderr, "  %s sarif -d tmp/                            # Scan directory\n", os.Args[0])
        }</span>

        // Parse flags (skip "sarif" subcommand)
        <span class="cov0" title="0">fs.Parse(os.Args[2:])

        // Get SARIF file(s)
        var files []string
        if *dir != "" </span><span class="cov0" title="0">{
                // Search directory for SARIF files
                found, err := sarif.FindSARIFFiles(*dir)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "Error searching directory: %v\n", err)
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">files = found</span>
        } else<span class="cov0" title="0"> if fs.NArg() &gt; 0 </span><span class="cov0" title="0">{
                // Use files from arguments
                files = fs.Args()
        }</span> else<span class="cov0" title="0"> {
                // Default: look for SARIF files in tmp/codeql
                defaultPath := "tmp/codeql/results.sarif"
                if _, err := os.Stat(defaultPath); err == nil </span><span class="cov0" title="0">{
                        files = []string{defaultPath}
                }</span> else<span class="cov0" title="0"> {
                        fs.Usage()
                        os.Exit(1)
                }</span>
        }

        <span class="cov0" title="0">if len(files) == 0 </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "No SARIF files found\n")
                os.Exit(1)
        }</span>

        // Process all files
        <span class="cov0" title="0">var allFindings []sarif.Finding
        for _, file := range files </span><span class="cov0" title="0">{
                // Parse SARIF file
                doc, err := sarif.Parse(file)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "Error parsing %s: %v\n", file, err)
                        continue</span>
                }

                <span class="cov0" title="0">findings := doc.GetFindings()

                // If multiple files, show which file we're processing
                if len(files) &gt; 1 &amp;&amp; len(findings) &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Printf("\nðŸ“„ %s:\n", filepath.Base(file))
                }</span>

                <span class="cov0" title="0">allFindings = append(allFindings, findings...)</span>
        }

        // Display results
        <span class="cov0" title="0">if *summary </span><span class="cov0" title="0">{
                sarif.PrintSummary(allFindings)
        }</span> else<span class="cov0" title="0"> {
                sarif.PrintFindings(allFindings, *verbose)
        }</span>

        // Exit with error code if issues found
        <span class="cov0" title="0">if len(allFindings) &gt; 0 </span><span class="cov0" title="0">{
                os.Exit(1)
        }</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
